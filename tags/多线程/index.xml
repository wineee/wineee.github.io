<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>多线程 on REWINE NOTE</title><link>/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><description>Recent content in 多线程 on REWINE NOTE</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>使用c++解决leetcode多线程题题目（之一）semaphore</title><link>/post/leetcode_cpp_sem/</link><pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate><guid>/post/leetcode_cpp_sem/</guid><description>&lt;p>通过 &lt;code>man sem_init&lt;/code> 可以查看具体文档。
或者使用： &lt;a href="https://man7.org/linux/man-pages/man3/sem_init.3.html" target="_blank">https://man7.org/linux/man-pages/man3/sem_init.3.html&lt;/a>&lt;/p>
&lt;p>sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。pshared 参数指明信号量是由进程内共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享。value 参数指定的初始值。&lt;/p>
&lt;p>sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的。&lt;/p>
&lt;p>sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。&lt;/p></description></item></channel></rss>