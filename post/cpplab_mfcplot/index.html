<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.74.3"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg color=#8aa2d3><link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico><meta name=theme-color content="#ffffff"><title>[VC++课程设计] 用mfc实现数学函数曲线绘制程序 - REWINE NOTE</title><meta name=author content="rewine"><meta name=description content="mfc plot mathematical functions"><meta name=keywords content="c++,mfc,lab"><meta property="og:title" content="[VC++课程设计] 用mfc实现数学函数曲线绘制程序"><meta name=twitter:title content="[VC++课程设计] 用mfc实现数学函数曲线绘制程序"><meta property="og:type" content="article"><meta property="og:url" content="https://wineee.github.io/post/cpplab_mfcplot/"><meta property="og:description" content="mfc plot mathematical functions"><meta name=twitter:description content="mfc plot mathematical functions"><meta property="og:image" content="https://wineee.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wineee.github.io/img/og.png"><meta property="article:published_time" content="2020-07-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-20T00:00:00+00:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://wineee.github.io/assets/css/fuji.min.css></head><body data-theme=auto><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');if(!fujiThemeData){localStorage.setItem('fuji_data-theme','auto');}else{if(fujiThemeData!=='auto'){document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light');}}</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://wineee.github.io>REWINE NOTE</a>
<span class=title-sub>Informatik verbindet dich und mich.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://wineee.github.io/post/cpplab_mfcplot/>[VC++课程设计] 用mfc实现数学函数曲线绘制程序</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-07-20</span><span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3371 字</span><span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/c++>c++</a>&nbsp;<a href=/tags/mfc>mfc</a>&nbsp;<a href=/tags/lab>lab</a>&nbsp;</span></div><div class="post-content markdown-body"><h3 id=实验环境>实验环境</h3><ul><li>window 10 版本19041</li><li>Microsoft Visual Studio Community 2019 版本 16.6.4</li></ul><h3 id=实现功能>实现功能</h3><ul><li><input checked disabled type=checkbox> 绘制常见函数的图像</li><li><input checked disabled type=checkbox> 支持普通函数，极坐标函数，参数方程，直接输入数据点</li><li><input checked disabled type=checkbox> 可以删除指定函数图像</li><li><input checked disabled type=checkbox> 可以在一个坐标系中绘制多条数学曲线</li><li><input checked disabled type=checkbox> 显示坐标轴，网格，刻度值，图例</li><li><input checked disabled type=checkbox> 可以选择不同颜色线型来绘制不同的曲线</li><li><input checked disabled type=checkbox> 当鼠标移动到曲线上某点时，可以显示该点的坐标</li><li><input checked disabled type=checkbox> 可以用鼠标拖动图像</li><li><input checked disabled type=checkbox> 可以进行图形的放大，缩小，定量设置显示范围，自动缩放</li><li><input checked disabled type=checkbox> 普通函数x取值范围可设置为跟随显示范围变化</li><li><input checked disabled type=checkbox> 状态栏实时显示鼠标位置，双击显示鼠标精确位置</li><li><input checked disabled type=checkbox> 重要数据的序列化和反序列化</li><li><input disabled type=checkbox> 突变函数(如$floor(x)$)和部分y值接近无穷的函数(如$tan(x)$)无法完美显示</li></ul><h3 id=界面展示>界面展示</h3><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720012121800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述>
<img class=img-zoomable src="https://img-blog.csdnimg.cn/2020072001273763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述>
<img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720014118171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述>
<img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720014136668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720014609420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述>
<img class=img-zoomable src="https://img-blog.csdnimg.cn/2020072001464030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720014714925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h3 id=设计结构>设计结构</h3><h5 id=程序流程及设计>程序流程及设计</h5><p>  用户输入函数信息，显示函数图像。还可以通过菜单和工具栏更改设置。</p><p>  通过计算样本点，相邻样本点用直线连接，当样本点数量足够大时，可近似看成曲线。
<img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720162214892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720161921318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h5 id=程序所有源文件>程序所有源文件</h5><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720162844144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h5 id=calculatorfunccpp介绍>CalculatorFunc.cpp介绍</h5><blockquote><p>double CalcEquation(CString m_sEquation, bool& succ, char xKey, double xVal)
m_sEquation:表达式
succ:计算是否成功
xKey:未知数是"x"还是"t&rdquo;
xVal:未知数的值</p></blockquote><blockquote><p>此文件可以单独拿出来(把CString换成string就行)使用
bool succ = true;
double ans = CalcEquation(&ldquo;sin(x)+e^x&rdquo;,succ,&lsquo;x&rsquo;,1.1);</p></blockquote><p> 对方程，分为数（常数，未知数x），双目运算符(+ , - ,* , / , ^ ) ,单目运算符(sin,cos等等)，单目运算符后面是一个完整的子式，如2+cos(x+1)中，x+1就是一个完整的式子，通过递归调用可以求子式的值，如果已知子式值，这个[单目运算符+子式]就是一个已知数了，那剩下的就等效于只有+ , - , * , / , ^ 的公式，用表达式栈法就可以解决。</p><h5 id=funcdatacpp介绍>FuncData.cpp介绍</h5><p><img class=img-zoomable src="https://img-blog.csdnimg.cn/20200720161950216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODMxMzYw,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><pre><code class=language-cpp>FuncData类
成员变量：
	int FuncCas;            //函数类型
	CString m_Equation;		//函数表达式
	double minX, maxX;		//x极值
	double maxY, minY;		//y极值
	int stepX;				//可以理解为样本点的数量
	int m_penWidth;			//画笔宽度
	int m_penType;			//画笔类型
	COLORREF m_color;		//画笔颜色
	vector&lt;pair&lt;double, double&gt; &gt; vetPoint;			 //储存所有样本点
成员函数：
	virtual double GetY(double xVal, bool&amp; succ) = 0;//得到未知数为xVal时函数值，succ表示计算是否成功
	virtual bool CalcList() = 0;					 //计算vetPoint
	virtual bool GetNearest(pair&lt;double,double&gt; NowPoint, pair&lt;double, double&gt; &amp;CmpPoint);//获取本函数与NowPoint最近的点
	virtual CString GetEquation2();					 //为了得到参数方程第二个函数式
	FuncData();
	FuncData(CString Equation,double minX,double maxX,int stepX,COLORREF color, int penWidth,int penType);//构造函数

注意:此处派生类只记录特有的成员
NormalFD类
无

PolarFD 类
成员变量
double maxth, minth;   //自变量θ取值范围

TwoFD类
成员变量
CString m_EquationY;
double maxT, minT;
成员函数
double GetX(double tVal, bool&amp; succ);//参数方程X也需要求值
	virtual double GetY(double tVal, bool&amp; succ);

DataFD类
成员函数
	static int DataFD_Cnt;  //记录数据点类型函数数量
</code></pre><h5 id=mfcplotdoccpp介绍>mfcplotDoc.cpp介绍</h5><p> mfcplotDoc中记录着设置信息和函数数据，主要内容如下</p><pre><code class=language-cpp>public:
	bool m_WillShowGrid; //是否显示网格
	bool m_WillShowAxis; //是否显示坐标轴
	bool m_WillShowEdge; //是否显示边框
	bool m_SingelMode;   //单函数模式添加函数自动删除上一个函数
	bool m_ForceXrange;	 //普通函数x范围是否固定，不固定的话随显示范围变化
	bool m_ShowNearPoint;//鼠标接近函数线时是否显示其坐标
	double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//显示范围
	FuncData *m_FD;//临时变量
	CObList m_List;//记录所有函数信息
public:
	afx_msg void OnAxisMenu();//坐标轴
	afx_msg void OnGridMenu();//网格
	afx_msg void OnEdgeMenu();//边框
	afx_msg void OnSmallerMenu();//显示范围缩小 0.8
	afx_msg void OnBiggerMenu();//显示范围放大 1.25
	afx_msg void OnNormalFuncMenu();//增加普通函数
	afx_msg void OnMenuSetXyrange();//设置显示范围
	afx_msg void OnFuncMode();//单/多函数模式
	afx_msg void OnPolarFuncMenu();//增加极坐标函数
	afx_msg void OnTwoFuncMenu();//增加参数方程函数
	afx_msg void OnDataFuncMenu();//增加数据点型函数
	afx_msg void OnFroceXrang();//普通函数x范围是否固定
	afx_msg void OnNearpointMenu();//是否显示最近点
	afx_msg void OnAutorangeMenu();//自动调整显示范围，正好显示完整函数图像
	afx_msg void OnDelfunconeMenu();//删除一个函数
	afx_msg void OnDelallMenu();//删除所有函数
</code></pre><h5 id=mfcplotviewcpp介绍>mfcplotView.cpp介绍</h5><p> 绘图逻辑是在这里实现的，主要内容如下</p><pre><code class=language-cpp>public:
	double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//函数显示范围
	int nTop, nButton, nLeft, nRight;//对应的逻辑坐标范围
	int isMoving;//拖动状态 0不拖动 1拖动模式 2正在拖动
	double tmp_Xmin, tmp_Xmax, tmp_Ymin, tmp_Ymax;
	//拖动模式下，单击鼠标左键，记录起点的显示范围
	CPoint m_posStart;
	//拖动模式下，单击鼠标左键，记录起点的鼠标坐标
	//根据鼠标坐标偏移量可以计算显示范围变化量
</code></pre><p> 函数中LPxtoFPx表示把函数坐标x变成pDC可以用的逻辑坐标_x，原理函数坐标范围m_Xmin，m_Xmax到逻辑坐标范围nLeft，nRight（下面函数会给出）等比例的映射。</p><pre><code class=language-cpp>double CmfcplotView::LPxtoFPx(int x) {
	return m_Xmin + (1.0 * x - nLeft) * (m_Xmax - m_Xmin) / (1.0 * nRight - nLeft);
}
</code></pre><p> 实现坐标转换后就可以进行绘图工作了。</p><pre><code class=language-cpp>void CmfcplotView::OnDraw(CDC* pDC)
{
	CmfcplotDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;
	m_Xmin = pDoc-&gt;m_Xmin;//极值保存在Doc中
	m_Xmax = pDoc-&gt;m_Xmax;
	m_Ymin = pDoc-&gt;m_Ymin;
	m_Ymax = pDoc-&gt;m_Ymax;
	
	CRect rect;
	GetClientRect(&amp;rect);//获得视图区

	nTop = (int)round(rect.bottom * 0.1);  //函数图像不会占据整个视图区
	nButton = (int)round(rect.bottom * 0.9);
	nLeft = (int)round(rect.right * 0.1);
	nRight = (int)round(rect.right * 0.9);

	if (pDoc-&gt;m_WillShowEdge) {//画边框
		pDC-&gt;MoveTo(nLeft, nTop);
		pDC-&gt;LineTo(nLeft, nButton);
		pDC-&gt;LineTo(nRight, nButton);
		pDC-&gt;LineTo(nRight, nTop);
		pDC-&gt;LineTo(nLeft, nTop);
	}

	//画x坐标信息
	int nX,nY;
	bool BIGX = abs(m_Xmin) &gt; 100 || abs(m_Xmax) &gt; 100;//x坐标值比较大时，标注更稀
	for (nX = nLeft; nX &lt; nRight; nX += (BIGX ? 100 : 50)) { //每隔100/50像素一个标注
		CRect textRect(nX - (BIGX ? 50 : 25), nButton + 1, nX + (BIGX ? 50 : 25), nButton + 20);//显示区域
		CString xInfo;
		xInfo.Format(_T(&quot;%.2f&quot;),LPxtoFPx(nX));
		pDC-&gt;DrawText(xInfo, &amp;textRect, DT_SINGLELINE | DT_CENTER);
		                                    //单行,上下左右居中显示
	}
	if (nX - nRight &lt;= (BIGX ? 50 : 25)) {//最后一个x坐标，与前一个标注距离太近则不显示
		CRect textRect(nRight, nButton + 1, nRight + 50, nButton + 20);
		CString xInfo;
		xInfo.Format(_T(&quot;%.2f&quot;),m_Xmax);
		pDC-&gt;DrawText(xInfo, &amp;textRect, DT_SINGLELINE | DT_LEFT | DT_TOP);
	}

	//y坐标
	for (nY = nButton - 50; nY &gt; nTop; nY -= 50) {
		CRect textRect(nLeft - 200, nY-10, nLeft - 3, nY + 10);
		CString yInfo;
		yInfo.Format(_T(&quot;%.2f&quot;), LPytoFPy(nY));
		pDC-&gt;DrawText(yInfo, &amp;textRect, DT_SINGLELINE | DT_RIGHT);
	}
	if (nTop - nY &lt;= 25) {
		CRect textRect(nLeft - 200, nTop - 10, nLeft - 3, nTop + 10);
		CString yInfo;
		yInfo.Format(_T(&quot;%.2f&quot;),m_Ymax);
		pDC-&gt;DrawText(yInfo, &amp;textRect, DT_SINGLELINE | DT_BOTTOM | DT_RIGHT);
	}


	//  显示网格
	if (pDoc-&gt;m_WillShowGrid) {
		CPen pen(PS_DOT, 1, RGB(100, 100, 100));           //创建笔，虚线，并调整坐标颜色灰色
		CPen *pOldPen = (CPen *)pDC-&gt;SelectObject(&amp;pen);
		for (nX = nLeft+50; nX &lt; nRight; nX += 50) {
			pDC-&gt;MoveTo(nX, nTop);
			pDC-&gt;LineTo(nX, nButton);
		}
		for (nY = nButton - 50; nY &gt; nTop; nY -= 50) {
			pDC-&gt;MoveTo(nLeft, nY);
			pDC-&gt;LineTo(nRight, nY);
		}
		pDC-&gt;SelectObject(pOldPen);
	}

	// 显示坐标轴
	if (pDoc-&gt;m_WillShowAxis) {
		CPen pen(PS_SOLID, 2, RGB(0, 0, 0));
		CPen* pOldPen = (CPen*)pDC-&gt;SelectObject(&amp;pen);
		int oX = FPxtoLPx(0);
		int oY = FPytoLPy(0);
		bool showY = oX &gt;= nLeft &amp;&amp; oX &lt;= nRight;
		bool showX = oY &gt;= nTop &amp;&amp; oY &lt;= nButton;//判断x,y轴是否在范围内
		if (showX) {
			pDC-&gt;MoveTo(nLeft - 10, oY);
			pDC-&gt;LineTo(nRight + 10, oY);
		}
		if (showY) {
			pDC-&gt;MoveTo(oX, nButton + 10);
			pDC-&gt;LineTo(oX, nTop - 10);
		}
		if (showX &amp;&amp; showY) {
			pDC-&gt;TextOutW(oX + 1, oY + 1, _T(&quot;O&quot;));
		}
		if (showX) {
			pDC-&gt;MoveTo(nRight + 10, oY);
			pDC-&gt;LineTo(nRight + 5, oY + 5);
			pDC-&gt;MoveTo(nRight + 10, oY);
			pDC-&gt;LineTo(nRight + 5, oY - 5);
			pDC-&gt;TextOutW(nRight + 10, oY, _T(&quot;X轴&quot;));
		}
		if (showY) {
			pDC-&gt;MoveTo(oX, nTop - 10);
			pDC-&gt;LineTo(oX - 5, nTop - 5);
			pDC-&gt;MoveTo(oX, nTop - 10);
			pDC-&gt;LineTo(oX + 5, nTop - 5);
			pDC-&gt;TextOutW(oX + 5, nTop - 10, _T(&quot;Y轴&quot;));
		}
		pDC-&gt;SelectObject(pOldPen);
	}

	
	POSITION p = pDoc-&gt;m_List.GetHeadPosition();

	int showTop = nTop;
	while (p != nullptr) {
		bool shouldMov = true;//一段曲线第一个点MoveTo，其他都是LineTo
		FuncData* tmpFD = (FuncData*)pDoc-&gt;m_List.GetNext(p);
		CPen pen(tmpFD-&gt;m_penType, tmpFD-&gt;m_penWidth, tmpFD-&gt;m_color);
		CPen* pOldPen = (CPen*)pDC-&gt;SelectObject(&amp;pen);

		if (tmpFD-&gt;FuncCas == CAS_NORMAL) {//动态X坐标模式下，普通函数x范围与视图不同时自动同步
			if (pDoc-&gt;m_ForceXrange &amp;&amp; isMoving!=2)
				if (tmpFD-&gt;minX != m_Xmin || tmpFD-&gt;maxX != m_Xmax) {
					tmpFD-&gt;minX = m_Xmin;
					tmpFD-&gt;maxX = m_Xmax;
					tmpFD-&gt;CalcList();
				}
		}

		for (auto dot : tmpFD-&gt;vetPoint) {
			if (dot.first &lt; m_Xmin || dot.first &gt; m_Xmax || dot.second &lt; m_Ymin || dot.second &gt; m_Ymax || dot.second != dot.second) {
				shouldMov = true;
				continue;
			}
			if (shouldMov) {
				pDC-&gt;MoveTo(FPxtoLPx(dot.first), FPytoLPy(dot.second));
				shouldMov = false;
			}
			else
				pDC-&gt;LineTo(FPxtoLPx(dot.first), FPytoLPy(dot.second));
		}

		pDC-&gt;MoveTo(nRight+5, showTop);//显示图例
		pDC-&gt;LineTo(rect.right, showTop);
		showTop += 5;
		if (tmpFD-&gt;FuncCas == CAS_NORMAL)
		    pDC-&gt;TextOutW(nRight + 5, showTop, _T(&quot;f(x)=&quot;)+tmpFD-&gt;m_Equation);
		else if (tmpFD-&gt;FuncCas == CAS_POLAR)
			pDC-&gt;TextOutW(nRight + 5, showTop, _T(&quot;r(t)=&quot;) + tmpFD-&gt;m_Equation);
		else if (tmpFD-&gt;FuncCas == CAS_TWO) {
			pDC-&gt;TextOutW(nRight + 5, showTop, _T(&quot;x(t)=&quot;) + tmpFD-&gt;m_Equation);
			showTop += 20;
			pDC-&gt;TextOutW(nRight + 5, showTop, _T(&quot;y(t)=&quot;) + tmpFD-&gt;GetEquation2());
		} else if (tmpFD-&gt;FuncCas == CAS_DATA)
			pDC-&gt;TextOutW(nRight + 5, showTop, _T(&quot;y(t)=&quot;) + tmpFD-&gt;m_Equation);
		showTop += 25;
		pDC-&gt;SelectObject(pOldPen);
	}
}
</code></pre><p> 值得一提的是OnMouseMove的代码，拖动模式下，起点信息已经在OnLButtonDown更新，拖动过程使用了双缓冲绘图防止闪烁。具体原理可参看文末参考资料。</p><pre><code class=language-cpp>void CmfcplotView::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	更新状态栏，此处省略
	if (isMoving==2) {
		::SetCursor(LoadCursor(NULL, IDC_SIZEALL));
		CmfcplotDoc* pDoc = GetDocument();
		double detx = LPxtoFPx(point.x) - LPxtoFPx(m_posStart.x);
		pDoc-&gt;m_Xmin = tmp_Xmin - detx;
		pDoc-&gt;m_Xmax = tmp_Xmax - detx;
		double dety = LPytoFPy(point.y) - LPytoFPy(m_posStart.y);
		pDoc-&gt;m_Ymin = tmp_Ymin - dety;
		pDoc-&gt;m_Ymax = tmp_Ymax - dety;
		CDC* pDC = GetDC();
		//创建一个内存中的显示设备
		CDC MemDC;
		MemDC.CreateCompatibleDC(NULL);
		//创建一个内存中的图像
		CBitmap MemBitmap;
		CRect rect;
		GetClientRect(&amp;rect);
		MemBitmap.CreateCompatibleBitmap(pDC, rect.right, rect.bottom);
		//指定内存显示设备在内存中的图像上画图
		MemDC.SelectObject(&amp;MemBitmap);
		//先用一种颜色作为内存显示设备的背景色
		MemDC.FillSolidRect(rect.left, rect.top, rect.right, rect.bottom, RGB(144, 144, 144));
		this-&gt;OnDraw(&amp;MemDC);
		//将内存中画好的图像直接拷贝到屏幕指定区域上
		pDC-&gt;BitBlt(rect.left, rect.top, rect.right, rect.bottom, &amp;MemDC, 0, 0, SRCCOPY);
		//释放相关资源
		ReleaseDC(pDC);
	}
	else if (isMoving == 1) {
		::SetCursor(LoadCursor(NULL, IDC_HAND));
	}
	显示函数最近点部分，此处省略
	CView::OnMouseMove(nFlags, point);
}

</code></pre><h3 id=完整代码>完整代码</h3><p><a href=https://github.com/wineee/mfcplot target=_blank>github</a>
<a href=https://gitee.com/rewine/mfcplot target=_blank>gitee</a>
<a href=https://download.csdn.net/download/qq_33831360/12636165 target=_blank>csdn下载</a></p><h3 id=参考资料>参考资料</h3><ul><li><a href=https://blog.csdn.net/by_mxy/article/details/9932967 target=_blank>DrawText函数的讲解</a></li><li><a href="https://blog.csdn.net/oceanlucy/article/details/46827809?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase" target=_blank>VC双缓冲绘图技术介绍</a></li><li>阎光伟，彭文，徐琳茜. 基于案例的Visual C++程序设计教程[M].北京：清华大学出版社，2012</li><li>张晓民. VC++2010应用开发技术[M].北京：机械工业出版社，2013</li></ul></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var commentArea=document.querySelector('.post-comment');var utterancesTheme=document.body.getAttribute('data-theme');if(utterancesTheme==='auto'){utterancesTheme=window.matchMedia('(prefers-color-scheme: dark)').matches?'photon-dark':'github-light';}else{utterancesTheme=utterancesTheme==='dark'?'photon-dark':'github-light';}
var s=document.createElement('script');s.src='https://utteranc.es/client.js';s.setAttribute('repo','wineee\/hugoblogtalks');s.setAttribute('issue-term','pathname');s.setAttribute('theme',utterancesTheme);s.setAttribute('crossorigin','anonymous');s.setAttribute('async','');document.querySelector('.post-comment').appendChild(s);document.querySelector('span.post-comment-notloaded').setAttribute('style','display: none;');}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/wineee target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/rewine target=_blank><span>Twitter</span></a></li><li><a href=https://space.bilibili.com/23192485 target=_blank><span>bilibili</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/acm/>ACM</a></span>
<span><a href=/tags/bfs/>bfs</a></span>
<span><a href=/tags/c/>c</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/cryptography/>cryptography</a></span>
<span><a href=/tags/lab/>lab</a></span>
<span><a href=/tags/mfc/>mfc</a></span>
<span><a href=/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/>匈牙利算法</a></span>
<span><a href=/tags/%E5%8D%95%E7%BA%AF%E5%9E%8B/>单纯型</a></span>
<span><a href=/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/>康托展开</a></span>
<span><a href=/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/>蓝桥杯</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><ul><li><a href=#实验环境>实验环境</a></li><li><a href=#实现功能>实现功能</a></li><li><a href=#界面展示>界面展示</a></li><li><a href=#设计结构>设计结构</a></li><li><a href=#完整代码>完整代码</a></li><li><a href=#参考资料>参考资料</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/wineee target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/rewine target=_blank><span>Twitter</span></a></li><li><a href=https://space.bilibili.com/23192485 target=_blank><span>bilibili</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/acm/>ACM</a></span>
<span><a href=/tags/bfs/>bfs</a></span>
<span><a href=/tags/c/>c</a></span>
<span><a href=/tags/c++/>c++</a></span>
<span><a href=/tags/cryptography/>cryptography</a></span>
<span><a href=/tags/lab/>lab</a></span>
<span><a href=/tags/mfc/>mfc</a></span>
<span><a href=/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/>匈牙利算法</a></span>
<span><a href=/tags/%E5%8D%95%E7%BA%AF%E5%9E%8B/>单纯型</a></span>
<span><a href=/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/>康托展开</a></span>
<span><a href=/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/>蓝桥杯</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><ul><li><a href=#实验环境>实验环境</a></li><li><a href=#实现功能>实现功能</a></li><li><a href=#界面展示>界面展示</a></li><li><a href=#设计结构>设计结构</a></li><li><a href=#完整代码>完整代码</a></li><li><a href=#参考资料>参考资料</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2021
<a href=https://wineee.github.io>rewine</a>
| <a href=https://github.com/itsme/my_blog>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script></body></html>