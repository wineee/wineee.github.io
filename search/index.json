[{"content":"1.准备蓝桥杯需要做什么，有哪些需要学习的算法？ 熟悉比赛环境 比赛使用的编辑环境，c/c++ 组使用的是 dev-c++ , python 组使用 IDLE , java 组使用 Eclipse，建议平时练习多使用对应的编辑器，如果不熟悉编译环境，在比赛时可能会带来不必要的麻烦，尤其是 python 组的 IDLE 非常简陋，由俭入奢易，由奢入俭难。\n喜讯：官方通知第十二届蓝桥杯 c/c++ 组增加了 CodeBlocks 20.03 编程环境，支持 C++ 98 和 C++11， 终于可以用上 c++ 的新特性了。\n写竞赛风格的代码 大学的课程大都是偏向使用工程风格的代码，重视可读性，写竞赛风格的代码可能会受到批评。但在蓝桥杯中，使用工程风格只会浪费时间，还可能增加出错的概率。\n变量名命名的问题，可以参考黄学长的这篇博客：http://hzwer.com/9160.html，总体来说风格比较自由。平时也可以积累一些常见算法的简洁写法，如下面的辗转相除法代码就很经典。短，在竞赛中意味着节省时间，同时更不容易出错。\nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }  数据结构也没必要像课上那样进行封装，遵从简单实用的原则，比如栈\nint st[MAX],top = 0; // 定义 st[top++] = a; // a入栈 b = st[--top]; // 出栈  建议尽量不用指针，用指针动态分配速度慢，而且空指针处理不好可以出现运行时崩溃。竞赛中数据范围是确定的，没必要动态分配内存。\n对数据范围要敏感 同样的题面，不同的数据范围，将是2个难度完全不同的题，数据范围不只是告诉你数组开多大，还可以大致推算算法的时间复杂度，比如n\u0026lt;=10，应该是阶乘级别的算法，比如全排列的暴力枚举；n\u0026lt;=1000, 可能是$O(n^3)$ 的算法，可能是动态规划，递推等等；n\u0026lt;=50000，可能是$O(n \\log(n))$ 的算法，比如线段树，分治之类；n\u0026lt;=1e9, 说不定是$O(\\log(n))$ 的，如二分等等。这些推测不一定准确，但可以提示题解的一些信息。\n程序的空间复杂度通常是电灯泡，不用担心，管够。但有些题目还是要关心关心的，这里给个例题：给你一个元素个数是10000的无序数列，求中位数，怎么做？如果加上内存限制连10000个元素的数组都装不下，只能开5000个元素的数组，怎么做？是不是解题方法完全不一样了。如果竞赛中内存超出限制会导致直接0分。当空间不充裕时，可以用sizeof()先看看用了多少内存，防止超出题目要求。\n2147483247，这个数你熟悉吗？它是 int 可以表示的最大数，再大记得开 long long。\n推荐一些算法 官方其实是有竞赛大纲的：https://upload.lanqiao.cn/file/20180207/1517983424205832.pdf\n不过内容不太具体，下面给出一些个人见解：\n数据结构\n 基础数据结构：数组，栈，队列，链表，树，图，堆 中等数据结构：并查集，Trie树，hash表，线段树，二叉搜索树，单调栈，单调队列  算法\n  暴力穷举，搜索算法（dfs，bfs，回溯，迭代加深搜索，双向搜索，记忆化搜索，最优性剪枝 ，可行性剪枝 ）\n  动态规划（背包问题，区间dp，树形dp，状压 dp， 数位dp，单调队列 / 单调栈优化，矩阵快速幂优化等等）\n  排序（桶排序，归并排序，快速排序等等）\n  前缀和，差分：常用的小技巧。\n  模拟：模拟就是用计算机来模拟题目中要求的操作，主要考验代码能力。\n  二分法，倍增法：二分法，也称折半搜索，必须会。\n  贪心：局部最优到达全局最优，比较常用。对不会做的题可以试试用贪心骗分。\n  分治，递归：非常重要的算法。\n  高精度：随着python的流行，高精度算法的题目越来越少见，不过蓝桥杯py和c++组是分开的，不排除。\n  字符串：字符串hash有必要学一下。此外很多字符串的题其实找规律，动态规划，排列组合，贪心等等，感觉kmp的题不是很多。\n  二进制处理技巧，位运算\n  图论\n 最短路（堆优化Dijkstra算法， SPFA算法，Floyd算法） 最小生成树（Kruskal算法，Prim算法） 二分图 判定（黑白染色） 二分图的最大匹配（匈牙利算法） 有向无环图，拓扑排序，DAG 上的动态规划 欧拉图和哈密顿图的性质  数学：\n 快速幂 辗转相除法，扩展欧几里得算法 组合数学 ，博弈论，概率论，解析几何的基础知识 数论：素数筛（欧拉筛），乘法逆元，费马小定理，素数判定，质因数分解，求欧拉函数等等  想参加省赛不需要把上面的知识全学完，毕竟蓝桥杯是比较全民向的竞赛，真正必要的算法：贪心，分治，dp，搜索，数论只要gcd，再多刷刷题，省二没问题。想要省一的话，还是有必要多学一点的，上面提到的算法最好都掌握。\n一定要了解STL 这条建议只针对c/c++组，选手只要学习c语言就可以参加，不需要完成大学的c++课程，面向对象的思想在竞赛中基本没什么用处，但是，如果不会用 c++ 的 STL 的话，那就实在太可惜了。C++ STL 也就是 C++ 标准模板库，它实现了常用的数据结构和算法。STL 学习难度非常低，只要调库就行，可以节省你大量时间和精力。\n比如竞赛题中经常需要对一组数据进行排序，有了 STL ，你只需要在加入algorithm头文件中，直接调用 sort(a, a+n); 即可完成对数组a从小到大的排序，非常方便。完全不需要自己写排序算法，而且时间复杂度是 $O(n \\log n)$ 的，即使没学过快速排序的人，也可以进行高效的排序了。\n下面的列举了常用的 STL ：\n string 字符串 vector 动态数组 set / multiset 集合 map / multimap / unordered_map 关联容器 queue 队列 priority_queue 优先队列（堆） algorithm 算法库，常用的有sort，偶尔用的lower_bound/upper_bound(二分), nth_element(找第n大)，next_permutation(排列组合中求下一个序列)等 bitset 二进制相关，偶尔用  多练习使用 SLT 的效益是非常高的，比如使用邻接表建图时\nvector\u0026lt;int\u0026gt; g[MAX_NODE]; // 定义 g[a].push_back(b); g[b].push_back(a); // 添加一条a与b的无向边 for (int i = 0; i \u0026lt; g[a].size(); i++) cout \u0026lt;\u0026lt; g[a][i]; // 遍历与a相连的点  是不是非常简洁，既节约时间，代码逻辑也清晰，在竞赛中经常使用。另一种竞赛中常用来表示图的数据结构是链式前项星，大家在网上找题解时应该会经常看到这种写法。\n2.国赛和省赛有什么区别？   蓝桥杯省赛一等奖可以获得报名国赛的资格。\n  省赛，国赛的报名费都是300元。\n  蓝桥杯的国赛无论报名流程，还是参赛过程，都和省赛基本一致。\n  我认为大家没必要太纠结省赛和国赛的不同，国赛的吸引力不算太大，有不少省一的同学没有继续参加国赛。但是，我推荐尽量参加一下，毕竟300块钱还不算太离谱。\n3.国赛需要学习哪些算法？ 准备国赛不如准备 ACM ，有对算法非常感兴趣的同学，一点要尝试一下 ACM 。\n如果仅仅是为了蓝桥杯的国赛的话，其实没有必要学习太多新的算法，多刷题就行了。重点还是分治，搜索，动态规划，这些算法难度上限很高，甚至无上限，比方说动态规划，有的状态非常难确定，很难看出是dp题，有的状态转移需要写单调栈/队列，线段树甚至平衡树等数据结构来加速，有的从前往后行不通，从后往前就可以，我还见过一个动态规划的状态转移是另一个动态规划问题。这个阶段，应该从题目中积累经验，而不是按标签刷题了。\n我没找到蓝桥杯真题的数据，题目和野生的题解网上可以搜到，但没数据就没法判断自己写的对不对，这点就要批评@蓝桥杯了。蓝桥杯官网的评测系统，题目也是不全的。刷题的OJ，我后面会推荐一些。\n下面补充一下 ACM 可能用到的算法，为什么不是蓝桥杯，因为没的可讲啊。\n数据结构\n 树状数组，ST表（倍增法），分块思想（块状数组，树分块，块状链表），树链抛分。 平衡树：STL的set/map封装了平衡树，但是有些情况还是需要手写平衡树，比如动态第k大的问题，STL封装太死，只能手写，常见的有 Treap，Splay，替罪羊树，AVL等 ，其中Splay比较特殊，它是唯二可以维护序列的平衡树，经典例题：文艺平衡树。吊炸天的数据结构Link-Cut-Tree也需要Splay为基础） 可持久化数据结构，最重要的是可持久化线段树，特殊用法：主席树 树套树, K-D Tree等等。 字符串相关：字符串匹配算法kmp，AC自动机，后缀三姐妹（后缀数组的倍增法构建可以学学，hihocoder有相关资料，后缀树，后缀自动机，我也不会hahaha），回文串（马拉车，回文树）  算法\n 搜索算法（启发式搜索A* ， IDA* ， Dancing Links） 动态规划（空间优化：滚动数组，插头 DP，斜率优化，四边形不等式优化等等，经典算法：悬线法） 树分治（点分治，边分治），cdp分治/整体二分，莫队算法。 LCA问题（欧拉序+ST表/倍增法/tarjan算法/树链抛分）  图论\n tarjan 求强连通分量 + 缩点 + 割点 / 桥。 网络流 最大流算法dinic和isap中至少会一个，费用流算法推荐 spfa费用流，网络流关键在于建模，经典题目有\u0026quot;网络流24题\u0026rdquo;。 最小树形图，次小生成树，k短路，差分约束，Prufer序列等。  数学\n BSGS，卢卡斯定理，中国剩余定理，莫比乌斯反演（扩展：杜教筛，min25筛）等数论知识。 牛顿迭代法，自适应辛普森公式等恶心的高数。 维护凸包，旋转卡壳，半平面交等恶心的几何题。 康托展开，卡特兰数，容斥原理，置换群（Burnside 引理，Pólya 定理）等组合数学知识。 高斯消元，线性基，线性规划（单纯型） 生成函数，原根，快速傅立叶变换（fft），快速数论变换（ntt）  4.除了蓝桥杯，还有哪些算法比赛值得参加？ PAT 计算机程序设计能力考试（Programming Ability Test，简称 PAT ） 旨在通过统一组织的在线考试及自动评测方法客观地评判考生的算法设计与程序设计实现能力， 科学的评价计算机程序设计人才， 为企业选拔人才提供参考标准。\nPAT值得参加的是甲级和顶级，甲级难度应该小于蓝桥杯，需要英文阅读能力。对于考研生来说，PAT成绩可能在部分学校会给予免机试的优待。\nACM-ICPC 国际大学生程序设计竞赛（英文全称：International Collegiate Programming Contest（简称 ICPC））是由国际计算机协会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。\nACM与蓝桥杯的主要区别有\n 难度不同，ACM 获奖难度和题目难度都高于蓝桥杯，考察范围更广。 参与方式不同，ACM 是团体赛，一队3人一台电脑，讲求分工合作，蓝桥杯是个人赛。 赛制不同，ACM题目可以提交多次，如果代码不通过会有罚时，可以修改后继续提交，直到通过。蓝桥杯只有一次判题的机会。ACM没有部分分，必须通过所有数据才能得分，蓝桥杯则有部分分。  ACM 是程序设计方面的顶级赛事，含金量高，需要付出的努力也更大。\nCCPC 中国大学生程序设计竞赛（China Collegiate Programming Contest， CCPC），与ACM类似。\n其他 可以了解一下百度之星，计蒜之道之类的网络赛，有难度，主要可以锻炼能力。\n5.有哪些推荐的OJ平台？ vjudge vjudge不是真正的OJ，它通过爬取其他 OJ 的题目，让我们可以直接在 VJ 上查找并提交各种 OJ 的题目，然后通过它在其他OJ的账号，提交代码并把结果反馈给我们。因此VJ上的题目非常全，有很多ACM选手也在使用。\nVJ上有一个kuangbin 带你飞专题，适合作为专项训练使用。\nluogu 洛谷的最大特点是辛勤的管理员了，同类型的codevs，tyvj，甚至bzoj都凉凉了，luogu能保持活跃离不开运营团队。目前，luogu题目很多，难度从入门到入土一应俱全，题解区由于审核的存在保持着较高的质量。题目有比较准确的难度分级，可以根据算法标签找题。\nleetcode leetcode的定位是帮助程序员准备算法面试，与竞赛类的OJ相比，题目考察的知识点比较单一，整体上题目难度偏低，适合入门或者养老使用，如果想提高的话不建议只刷这个。\n其他 hdu,poj 杭电和北大的OJ，可以说是大学ACM题库中最为知名的两个。\ncodeforces 俄罗斯的竞赛网站，有着高质量的题目和高密度的比赛，唯一可惜的是由于时间差，大部分比赛要熬到凌晨1点。\nhihocoder 有大量模板题，有些题自带教程，刷模板的好去处。\nLibreOJ 一个有自由精神的开源OJ，你可以查看任意人提交的代码，下载任意题目数据。\n上面5个OJ的题目都可以在vjudge上提交。\n6.比赛的时候有哪些注意事项？ 时间，一定要注意时间，写完一定要先提交。国赛时，我最后写的是一个填空题，写完想验算一下，当时一直注意电脑右下角的时间，准备最后一分钟提交，结果打开提交页面，居然已经结束了。后来才明白赛场提前3分钟开始的，提前3分钟结束，没想到居然还有这种情况。比赛系统不讲武德，我大意了，没有闪，以后好自为之，好好反思。\n合理分配时间，题目量大，不要一直抓住一个题不放，不保证题目难度是递增的，不会的可以先跳过，至少每个题都看一遍，把能拿的分先拿了。最好抽出时间检查，会做的题却写错并不少见，这些错误往往简单复查一下就可以发现，当最后有可做的题没写完时，就需要取舍了，有时候放弃做新题去检查，反而收益更高。\n","date":"2021-01-22","permalink":"https://wineee.github.io/post/lanqiaobie/","tags":["ACM","蓝桥杯"],"title":"关于蓝桥杯竞赛的经验总结"},{"content":"第一章 引言 什么是被动攻击和主动攻击,各有几种类型?   被动攻击：也称窃听，以获取信息为目的。 仅攻击信息的保密性，不影响正常的网络通信，不对消息作任何修改 搭线窃听、对文件或程序非法复制、木马、对资源的非授权使用 被动攻击又分为两类：获取消息的内容和业务流分析\n 获取消息的内容：通过破译密文等手段直接获取机密信息的内容 业务流分析：敌手虽然可能无法从截获的消息中获取内容，但却有可能获知消息的长度，格式，通信双方的位置和身份，通信次数。在商业环境，用户隐私，以及军网中这些消息可能是敏感的。    主动攻击：对数据流进行篡改或产生假的数据流 可分为3类：\n 中断：对系统可用性进行攻击 破坏计算机硬件，网络，或文件管理系统。如DoS，病毒等 篡改：对完整性进行攻击 修改文件中的数据(数据修改后存储)，替换某一程序使其执行不同功能 修改网络中传送消息的内容等，比如中间节点对转发的图象进行了压缩 伪造：对真实性进行攻击 在网络中插入伪造的消息冒充消息发送者，在文件中插入伪造记录等    分别是对信息系统的什么性质进行的攻击? 恶意程序的分类  根据是否需要宿主程序及是否可以自我复制可分为病毒、蠕虫、特洛伊木马、逻辑炸弹等  安全业务分为哪五种?各自含义  保密业务,防止被动攻击  机密性就是保护信息（数据）不泄露或不泄露给那些未授权掌握这一信息的实体，如防止消息内容泄漏，被窃听。 在信息系统安全中需要区分两类机密性服务：  数据机密性服务：使攻击者想要从某个数据项中推出敏感信息是十分困难的 业务流机密性服务：使攻击者想要通过观察通信系统的业务流来获得敏感信息是十分困难的如防止敌手进行业务流分析，以获得信源，信宿，次数，消息长度等     认证业务  鉴别是最基本的安全服务，是对付假冒攻击的有效方法，以保障通信的真实性，鉴别可以分为对等实体鉴别和数据源鉴别 (1) 对等实体鉴别， 即身份认证，如主机和终端，主机和服务器等。保障身份的真实性，通信双方都相信对方是真实的，这种服务可以是单向的，也可以是双向的，可以带有有效期检验，也可以不带。 (2) 数据源鉴别，保障通信连接的真实性，通信连接不能被第三方介入，以假冒其中的一方而进行非授权的传输或接受。单向通信：认证业务功能是使接收者相信消息确实是由它自己所声称的那个信源发出的。   完整性业务  完整性服务用于对抗数据在存储、传输等处理过程中受到的非授权修改 ，如用于消息流：保证所接收的消息未经复制、插入、篡改、重排、或重放。即保证接收的消息和发送的消息完全一样 和机密性一样可以实现不同粒度的完整性保护 还能用于一定程度上对已经毁坏的数据进行恢复   不可否认性业务  用于防止通信双方中的某一方对所传送的消息的否认，保护通信实体免遭来自其他合法实体的威胁 一个消息发出后，接收者能够证明消息的真实来源，发送者能够证明接收者确已接收了该消息   访问控制  访问控制用于防止资源的未授权使用，控制的实现方式是认证，检查用户是否有对某一资源的访问权    信息安全的基本模型?信息系统的保护模型? 密码体制从原理上可分为哪两大类?含义  单钥体制  传统密码体制所用的加密密钥和解密密钥相同k1＝k2，称为单钥密码体制，也称为对称密码体制   双钥密码体制  加密密钥和解密密钥不相同，称为双钥密码体制，也称为非对称密码体制或公钥体制    单钥密码体制对明文加密的两种方式?  流密码  明文消息按字符或比特逐位加密 需要一个至少和明文一样长的密钥流   分组密码  将明文消息分组(含有多个字符)，逐组进行加密 用同一个密钥分别对不同的分组按照一定的运行模式加密    对密码体制的攻击的4种类型   唯密文攻击\n  已知明文攻击\n  选择明文攻击\n  选择密文攻击\n     攻击类型 攻击者掌握的内容     惟密文攻击 加密算法，截获的部分密文   已知明文攻击 **加密算法，截获的部分密文，**一个或多个明密文对   选择明文攻击 **加密算法，截获的部分密文，**自己选择的明文消息及由密钥产生的相应密文   选择密文攻击 **加密算法，截获的部分密文，**自己选择的密文消息及相应的被解密的明文      第二章 流密码 密码和流密码的区别? 同步流密码的概念 分组密码与流密码的区别在于有无记忆性 ,流密码的滚动密钥 $z_0=f(k,\\theta_0)$ , 由函数 $f$ , 密钥 $k$, 和指定的初态 $\\theta_0$ 完全确定. 此后,由输入加密器的明文可能影响加密器中内部记忆部件的存储状态,因而 $\\theta_i (i\u0026gt;0)$ 可能依赖于 $k, \\theta_0, x_0, x_1,\u0026hellip;,x_{i-1}$ 等参数.\n根据加密器中的记忆元件的储存状态 $\\theta_i$ 是否依赖于输入的明文字符,流密码可以进一步分成同布和自同步两种. $\\theta_i$ 独立于明文字符的叫同步流密码,否则叫自同步流密码.\n有限状态自动机的基本原理 有限状态自动机是具有离散输入和输出（输入集和输出集均有限）的一种数学模型，由以下3部分组成：\n密钥流生成器的分解和常见的密钥流生成器 LFSR输出序列和周期的计算 LFSR的特征多项式及其性质  记$2^n-1$个非零序列的全体为G(p(x))。 定理2-2 p(x)|q(x)的充要条件是G(p(x))属于G(q(x)) 说明可用n级LFSR产生的序列，也可用级数更多的LFSR来产生 若序列{ai}的特征多项式p(x)定义在GF(2)上，p是p(x)的周期，则{ai}的周期r|p。 说明n级LFSR输出序列的周期r不依赖于初始条件，而依赖于特征多项式p(x)。 初始状态对序列的周期有一定的影响 所有这些m序列之间是相互移位的关系，本质上是同一个序列  m序列密码的条件和破译  n级LFSR产生的序列有最大周期的必要条件是其特征多项式为不可约的 注意：只要有一条序列为m序列，则所有非0序列都是m序列 该定理的逆不成立，即LFSR的特征多项式为不可约多项式时，其输出序列不一定是m序列。 若n次不可约多项式p(x)的阶为$2^n-1$，则称p(x)是n次本原多项式 {ai}为m序列的充要条件是p(x)为本原多项式。 对于任意的正整数n，至少存在一个n次本原多项式 m序列虽然具有最大的周期，然而因它是线性序列而极其不安全，只要知道连续的2n个bit的序列就可以完全破译了。即可以求出m序列产生器特征多项式的n个系数    第三章 分组密码体制  与流密码相比无记忆性。在相同密钥下分别对长为n的输入明文组实施相同变换，所以只需研究对任一组明文数字的变换规则。 分组密码实质上是字长为n的数字序列的代换密码 分组密码的优缺点  适合软硬件实现，软件实现及标准化优于流密码 没有有效的数学工具，安全性一般无法证明    Shannon提出的设计密码系统的两个基本方法   扩散和混淆(diffusion and confusion)是由Shannon提出的设计密码系统的两个基本准则，目的是抗击敌手对密码系统的统计分析\n  扩散性：所设计的密码应使得\n (1) 密钥的每一个比特影响密文的每一个比特，以防止对密钥进行逐段破译； (2) 明文的每一个比特影响密文的每一个比特，以便最充分地隐蔽明文。即将明文的统计特性散布到密文中去，从而使明文和密文之间的统计关系变得尽可能复杂    混淆性：\n 是使密文和密钥之间的统计关系变得尽可能复杂，以使敌手无法得到密钥。 即使敌手能得到密文的一些统计关系，由于密钥和密文之间的统计关系复杂化，敌手也无法得到密钥。 使用复杂的代换算法可以得到预期的混淆效果 简单的线性代换函数得到的混淆效果则不够理想    Feistel网络的加解密结构 DES加密算法的基本原理和过程 分组密码的四种运行模式和用途    模式 描述 用途     电码本**(ECB)****模式** 每个明文组独立地以同一密钥加密 传送短数据**(****如一个加密密钥****)**   密码分组链接**(CBC)****模式** 加密算法的输入是当前明文组与前一密文组的异或 传送数据分组；认证   密码反馈**(CFB)****模式** 每次只处理输入的j比特，将上一次的密文作加密算法的输入以产生伪随机输出，该输出再与当前明文异或以产生当前密文 传送数据流；认证   输出反馈**(OFB)****模式** 与CFB类似不同之处是本次加密算法的输入为前一次加密算法的输出 有扰信道上**(****如卫星通信****)****传送数据流**   计数器**(CTR)****模式** 对计数器依次用k加密后与明文异或 适合并行，可随机访问    IDEA算法的基本原理和过程  每轮开始时有一个变换，该变换的输入是4个子段和4个子密钥 变换中的运算是两个乘法和两个加法 输出的4个子段经异或运算形成了两个16比特的子段作为MA结构的输入 MA结构也有两个输入的子密钥，输出是两个16比特的子段 最后，变换的4个输出子段和MA结构的两个输出子段经过异或运算产生这一轮的4个输出子段  AES算法的原理和过程  Rijndael的轮函数由4个不同的计算部件组成，分别是： 字节代换（ByteSub）、行移位（ShiftRow） 列混合（MixColumn）、密钥加（AddRoundKey） 轮函数的伪C代码如下： Round (State, RoundKey) { ByteSub (State); ShiftRow (State); MixColumn (State); AddRoundKey (State, RoundKey) } 结尾轮的轮函数与前面各轮不同，将MixColumn这一步去掉。其伪C代码如下： FinalRound (State, RoundKey) { ByteSub (State); ShiftRow (State); AddRoundKey (State, RoundKey) } “InvShiftRow”与“InvByteSub”两个计算部件可以交换顺序 Rijndael密码的解密算法为顺序完成以下操作：初始的密钥加；(Nr-1)轮迭代；一个结尾轮。其中解密算法的轮函数为 InvRound (State, RoundKey) { InvByteSub (State); InvShiftRow (State); InvMixColumn (State); AddRoundKey (State, RoundKey) } 解密算法的结尾轮为 InvFinalRound (State, RoundKey) { InvByteSub (State); InvShiftRow (State); AddRoundKey (State, RoundKey) }  第四章 公钥密码 公钥密码体制的加密和认证原理   公钥密码算法基本工具不再是代换和置换，而是数学函数\n  以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、认证等都有着深刻的意义。\n  公钥密码算法的最大特点是采用两个相关密钥将加密和解密能力分开\n  一个密钥是公开的，称为公开密钥，简称公开钥，用于加密、验证签名，可以被任何人知道\n  另一个密钥是为用户专用，因而是保密的，只能被消息的接收者或签名者知道，称为秘密密钥，简称秘密钥，用于解密、产生签名\n  因此公钥密码体制也称为双钥密码体制\n  公钥体制的加密过程: ① 密钥的产生 ：要求接收消息的端系统，产生一对用来加密和解密的密钥$PK_B$和$SK_B$，如图中的接收者B，其中$PK_B$是公开钥，$SK_B$是秘密钥。因此，公钥可以发布给其他人 ② 公开钥的分发 ：B将加密密钥$(PK_B)$予以公开。另一密钥则被保密$(SK_B)$ ③ 加密 ：A要想向B发送消息m，则使用B的公开钥加密m，表示为$ c=E_{PK_B}[m] $其中c是密文，E是加密算法 ④ 解密 ：B收到密文c后，用自己的秘密钥$SK_B$解密，即$m=D_{SK_B}[c]$，其中D是解密算法。因为只有B知道$SK_B$，所以其他人都无法对c解密。\n  公钥体制的认证过程\n公钥加密不仅能用于加、解密，还能用于对发方A发送的消息m提供认证 用户A用自己的秘密钥$SK_A$对m加密，表示为$c=E_{SK_A}[m]$ 将c发往B。B用A的公开钥$PK_A$对c解密，表示为$m=D_{PK_A}[c]$ 因为从m得到c是经过A的秘密钥$SK_A$加密，**只有A才能做到**。因此c可当做A对m的**数字签字**。 任何人只要得不到A的秘密钥$SK_A$就不能篡改m，所以以上过程获得了对**消息来源和消息完整性的认证**，也实现了**对身份的认证**。\n  RSA加密体制的原理和计算  它既可用于加密、又可用于数字签字。 RSA算法的安全性是基于数论中大整数分解的困难性(但可能达不到大数分解的困难强度) 1 密钥的产生 ① 选两个保密的大素数p和q ② 计算n=p×q，$\\phi(n)=(p-1)(q-1)$，其中$\\phi(n)$是n的欧拉函数值 ③ 选一整数e，满足$1\u0026lt;e\u0026lt; \\phi(n)$，且$gcd(\\phi(n),e)=1$ ④ 计算$d$，满足$ d * e = 1 \\mod \\phi(n)$, 即d是e在模$\\phi(n)$下的乘法逆元，因e与$\\phi(n)$互素，模$\\phi(n)$的乘法逆元一定存在 ⑤ 以{e,n}为公开钥,{d,p,q}为秘密钥 秘密钥也可记为d，或{d, n}，如果是系统负责产生密钥，则用户可能不知道p,q 2 加密 加密时首先将明文比特串分组，使得每个分组对应的十进制数小于n，即分组长度小于$log_2 n$。 然后对每个明文分组m，作加密运算： $c≡m^e \\mod n$ 3 解密 对密文分组的解密运算为： $m≡c^d \\mod n$ RSA的加密很快，因为加密指数e一般选择得很小 解密指数d很大，需要计算模 300digits (or 1024bits) 的乘法，计算机不能直接处理这么大的数，计算速度很慢，需要考虑其它技术，加速RSA的实现 如果知道p和q，可采用中国剩余定理CRT： CRT 对RSA解密算法生成两个解密方程（利用$M=C^d \\mod N$，$N=p * q$）, 即：$M_1 = M \\mod p = (C \\mod p)^{d \\mod (p-1)} \\mod p$ $M_2 = M \\mod q = (C \\mod q)^{d \\mod (q-1)} \\mod q$ 解方程 $M = M_1 \\mod p$ $M = M_2 \\mod q $ 具有唯一解（利用CRT ）： $M = M_1 * q * (q^{－1} \\mod p) + M_2 * p * (p^{－1} \\mod q) \\mod N$ 不考虑CRT的计算代价，改进的算法的解密速度是原来的4倍 若考虑CRT的计算代价，改进后的算法解密速度是原来的3倍多 RSA密钥的产生 需考虑两个大素数p、q的选取，以及e的选取和d的计算 n(=p*q) 是公开的，为了防止敌手通过穷搜索发现p、q，这两个素数应足够大，且具有好的随机性 (1) 如何有效地寻找大素数 一般是先随机选取一个大的奇数（例如用伪随机数产生器）， 然后用素性检验算法检验这一奇数是否为素数，如果不是则选取另一大奇数，重复这一过程，直到找到素数为止 素性检验算法通常都是概率性的，常用Miller-Rabin概率检测算法实现，只有在产生新密钥时才需执行这一工作 (2) 如何选取满足$gcd(\\phi(n),e)=1$的e，并计算满足$d * e≡1 \\mod \\phi(n)$的d,这一问题可由推广的Euclid算法完成  背包密码体制的原理和计算   设$A=(a_1,a_2,…,a_n)$是由 n 个不同的正整数构成的 n 元组，s 是另一已知的正整数。背包问题就是从 A 中求出所有的 $a_i$，使其和等于 s。其中 A称为背包向量，s 是背包的容积。 例如,A=(43, 129, 215, 473, 903, 302, 561, 1165, 697, 1523)，s=3231。 由于 3231=129+473+903+561+1165 所以从 A 中找出的满足要求的数有129、473、903、561、1165 原则上讲，通过检查 A 的所有子集，总可找出问题的解（若有解的话） 本例 A 的子集共有$2^{10}=1024$个（包括空集）。 然而如果 A 中元素个数 n 很大，子集个数 $2^n$将非常大。 如A中有300个元素，A的子集有$2^{300}$。寻找满足要求的 A 的子集没有比穷搜索更好的算法，因此背包问题( Knapsack)是NPC问题\n  由背包问题构造公钥密码体制同样是要构造一个(陷门)单向函数f 将 $x (1≤x≤2 * n-1)$ 写成长为 n 的二元表示, f(x) 定义为 A 中所有$a_i$的和，其中 x 的二元表示的第 i 位为1，即 $f(1)=f(0…001)=a_n;$\n$f(2)=f(0…010)=a_{n-1};$\n$ f(3)=f(0…011)=a_{n-1}+a_n;$\n$f(2n-1)=f(1…111)=a_1+a_2+…+a_n$\n使用向量乘(内积)，有$f(x)=A·B_x$，其中$B_x$是x二元表示的列向量。 上例中f(364) =f(0101101100)= 129+473+903+561+1165 = 3231 显然，已知 x 很容易求 f(x)，但已知 f(x) 求 x 就是要解背包问题。 为使接收方能够解密，就需找出单向函数 f(x) 的陷门。为此需引入一种特殊类型的背包向量。\n  定义背包向量$A=(a_1,a_2,…,a_n)$称为超递增的，如果 $a_j \u0026gt; a_1+a_2+\u0026hellip;+a_{j-1}, 其中j=1,2,3\u0026hellip;n$\n  超递增背包向量对应的背包问题很容易通过以下算法求解。 已知 s 为背包容积，对A从右向左检查每一元素，以确定是否在解中。 若 $s≥a_n$，则 $a_n$ 在解中，令 $x_n=1$； 若 $s \u0026lt; a_n$，则 $a_n$ 不在解中，令$x_n=0$。 下面令\ns = s if s\u0026lt;a[i] else s-a[i]  对$a_{n-1}$重复上述过程，一直下去，直到检查出$a_1$是否在解中。 检查结束后得 $x=(x_1x_2…x_n)$，$B_x=(x_1x_2…x_n)^T$\n  1 密钥产生 选一个超递增背包向量 $ A=(a_1,a_2,…,a_n) $ 用模乘对 A 进行伪装，模乘的模数 k 和乘数 t 皆取为常量，满足 ，gcd(t, k) = 1，即 t 在模 k 下有乘法逆元。 设 $b_i≡t·a_i \\mod k$, i=1,2,…,n，得一新的背包向量$ B = (b_1,b_2,…,b_n)$，记为 $B≡t · A \\mod k$ 用户以 B 作为自己的公开钥，A, t, k为私钥\n  2.加密 对明文分组 $x=(x_1x_2…x_n)$的加密运算为$c=f(x)=B·B_x \\mod k$\n  3. 解密 首先由$s≡t^{-1}c \\mod k$，求出 s 作为超递增背包向量 A 的容积， 再由超递增背包向量A解背包问题即得$x=(x_1x_2…x_n)$。\n  过了两年该体制即被破译\n  Rabin加密体制的原理和计算   Rabin密码体制已被证明对该体制的破译等价于对大整数的分解\n  RSA中选取的公开钥e满足$1\u0026lt;e\u0026lt;\\phi(n)$，且$gcd(e,\\phi(n))=1$。Rabin密码体制则取e=2\n  1 密钥的产生: 随机选择两个大素数p、q，满足$p≡q≡3 \\mod 4$，Blum数，即这两个素数形式为$4 * k+3$；计算$n = p * q$。以 n 作为公开钥，p、q 作为秘密钥。\n  2. 加密:\n$c≡m^2 \\mod n$ 其中 m 是明文分组，c 是对应的密文分组。\n  3. 解密: 解密就是求c模n的平方根，即解$x^2≡c \\mod n$，因此，Rabin体制也被称为基于环上二次剩余困难性构造，由中国剩余定理知解该方程等价于解方程组\n    由于p≡q≡3 mod 4，方程组的解可容易地求出，其中每个方程都有两个解，即$ x≡\\pm m_1 \\mod p$， $x≡\\pm m_2 \\mod q$， 经过组合可得4个同余方程组\n  由中国剩余定理可解出每一方程组的解，共有4个，即每一密文对应的明文不惟一。为了有效地确定明文,可在 m 中加入某些信息,如发送者的身份号、接收者的身份号、日期、时间等。\n  Rabin密码在选择密文攻击CCA下是不安全的\n  ElGamal密码体制  密钥产生 选择一个大的素数 p ；选择 g ，1 \u0026lt; g \u0026lt; p；选择 x，1 \u0026lt; x \u0026lt; p-1； 计算$y = g^x \\mod p$，公钥是(p, g, y)，私钥是x 加密 设欲加密明文消息M，0 \u0026lt; M \u0026lt; p 随机选一整数 k , 满足 gcd(k, p－1) = 1 计算对$C1≡g^k \\mod p,C2≡y^kM \\mod p$，密文为C = C1||C2 (级联) 解密 $M=C_2/C_1x \\mod p$ 这是因为$C_2/C_1^x \\mod p＝y^kM/g^{kx} \\mod p＝y^kM/y^k \\mod p＝M \\mod p $ 特点：密文由明文和所选随机数k来定，因而是一种概率加密体制代价是使数据扩展一倍  Diffie-Hellman 密钥交换   算法的唯一目的是使得两个用户能够安全地交换密钥，得到一个共享地会话密钥，算法本身不能用于加、解密\n  算法的安全性基于求离散对数的困难性\n  假设 p 是大素数， g 是 p 的本原根，p 和 g 作为公开元素，协议如下： ① 用户Alice选择随机数x，计算 $a=g^x \\mod p$，保密x，发送a给Bob ② 用户Bob选择随机数y，计算 $b=g^y \\mod p$，保密y，发送 b 给Alice ③ Bob和Alice各自计算 $k=b^x \\mod p$ 和 $k=a^y \\mod p$, 从而得到共享密钥 k 这是因为$k=b^x mod p=(g^y)^x \\mod p=(g^x)^y \\mod p=a^y \\mod p$\n  ECC加密体制的原理和优点   与基于有限域上离散对数问题的公钥体制（如Diffie-Hellman密钥交换和ElGamal密码体制）相比，椭圆曲线密码体制有如下优点:\n  1: 安全性高\n攻击有限域上的离散对数问题可以用指数积分法，对椭圆曲线上的离散对数问题并不有效。 目前攻击椭圆曲线上的离散对数问题的方法只有适合攻击任何循环群上离散对数问题的大步小步法\n  2: 密钥量小\n由攻击两者的算法复杂度可知，在实现相同的安全性能条件下，椭圆曲线密码体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小\n  3: 灵活性好\n有限域GF(q)一定的情况下，其上的循环群（即GF(q)-{0}）就定了 GF(q)上的椭圆曲线可以通过改变曲线参数，得到不同的曲线，形成不同的循环群。因此，椭圆曲线具有丰富的群结构和多选择性 可在保持和RSA/DSA体制同样安全性能的前提下大大缩短密钥长度(目前160比特足以保证安全性)，因而在密码领域有着广阔的应用前景\n  ECC上的Elgamal密码体制   椭圆曲线并非椭圆，之所以称为椭圆曲线是因为它的曲线方程与计算椭圆周长的方程类似。一般来讲，椭圆曲线的曲线方程是以下形式的三次方程： $y^2+axy+by=x^3+cx^2+dx+e$ 其中a，b，c，d，e是满足某些简单条件的实数。定义中包括一个称为无穷点的元素，记为O。\n  椭圆曲线关于x轴对称。\n  3个点位于同一直线上，那么它们的和为O\n  O为加法单位元，即对椭圆曲线上任一点P，有 P+O=P\n  设P1=(x,y)是椭圆曲线上的一点（如图所示），它的加法逆元定义为P2=－P1=(x, -y)\n  设Q和R是椭圆曲线上x坐标不同的两点，Q+R的定义如下： 画一条通过Q、R的直线与椭圆曲线交于P1\n由Q+R+P1=O 得 Q+R=-P1\n  点Q的倍数定义如下： 在Q点做椭圆曲线的一条切线，设切线与椭圆曲线交于点S，定义2Q=Q+Q=-S。类似地可定义3Q=Q+Q+Q+，…，\n  以上定义的加法具有加法运算的一般性质，如交换律、结合律等\n         (0**，****1)** (0**，****22)** (1**，****7)** (1**，****16)** (3**，****10)** (3**，****13)** (4**，****0)** (5**，****4)** (5**，****19)**     (6**，****4)** (6**，****19)** (7**，****11)** (7**，****12)** (9**，****7)** (9**，****16)** (11**，****3)** (11**，****20)** (12**，****4)**   (12**，****19)** (13**，****7)** (13**，****16)** (17**，****3)** (17**，****20)** (18**，****3)** (18**，****20)** (19**，****5)** (19**，****18)**        第五章 密钥分配与密钥管理  密钥的种类与使用周期 密钥加密密钥(key encrypting key):在传输会话密钥时，用来加密会话密钥的密钥称为密钥加密密钥，也称次主密钥(submaster key)或二级密钥(secondary key) 主机主密钥(host master key):对密钥加密密钥进行加密的密钥称为主机主密钥。它一般保存于网络中心、主节点、主处理机中，受到严格的物理保护。一般在密钥分配中心以及终端系统中主密钥都是物理上安全的。如果主密钥泄露了，则相应的会话密钥也将泄露，如果把主密钥当作会话密钥注入加密设备，那么其安全性则降低 两个用户（主机、进程、应用程序）在用单钥密码体制进行保密通信时，首先必须有一个共享的秘密密钥，为防止攻击者得到密钥，还必须时常更新密钥。因此，密码系统的强度也依赖于密钥分配技术 两个用户A和B获得共享密钥的方法有以下4种： ① 密钥由A选取并通过物理手段发送给B ② 密钥由第三方选取并通过物理手段发送给A和B ③ 如果A、B事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方 ④ 如果A和B与第三方C分别有一保密信道，则C为A、B选取密钥后，分别在两个保密信道上发送给A、B 第1和第2种方法称为人工发送 在通信网中，若只有个别用户想进行保密通信，密钥的人工发送还是可行的。然而如果所有用户都要求支持加密服务，则任意一对希望通信的用户都必须有一共享密钥。如果有n个用户，则密钥数目为n(n-1)/2。因此当n很大时，密钥分配的代价非常大，密钥的人工发送是不可行的 系统的主密钥或初始密钥一般物理手段发送 对于第3种方法 攻击者一旦获得一个密钥就可获取以后所有的密钥；而且用这种方法对所有用户分配初始密钥时，代价仍然很大。  在单钥密钥体制下有中心的密钥分配和无中心的密钥分配   第4种方法比较常用 其中的第三方通常是一个负责为用户分配密钥的密钥分配中心(KDC)。 这时每一用户必须和密钥分配中心有一个共享密钥，称为主密钥。（可通过第二种方法） 通过主密钥分配给一对用户的密钥ks称为会话密钥，用于这一对用户之间的保密通信。 通信完成后，会话密钥即被销毁。如上所述，如果用户数为n，则会话密钥数为n(n-1)/2。但主密钥数却只需n个，所以主密钥可通过物理手段发送。\n  网络中如果用户数目非常多且分布的地域非常广，则需要使用多个KDC的分层结构\n  分层结构可减小主密钥的分布，因为大多数主密钥是在本地KDC和本地用户之间共享。\n  分层结构还可将虚假KDC的危害限制到一个局部区域，但会降低信任度\n  在基于对称密钥和公钥的密钥管理中都存在分层控制问题\n   普遍采用的方式是KDC密钥管理体系\n主密钥的分配采用物理的方式，由KDC负责对用户的密钥进行管理，基于第2种方式在用户和KDC之间建立共享主密钥，要求所有用户必需信任KDC，且需要对KDC进行严格的保护。如果系统规模庞大，还要使用分层控制的方式\n用KDC为用户分配密钥时，要求所有用户都信任KDC，同时还要求对KDC加以保护。如果密钥的分配是无中心的，则不必有以上两个要求\n  无中心的密钥分配时，两个用户A和B建立会话密钥需经过以下3步： ① A向B发出建立会话密钥的请求和一个一次性随机数$N_1$ ② B用与A共享的主密钥$MK_m$对应答的消息加密，并发送给A 应答的消息中有B选取的会话密钥$K_S$、B的身份$ID_B、f(N_1)$和另一个一次性随机数$N_2$ ③ A使用新建立的会话密钥$K_S$对$f(N_2)$加密后返回给B\n  单钥体制中密钥控制技术的两种技术  密钥标签 控制矢量  公钥体制下公钥的4种分配方法   主要有两个方面的问题需要解决\n 公钥密码体制所用的公开密钥的管理和分配 如何用公钥体制来分配单钥密码体制所需的密钥，这是公钥加密的主要用途之一    公钥的分配方法主要有以下4种\n  公开发布\n公开发布指用户将自己的公钥发给每一其他用户，或向某一团体广播\n缺点很明显，即任何人都可伪造这种公开发布\n  公用目录表 公用目录表指一个公用的公钥动态目录表 公用目录表的建立、维护以及公钥的分发由某个可信的实体或组织承担，称这个实体或组织为公用目录的管理员 该方案有以下一些组成部分： ① 管理员为每个用户都在目录表中建立一个目录，目录中有两个数据项: 用户名；用户的公开钥 ② 每一用户都亲自或以某种安全的认证通信在管理者那里为自己的公开钥注册，用户能够直接操作目录表 ③ 用户如果由于自己的公钥用过的次数太多或由于与公钥相关的秘密钥已被泄露，可随时用新密钥替换现有的密钥\n④ 管理员定期公布或定期更新目录表 ⑤ 用户可通过电子手段访问目录表，这时从管理员到用户必须有安全的认证通信\n安全性高于公开发布，但仍易受攻击 如果敌手成功地获取管理员的秘密钥（密码），就可伪造一个公钥目录表，以后既可假冒任一用户又能监听发往任一用户的消息。(因为公钥目录表的保护不是十分安全) 公用目录表还易受到敌手的窜扰(因为用户亲自操作目录表，可能会破坏目录表) 用户需要登录到公钥目录表中自己查找收方的公钥\n  公钥管理机构\n为防止用户自行对公钥目录表操作所带来的安全威胁，假定有一个公钥管理机构来为各用户建立、维护动态的公钥目录 即由用户提出请求，公钥管理机构通过认证信道将用户所需要查找的公钥传给用户 该认证信道主要基于公钥管理机构的签名\n 其中消息②中 管理机构对A的应答消息用自己的秘密钥SKAU加密签名，消息还包含了A的请求，抗篡改、抗重放；包括最初的时戳，抗重放 一次性随机数N1和N2，用于保障通信的新鲜性，使A和B能够完成握手  公钥管理机构方式的优缺点 每次密钥的获得由公钥管理机构查询并认证发送，用户不需要查表，提高了安全性 但公钥管理机构必须一直在线，由于每一用户要想和他人联系都需求助于管理机构，所以管理机构有可能成为系统的瓶颈 由管理机构维护的公钥目录表也易被敌手通过一定方式窜扰\n  公钥证书\n  用户通过公钥证书来互相交换自己的公钥而无须与公钥管理机构联系\n  公钥证书由证书管理机构CA(certificate authority)为用户建立\n  证书中的数据项有与该用户的秘密钥相匹配的公开钥及用户的身份和时戳等，所有的数据项经CA用自己的秘密钥签字后就形成证书\n  公钥基础设施PKI(public key infrastructure)是指结合公钥密码体制建立的提供信息安全服务的基础设施\n  PKI技术提供以下四种安全服务 (1) 数据的保密性：保证在开放的网络上传输的机密信息不泄露给非法接受者 (2) 数据的完整性：保证在开放的网络上传输的信息不被中途篡改及重复发送； (3) 身份认证：对通信方的身份、数据源的身份进行认证，以保证身份的真实性； (4) 不可否认性：通信各方不能否认自己在网络上的行为\n  一个PKI系统由认证中心、证书库、Web安全通信平台，RA注册审核机构等组成，其中认证中心CA和证书库是PKI的核心\n  认证中心CA的体系结构\n        用公钥加密分配单钥体制密钥   简单分配\n    A、B现在可以用单钥加密算法以KS作为会话密钥进行保密通信，通信完成后，又都将KS销毁 这种分配法尽管简单，但却由于A、B双方在通信前和完成通信后，都未存储密钥，因此，密钥泄露的危险性为最小，且可防止双方的通信被敌手监听, 每次公私钥由发方临时产生 但由于公钥缺少证书管理机构认证且非物理传输容易受到主动攻击\n  具有保密性和认证性的密钥分配\n    Diffie-Hellman密钥交换  上面已经提到  线性同余算法伪随机数生成器及其变形   随机数在密码学中的作用 相互认证中的一次性随机数，如在密钥分配中，都使用了一次性随机数防止重放攻击 会话密钥的产生，用随机数作为会话密钥 公钥密码算法中密钥的产生，用随机数作为公钥密码算法中的密钥，或以随机数来产生公钥密码算法中的密钥\n  在随机数的各种应用中，都要求随机数序列满足两个特性 随机性和不可预测性 （1）随机性 以下两个准则常用来保障数列的随机性： ①均匀分布 数列中每个数出现的频率应相等或近似相等 ②独立性 数列中任一数都不能由其它数推出\n（2）不可预测性 在诸如相互认证和会话密钥的产生等应用中，不仅要求数列具有随机性而且要求对数列中以后的数是不可测的 对于真随机数列来说，数列中每个数都独立于其它数，因此是不可预测的 对于伪随机数来说，就需要特别注意防止敌手从数列前边的数预测出后边的数\n  最为广泛使用的伪随机数产生器是线性同余算法 线性同余算法有4个参数： 模数m (m\u0026gt;0)， 乘数a (0\u0026lt;=a\u0026lt;m)， 增量c (0\u0026lt;=c\u0026lt;m)， 初值即种子 $X_0(0\u0026lt;=X_0\u0026lt;m)$； 由以下迭代公式得到随机数数列{ $X_n$}： $X_{n＋1}＝aX_n+c \\mod m$ 如果$m，a，c，X_0$都为整数则产生的随机数序列{$ X_n$}也都是整数\n  评价线性同余算法的性能有以下3个标准： ①迭代函数应是整周期的，即数列中的数在重复之前应产生出0到m之间的所有数 ②产生的数列看上去应是随机的。因为数列是确定性产生的，因此不可能是随机的，但可用各种统计检测来评价数列具有多少随机性 ③迭代函数能有效地利用32位运算实现\n  a, c和m的取值是产生高质量随机数的关键，通过精心选取a, c和m，可使以上3个标准得以满足 为使随机数数列的周期尽可能大，m应尽可能大，普遍原则是选m接近等于计算机能表示的最大整数，为了方便32位运算地实现，m可取为$2^{31}-1$，这满足上述的第③条要求\n  对第①条来说，一种典型的选取方式是， m为素数、c=0、a是m的一个本原根\n  Knuth给出了使迭代函数达到整周期的充要条件\n  通常，可取$m＝2^r，a＝2^i＋1，c＝1$，其中r是一整数，i\u0026lt;r也是一整数即可满足定理条件\n  线性同余算法的强度在于如果将乘数和模数选择得好，则产生的数列和从1，2，…，m-1中随机选取的数列是不可区分的\n  线性同余算法的密码分析\n给定参数，则线性同余算法由初始值$X_0$确定 如果敌手知道正在使用线性同余算法，并知道算法的参数，则一旦获得数列中的一个数，就可得到以后的所有数 甚至如果敌手只知道正在使用线性同余算法以及产生的数列中极少一部分，就足以确定出算法的参数。假定敌手能确定$X_0，X_1，X_2，X_3$，就可通过以下方程组解出a，c和m。\n$X_1＝(aX_0+c) \\mod m$ $X_2＝(aX_1+c) \\mod m$ $X_3＝(aX_2+c) \\mod m$\n改进的方法是利用系统时钟修改随机数数列 一：每当产生N个数后，就利用当前的时钟值模m后作为种子 二：直接将当前的时钟值加到每个随机数上(模m加)\n  对线性同余算法有以下一些常用变形\n  幂形式的迭代公式为$X_{n＋1}＝(X_n)^d \\mod m，n＝1，2，…$ 其中d, m是参数，$X_0(0\u0026lt;=X_0\u0026lt;m)$是种子 根据参数的取法，幂形式又分为以下两种：\n①RSA产生器 此时参数取为RSA算法的参数，即m是两个大素数乘积，d是RSA秘密钥，满足$gcd(d, \\phi(m))=1$ ②平方产生器 取d＝2，m＝pq，而p，q模4余3的大素数\n  离散指数形式的迭代公式为$X_{n＋1}＝g^{X_n} \\mod m，n＝1，2，…$ 其中g, m是参数，$X_0(0\u0026lt;=X_0\u0026lt;m)$是种子\n  ANSI X 9.17 伪随机数生成器的原理   它是密码强度最高的伪随机数产生器之一，已在包括PGP等许多应用过程中被采纳， 产生器有3个组成部分\n  ① 输入 输入为两个64比特的伪随机数，其中$DT_i$表示当前的日期和时间，每产生一个数$R_i$后，$DT_i$都更新一次；$V_i$是产生第i个随机数时的种子，其初值可任意设定，以后每次自动更新。 ②密钥 3次3DES(EDE)加密使用 相同的两个56比特的密钥K1和K2 ③输出 为一个64比特的伪随机数 $R_i$和一个64比特的新种子$V_{i＋1}$\n    $R_i＝EDE_{K1,K2}[V_i @ EDE_{K1,K2}[DT_i]]$ $V_{i＋1}＝EDE_{K1,K2}[R_i @ EDE_{K1,K2}[DT_i]]$\n  本方案具有非常高的密码强度， 这是因为采用了112比特长的密钥和9个DES加密 同时还由于算法由两个伪随机数输入驱动， 一个是当前的日期和时间 另一个是算法上次产生的新种子\n  前向保密和后向保密性 即使某次产生的随机数$R_i$泄漏了，但由于**$R_i$又经一次EDE加密才产生新种子$V_{i＋1}$**，所以别人即使得到$R_i$也得不到$V_{i＋1}$，从而得不到新随机数$R_{i＋1}$\n  BBS(blum-blum-shub)随机比特生成器  在某些情况下，需要的是随机比特序列，而不是随机数序列，如流密码的密钥流 首先，选择两个大素数p，q，满足p≡q≡3 mod 4，令n＝p×q。再选一随机数s，使得s与n互素。然后按以下算法产生比特序列{Bi}：  BBS的安全性基于大整数分解，是密码上安全的伪随机数比特产生器 如果伪随机比特产生器能通过下一比特检验，则称之为密码上安全的伪随机比特产生器 即以伪随机比特产生器的输出序列的前k个比特作为输入，如果不存在多项式时间算法，能以大于1/2的概率预测第k+1个比特。换句话说，已知一个序列的前k个比特，不存在实际可行的算法能以大于1/2的概率预测下一比特是0还是1。  秘密分割Shamir门限方案  设秘密 s 被分成n个部分信息，每一部分信息称为一个子密钥或影子(share or shadow)，由一个参与者持有，使得： ① 由k个或多于k个参与者所持有的部分信息可重构s ② 由少于k个参与者所持有的部分信息则无法重构s 则称这种方案为(k,n)－秘密分割门限方案，k称为方案的门限值。 如果一个参与者或一组未经授权的参与者在猜测秘密s时，并不比局外人猜秘密时有优势,则称这个方案是完善的 攻击者除了试图恢复秘密外，还可能从可靠性方面进行攻击，如果他能阻止多于n-k个人参与秘密恢复，则用户的秘密就难于恢复 秘密分割应该由可信第三方执行，或者托管设备完成 Shamir门限方案基于多项式的Lagrange插值公式      第六章 消息认证和杂凑算法 消息认证码MAC的定义及三种使用方式  消息认证码MAC指消息被一密钥控制的公开函数作用后产生的、用作认证符的、固定长度的数值，也称为密码校验和 此时需要通信双方A和B共享一密钥k   ANSIX9.17数据认证算法  算法基于CBC模式的DES算法，其初始向量为零向量 需被认证的数据(消息、记录、文件或程序)被分为64比特长的分组D1，D2，…，DN， 其中最后一个分组不够64比特的话，可在其右边填充一些0，然后按图所示过程计算数据认证码 杂凑函数的定义及6种使用方式 迭代型杂凑函数的一般结构   MDS和SHA杂凑函数的基本过程, 他们之间的区别与联系  如图所示。其中函数的输入M被分为L个分组Y0,Y1,…,YL-1，每一个分组的长度为b比特，最后一个分组的长度不够的话，需对其做填充 最后一个分组中还包括整个函数输入的长度值，将使得敌手的攻击更为困难 IV = 初始值, n =散列码的长度;最后一轮输出的链接变量CVL即为最终产生的哈希值  MD5算法采用迭代型散列函数的一般结构 算法的输入为任意长的消息，分为512比特长的分组 输出为128比特的消息摘要  处理过程有以下几步： ① 对消息填充，使得其比特长在模512下为448，即填充后消息的长度为512的某一倍数减64，留出的64比特备第2步使用 步骤①是必需的，即使消息长度已满足要求，仍需填充。 填充方式是固定的，即第1位为1，其后各位皆为0 哈希码中每一个比特是所有输入比特的函数 因此获得了很好的混淆效果，从而使得不可能随机选择两个具有相同哈希值的消息 SHA-1算法描述 算法的输入为小于264比特长的任意消息，分为512比特长的分组 输出为160比特长的消息摘要。算法的框图与MD5一样，但哈希值的长度和链接变量的长度为160比特 ① 对消息填充 与MD5的步骤①完全相同。 ② 附加消息的长度 与MD5的步骤②类似，不同之处在于以big-endian方式表示填充前消息的长度  HMAC的算法框图     第七章 数字签名和密码协议 数字签名的两种产生方式   由加密算法产生数字签名\n是指将消息或消息的摘要加密后的密文作为对该消息的数字签名 其用法又根据是单钥加密还是公钥加密而有所不同\n 单钥加密，不具备抗抵赖功能 如图：基于共享密钥加解密，密文即为签名 如果加密的是消息摘要或有消息冗余，则可提供消息源认证和完整性认证  公钥加密  然而由于任何人都可使用A的公开钥解密密文，所以这种方案不提供保密性 加密的消息应该是消息摘要或有消息冗余 为提供保密性，A可用B的公开钥再一次加密\n由加密算法产生数字签名在实现上一般采用外部保密方式，即先签名后加密，反之则称为内部保密方式 外部保密方式便于解决争议，因为第3方在处理争议时，需得到明文消息及其签名 先签名后加密，可防止签名替换攻击 有时签名消息中还要包含收方的身份 这样可以抵抗假冒攻击\n  由签名算法产生数字签名\n  数字签名的两种执行方式   数字签名的执行方式有两类： 直接方式和具有仲裁的方式\n  直接方式(缺少监督的方式)\n直接方式是指数字签名的执行过程只有通信双方参与，并假定双方有共享的秘密钥或接收一方知道发方的公钥 直接方式的数字签名有一公共弱点，即方案的有效性取决于发方秘密钥的安全性(发方可以声称自己秘密钥被窃取，而否认发过的消息,发方也有秘密钥真的被偷的危险)\n  具有仲裁方式的数字签名\n具有仲裁方式的数字签名也有很多实现方案，这些方案都按以下方式运行： ①发方X对发往收方Y的消息签名后，将消息及其签名先发给仲裁者A ②A对消息及其签名验证完后，再连同一个表示已通过验证的指令一起发往收方Y 此时由于A的存在，X无法对自己发出的消息予以否认。在这种方式中，仲裁者起着重要的作用，并应取得所有用户的信任\n    RSA签名于DSS签名的不同   RSA算法既能用于加密和签名，又能用于密钥交换\n  与此不同，DSS使用的算法只能提供数字签名功能\n    RSA签名中，先对消息做hash运算，再对hash值用发方的秘密钥加密就形成了对消息的签名\n  DSS签名也先利用杂凑函数产生消息的一个杂凑值，杂凑值连同一随机数k一起作为签名函数的输入\n签名函数还需使用发送方的秘密钥SKA和供所有用户使用的一族参数，称这一族参数为全局公开钥PKG\n  DSA的算法描述和框图 保证消息实时性的两种常用方法  实现消息新鲜性有两种技术：时间戳和询问应答机制 时戳 如果A收到的消息包括一时戳，且在A看来这一时戳充分接近自己的当前时刻， A才认为收到的消息是新的并接受之。这种方案要求所有各方的时钟是同步的 询问-应答 用户A向B发出一个一次性随机数作为询问，如果收到B发来的消息（应答）也包含一正确的一次性随机数，A就认为B发来的消息是新的并接受之。 时戳法不能用于面向连接的应用过程 询问-应答方式则不适合于无连接的应用过程  相互认证与单向认证  A和B是网络的两个用户，他们想通过网络先建立安全的共享密钥再进行保密通信。A(B)如何确信自己正在和B(A)通信而不是和C通信呢？即双方的身份认证 这种通信方式为双向通信，此时的认证称为相互认证 双向认证也叫相互认证、双方认证等 类似地，对于单向通信来说，认证称为单向认证  交互式证明   交互证明系统由两方参与，分别称为 证明者(prover，简记为P)和验证者(verifier，简记为V)\n  其中P知道某一秘密（如公钥密码体制的秘密钥或一平方剩余x的平方根），P希望使V相信自己的确掌握这一秘密\n  交互证明由若干轮组成\n 在每一轮，P和V可能需根据从对方收到的消息和自己计算的某个结果向对方发送消息 比较典型的方式是在每轮V都向P发出一询问，P向V做出一应答 所有轮执行完后，V根据P是否在每一轮对自己发出的询问都能正确应答，以决定是否接受P的证明    交互证明和数学证明的区别是：\n 数学证明的证明者可自己独立地完成证明 交互证明是由P产生证明、V验证证明的有效性来实现，因此双方之间通过某种信道的通信是必需的。    交互证明系统须满足以下要求：\n① 完备性 如果P知道某一秘密，V将接受P的证明 ② 正确性 如果P能以一定的概率使V相信P的证明，则P知道相应的秘密\n  零知识证明起源于最小泄露证明\n 如果V除了知道P能证明某一事实外，不能得到其他任何信息，则称P实现了零知识证明，相应的协议称为零知识证明协议    第八章 网络加密与认证 网络加密的两种基本方式  链路加密是指每个易受攻击的链路两端都使用加密设备进行加密 端到端加密是指仅在一对用户的通信线路两端(即源节点和终端节点)进行加密  kerberos认证服务系统的详细过程   Kerberos协议是工作在应用层的认证协议\n  解决的问题：\n 在一个公开的分布式环境中，工作站上的用户希望访问分布在网络中的服务器(可能是多个)上的服务 服务器希望能够限制授权用户的访问，并能对服务请求进行鉴别 Kerberos的主要功能：认证、授权、记账与审计 Kerberos系统在一个分布式的Client/Server体系机构中采用一个或多个Kerberos服务器提供一个认证服务 Kerberos系统基于对称密钥（DES算法）构建，提供一个基于可信第三方的认证服务  ![image-20201202221608940](  X.509的认证过程  那么如果我们使用证书技术分发公钥的话具体如何做呢？ X.509协议给了我们一个非常实用的标准 X.509协议是X.500系列标准的一个组成部分。 这里X. 500系列标准定义了一种目录业务 目录实际上是维护用户信息数据库的服务器或分布式服务器集合，其中目录中的用户信息包括用户名到网络地址的映射和用户的其他属性，比如互联网中的各个网站名及其网络地址 目录的作用是存放用户的公钥证书 X. 509还定义了基于公钥证书的认证协议 目录服务器本身并不负责为用户建立公钥证书，其作用仅仅是为用户访问公钥证书提供方便 认证过程  ","date":"2020-12-04","permalink":"https://wineee.github.io/post/cryptography_review/","tags":["cryptography"],"title":"现代密码学复习总结"},{"content":"(1) nullptr 用nullptr 代替NULL,\nNULL是一个宏定义，在c和c++中的定义不同，c中NULL为（void*)0,而c++中NULL为整数0\nvoid foo(char *); void foo(int);  对于这两个函数,如果NULL定义为0的话,foo(NULL)将会出现歧义\n使用NULL的情景均可用nullptr 代替\n(2) constexpr constexpr 让用户显式的声明函数或对象构造函数在编译器为常数\nconstexpr  的函数可以使用递归，从 C++ 14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，但 C++ 11 中是不可以的\nconstexpr int two() { return 2; } int _two() { return 2; } constexpr int fib(int n) { return n == 1 || n == 2 ? 1 : fib(n-1)+fib(n-2); } int main() { int a[two()]; //int _a[_two()]; //编译出错 int b[fib(5)]; int x; cin \u0026gt;\u0026gt; x; int c[fib(x)];//错误用法，constexpr必须编译期可求 cout \u0026lt;\u0026lt; sizeof (c) / sizeof (int); return 0; }  constexpr 还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr ，那么产生的对象中的所有成员都会是constexpr ，该对象也就是constexpr 对象了，可用于各种只能使用constexpr 的场合。注意，constexpr 构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。\nstruct A { constexpr A(int xx, int yy): x(xx), y(yy) {} int x, y; }; constexpr A a(1, 2); enum {SIZE_X = a.x, SIZE_Y = a.y};  C++中的const和constexpr  (3) auto auto  的意义是使C++编译器可以在编译时推导数据类型，这样就不用每次都要声明数据类型了.\n注意 auto  不能用于函数传参以及推导数组类型\nvector\u0026lt;int\u0026gt; vec{1,2,3}; for (auto it = vec.begin(); it != vec.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026quot; \u0026quot;;//迭代器 auto n = 10;//int auto x = new auto(12); //int*  (4) decltype 有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（初始化可以用auto ）。为了满足这一需求，C++11新标准引入了decltype  类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。\nauto x = 1; auto y = 2; decltype(x+y) z = 0; // z 是一个 int 型的  C++11新标准学习：decltype关键字 (5)尾返回类型 template\u0026lt;typename T, typename U\u0026gt; auto add(T x, U y) -\u0026gt; decltype(x+y) { return x+y; }  C++ 14 开始是可以直接让普通函数具备返回值推导\ntemplate\u0026lt;typename T, typename U\u0026gt; auto add(T x, U y) { return x+y; }  (6)基于范围的 for 循环 int array[] = {1,2,3,4,5}; for(auto \u0026amp;x : array) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; x = -x; } for(auto x : array) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; }  (7)初始化列表 int a[3]{1,2,3}; //统一的初始化语法 vector\u0026lt;int\u0026gt; vetc{1,2,3}; set\u0026lt;int\u0026gt; f{1,1,2,3};  (8) 外部模板 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。\n// test1.cpp #include \u0026quot;test.h\u0026quot; template void fun\u0026lt;int\u0026gt;(int); // 显式地实例化 void test1() { fun(1); }  // test2.cpp #include \u0026quot;test.h\u0026quot; extern template void fun\u0026lt;int\u0026gt;(int); // 外部模板的声明 void test2() { fun(2); }  (9) 尖括号 \u0026ldquo;\u0026gt;\u0026rdquo; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; wow;  两个\u0026gt;相连不用加空格了。\n(10) 类型别名模板 template\u0026lt; typename T, typename U, int value\u0026gt; class SuckType { public: T a; U b; SuckType():a(value),b(value){} }; template\u0026lt; typename U\u0026gt; using NewType = SuckType\u0026lt;std::vector\u0026lt;int\u0026gt;, U, 1\u0026gt;; NewType\u0026lt;int\u0026gt; Tmp;  typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process using process = int(*)(void *); // 同上, 更加直观  (11)默认模板参数 template\u0026lt;typename T = int, typename U = int\u0026gt; auto add(T x, U y) -\u0026gt; decltype(x+y) { return x+y; }  (12)变长参数模板 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。\ntemplate\u0026lt;typename... Ts\u0026gt; class Magic;  模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：\nclass Magic\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::map\u0026lt;std::string, std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; darkMagic;  既然是任意形式，所以个数为 0 的模板参数也是可以的：class Magic\u0026lt;\u0026gt; nothing;。\n除了在模板参数中能使用 ... 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如：\ntemplate\u0026lt;typename... Args\u0026gt; void printf(const std::string \u0026amp;str, Args... args);  那么我们定义了变长的模板参数，如何对参数进行解包呢？\n首先，我们可以使用 sizeof... 来计算参数的个数，：\ntemplate\u0026lt;typename... Args\u0026gt; void magic(Args... args) { std::cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; std::endl; }  我们可以传递任意个参数给 magic 函数：\nmagic(); // 输出0 magic(1); // 输出1 magic(1, \u0026quot;\u0026quot;); // 输出2  其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：\n1. 递归模板函数\n递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的：\n#include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printf(T value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T, typename... Args\u0026gt; void printf(T value, Args... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; printf(args...); } int main() { printf(1, 2, \u0026quot;123\u0026quot;, 1.1); return 0; }  2. 初始化列表展开\n递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。\n这里介绍一种使用初始化列表展开的黑魔法：\n// 编译这个代码需要开启 -std=c++14 template\u0026lt;typename T, typename... Args\u0026gt; auto print(T value, Args... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; return std::initializer_list\u0026lt;T\u0026gt;{([\u0026amp;] { std::cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; std::endl; }(), value)...}; } int main() { print(1, 2.1, \u0026quot;123\u0026quot;); return 0; }  在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性，而 std::initializer_list 也是 C++11 新引入的容器。\n通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。唯一不美观的地方在于如果不使用 return 编译器会给出未使用的变量作为警告。\n(13)面向对象增强 （1）委托构造 class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; int main() { Base b(2); std::cout \u0026lt;\u0026lt; b.value1 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; b.value2 \u0026lt;\u0026lt; std::endl; }  （2）继承构造 class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; class Subclass : public Base { public: using Base::Base; // 继承构造 }; int main() { Subclass s(3); std::cout \u0026lt;\u0026lt; s.value1 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; s.value2 \u0026lt;\u0026lt; std::endl; }  （3）显式虚函数重载 C++ 11 引入了 override 和 final 这两个关键字来防止上述情形的发生。\n当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：\nstruct Base { virtual void foo(int); }; struct SubClass: Base { virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数 };  final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。\nstruct Base { virtual void foo() final; }; struct SubClass1 final: Base { }; // 合法 struct SubClass2 : SubClass1 { }; // 非法, SubClass 已 final struct SubClass3: Base { void foo(); // 非法, foo 已 final };  （6）显式禁用默认函数 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。\nclass Magic { public: Magic() = default; // 显式声明使用编译器生成的构造 Magic\u0026amp; operator=(const Magic\u0026amp;) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number); }  (14)强类型枚举 C++ 11 引入了枚举类（enumaration class），并使用 enum class 的语法进行声明：\nenum class new_enum : unsigned int { value1, value2, value3 = 100, value4 = 100 };  这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较。\n(15) Lambda 表达式 C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。 Lambda 的语法形式如下：\n[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u0026gt; 返回值类型 {函数体}  函数对象参数 标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量 (包括 Lambda 所在类 的 this)。函数对象参数有以下形式：\n 空。没有任何函数对象参数。 =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 \u0026amp;。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。 this。函数体内可以使用 Lambda 所在类中的成员变量。 a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。 \u0026amp;a。将 a 按引用进行传递。 a，\u0026amp;b。将 a 按值传递，b 按引用进行传递。 =，\u0026amp;a，\u0026amp;b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。 \u0026amp;，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。  操作符重载函数参数 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (\u0026amp;a, \u0026amp;b)) 两种方式进行传递。\nmutable 或 exception 声明 这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw (int)。\n-\u0026gt; 返回值类型 标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n函数体 标识函数的实现，这部分不能省略，但函数体可以为空。\n实例 [] (int x, int y) { return x + y; } // 隐式返回类型 [] (int\u0026amp; x) { ++x;} // 没有 return 语句 -\u0026gt; Lambda 函数的返回类型是 'void' [] () { ++global_x; } // 没有参数，仅访问某个全局变量 [] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)  Lambda参考博客\n","date":"2020-08-19","permalink":"https://wineee.github.io/post/cplusplus1x_base/","tags":["c++"],"title":"初步认识c++1x的新特性"},{"content":"实验环境  window 10 版本19041 Microsoft Visual Studio Community 2019 版本 16.6.4  实现功能  绘制常见函数的图像 支持普通函数，极坐标函数，参数方程，直接输入数据点 可以删除指定函数图像 可以在一个坐标系中绘制多条数学曲线 显示坐标轴，网格，刻度值，图例 可以选择不同颜色线型来绘制不同的曲线 当鼠标移动到曲线上某点时，可以显示该点的坐标 可以用鼠标拖动图像 可以进行图形的放大，缩小，定量设置显示范围，自动缩放 普通函数x取值范围可设置为跟随显示范围变化 状态栏实时显示鼠标位置，双击显示鼠标精确位置 重要数据的序列化和反序列化 突变函数(如$floor(x)$)和部分y值接近无穷的函数(如$tan(x)$)无法完美显示  界面展示 设计结构 程序流程及设计  用户输入函数信息，显示函数图像。还可以通过菜单和工具栏更改设置。\n 通过计算样本点，相邻样本点用直线连接，当样本点数量足够大时，可近似看成曲线。 程序所有源文件 CalculatorFunc.cpp介绍  double CalcEquation(CString m_sEquation, bool\u0026amp; succ, char xKey, double xVal) m_sEquation:表达式 succ:计算是否成功 xKey:未知数是\u0026quot;x\u0026quot;还是\u0026quot;t\u0026rdquo; xVal:未知数的值\n  此文件可以单独拿出来(把CString换成string就行)使用 bool succ = true; double ans = CalcEquation(\u0026ldquo;sin(x)+e^x\u0026rdquo;,succ,\u0026lsquo;x\u0026rsquo;,1.1);\n  对方程，分为数（常数，未知数x），双目运算符(+ , - ,* , / , ^ ) ,单目运算符(sin,cos等等)，单目运算符后面是一个完整的子式，如2+cos(x+1)中，x+1就是一个完整的式子，通过递归调用可以求子式的值，如果已知子式值，这个[单目运算符+子式]就是一个已知数了，那剩下的就等效于只有+ , - , * , / , ^ 的公式，用表达式栈法就可以解决。\nFuncData.cpp介绍 FuncData类 成员变量： int FuncCas; //函数类型 CString m_Equation;\t//函数表达式 double minX, maxX;\t//x极值 double maxY, minY;\t//y极值 int stepX;\t//可以理解为样本点的数量 int m_penWidth;\t//画笔宽度 int m_penType;\t//画笔类型 COLORREF m_color;\t//画笔颜色 vector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; vetPoint;\t//储存所有样本点 成员函数： virtual double GetY(double xVal, bool\u0026amp; succ) = 0;//得到未知数为xVal时函数值，succ表示计算是否成功 virtual bool CalcList() = 0;\t//计算vetPoint virtual bool GetNearest(pair\u0026lt;double,double\u0026gt; NowPoint, pair\u0026lt;double, double\u0026gt; \u0026amp;CmpPoint);//获取本函数与NowPoint最近的点 virtual CString GetEquation2();\t//为了得到参数方程第二个函数式 FuncData(); FuncData(CString Equation,double minX,double maxX,int stepX,COLORREF color, int penWidth,int penType);//构造函数 注意:此处派生类只记录特有的成员 NormalFD类 无 PolarFD 类 成员变量 double maxth, minth; //自变量θ取值范围 TwoFD类 成员变量 CString m_EquationY; double maxT, minT; 成员函数 double GetX(double tVal, bool\u0026amp; succ);//参数方程X也需要求值 virtual double GetY(double tVal, bool\u0026amp; succ); DataFD类 成员函数 static int DataFD_Cnt; //记录数据点类型函数数量  mfcplotDoc.cpp介绍  mfcplotDoc中记录着设置信息和函数数据，主要内容如下\npublic: bool m_WillShowGrid; //是否显示网格 bool m_WillShowAxis; //是否显示坐标轴 bool m_WillShowEdge; //是否显示边框 bool m_SingelMode; //单函数模式添加函数自动删除上一个函数 bool m_ForceXrange;\t//普通函数x范围是否固定，不固定的话随显示范围变化 bool m_ShowNearPoint;//鼠标接近函数线时是否显示其坐标 double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//显示范围 FuncData *m_FD;//临时变量 CObList m_List;//记录所有函数信息 public: afx_msg void OnAxisMenu();//坐标轴 afx_msg void OnGridMenu();//网格 afx_msg void OnEdgeMenu();//边框 afx_msg void OnSmallerMenu();//显示范围缩小 0.8 afx_msg void OnBiggerMenu();//显示范围放大 1.25 afx_msg void OnNormalFuncMenu();//增加普通函数 afx_msg void OnMenuSetXyrange();//设置显示范围 afx_msg void OnFuncMode();//单/多函数模式 afx_msg void OnPolarFuncMenu();//增加极坐标函数 afx_msg void OnTwoFuncMenu();//增加参数方程函数 afx_msg void OnDataFuncMenu();//增加数据点型函数 afx_msg void OnFroceXrang();//普通函数x范围是否固定 afx_msg void OnNearpointMenu();//是否显示最近点 afx_msg void OnAutorangeMenu();//自动调整显示范围，正好显示完整函数图像 afx_msg void OnDelfunconeMenu();//删除一个函数 afx_msg void OnDelallMenu();//删除所有函数  mfcplotView.cpp介绍  绘图逻辑是在这里实现的，主要内容如下\npublic: double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//函数显示范围 int nTop, nButton, nLeft, nRight;//对应的逻辑坐标范围 int isMoving;//拖动状态 0不拖动 1拖动模式 2正在拖动 double tmp_Xmin, tmp_Xmax, tmp_Ymin, tmp_Ymax; //拖动模式下，单击鼠标左键，记录起点的显示范围 CPoint m_posStart; //拖动模式下，单击鼠标左键，记录起点的鼠标坐标 //根据鼠标坐标偏移量可以计算显示范围变化量   函数中LPxtoFPx表示把函数坐标x变成pDC可以用的逻辑坐标_x，原理函数坐标范围m_Xmin，m_Xmax到逻辑坐标范围nLeft，nRight（下面函数会给出）等比例的映射。\ndouble CmfcplotView::LPxtoFPx(int x) { return m_Xmin + (1.0 * x - nLeft) * (m_Xmax - m_Xmin) / (1.0 * nRight - nLeft); }   实现坐标转换后就可以进行绘图工作了。\nvoid CmfcplotView::OnDraw(CDC* pDC) { CmfcplotDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; m_Xmin = pDoc-\u0026gt;m_Xmin;//极值保存在Doc中 m_Xmax = pDoc-\u0026gt;m_Xmax; m_Ymin = pDoc-\u0026gt;m_Ymin; m_Ymax = pDoc-\u0026gt;m_Ymax; CRect rect; GetClientRect(\u0026amp;rect);//获得视图区 nTop = (int)round(rect.bottom * 0.1); //函数图像不会占据整个视图区 nButton = (int)round(rect.bottom * 0.9); nLeft = (int)round(rect.right * 0.1); nRight = (int)round(rect.right * 0.9); if (pDoc-\u0026gt;m_WillShowEdge) {//画边框 pDC-\u0026gt;MoveTo(nLeft, nTop); pDC-\u0026gt;LineTo(nLeft, nButton); pDC-\u0026gt;LineTo(nRight, nButton); pDC-\u0026gt;LineTo(nRight, nTop); pDC-\u0026gt;LineTo(nLeft, nTop); } //画x坐标信息 int nX,nY; bool BIGX = abs(m_Xmin) \u0026gt; 100 || abs(m_Xmax) \u0026gt; 100;//x坐标值比较大时，标注更稀 for (nX = nLeft; nX \u0026lt; nRight; nX += (BIGX ? 100 : 50)) { //每隔100/50像素一个标注 CRect textRect(nX - (BIGX ? 50 : 25), nButton + 1, nX + (BIGX ? 50 : 25), nButton + 20);//显示区域 CString xInfo; xInfo.Format(_T(\u0026quot;%.2f\u0026quot;),LPxtoFPx(nX)); pDC-\u0026gt;DrawText(xInfo, \u0026amp;textRect, DT_SINGLELINE | DT_CENTER); //单行,上下左右居中显示 } if (nX - nRight \u0026lt;= (BIGX ? 50 : 25)) {//最后一个x坐标，与前一个标注距离太近则不显示 CRect textRect(nRight, nButton + 1, nRight + 50, nButton + 20); CString xInfo; xInfo.Format(_T(\u0026quot;%.2f\u0026quot;),m_Xmax); pDC-\u0026gt;DrawText(xInfo, \u0026amp;textRect, DT_SINGLELINE | DT_LEFT | DT_TOP); } //y坐标 for (nY = nButton - 50; nY \u0026gt; nTop; nY -= 50) { CRect textRect(nLeft - 200, nY-10, nLeft - 3, nY + 10); CString yInfo; yInfo.Format(_T(\u0026quot;%.2f\u0026quot;), LPytoFPy(nY)); pDC-\u0026gt;DrawText(yInfo, \u0026amp;textRect, DT_SINGLELINE | DT_RIGHT); } if (nTop - nY \u0026lt;= 25) { CRect textRect(nLeft - 200, nTop - 10, nLeft - 3, nTop + 10); CString yInfo; yInfo.Format(_T(\u0026quot;%.2f\u0026quot;),m_Ymax); pDC-\u0026gt;DrawText(yInfo, \u0026amp;textRect, DT_SINGLELINE | DT_BOTTOM | DT_RIGHT); } // 显示网格 if (pDoc-\u0026gt;m_WillShowGrid) { CPen pen(PS_DOT, 1, RGB(100, 100, 100)); //创建笔，虚线，并调整坐标颜色灰色 CPen *pOldPen = (CPen *)pDC-\u0026gt;SelectObject(\u0026amp;pen); for (nX = nLeft+50; nX \u0026lt; nRight; nX += 50) { pDC-\u0026gt;MoveTo(nX, nTop); pDC-\u0026gt;LineTo(nX, nButton); } for (nY = nButton - 50; nY \u0026gt; nTop; nY -= 50) { pDC-\u0026gt;MoveTo(nLeft, nY); pDC-\u0026gt;LineTo(nRight, nY); } pDC-\u0026gt;SelectObject(pOldPen); } // 显示坐标轴 if (pDoc-\u0026gt;m_WillShowAxis) { CPen pen(PS_SOLID, 2, RGB(0, 0, 0)); CPen* pOldPen = (CPen*)pDC-\u0026gt;SelectObject(\u0026amp;pen); int oX = FPxtoLPx(0); int oY = FPytoLPy(0); bool showY = oX \u0026gt;= nLeft \u0026amp;\u0026amp; oX \u0026lt;= nRight; bool showX = oY \u0026gt;= nTop \u0026amp;\u0026amp; oY \u0026lt;= nButton;//判断x,y轴是否在范围内 if (showX) { pDC-\u0026gt;MoveTo(nLeft - 10, oY); pDC-\u0026gt;LineTo(nRight + 10, oY); } if (showY) { pDC-\u0026gt;MoveTo(oX, nButton + 10); pDC-\u0026gt;LineTo(oX, nTop - 10); } if (showX \u0026amp;\u0026amp; showY) { pDC-\u0026gt;TextOutW(oX + 1, oY + 1, _T(\u0026quot;O\u0026quot;)); } if (showX) { pDC-\u0026gt;MoveTo(nRight + 10, oY); pDC-\u0026gt;LineTo(nRight + 5, oY + 5); pDC-\u0026gt;MoveTo(nRight + 10, oY); pDC-\u0026gt;LineTo(nRight + 5, oY - 5); pDC-\u0026gt;TextOutW(nRight + 10, oY, _T(\u0026quot;X轴\u0026quot;)); } if (showY) { pDC-\u0026gt;MoveTo(oX, nTop - 10); pDC-\u0026gt;LineTo(oX - 5, nTop - 5); pDC-\u0026gt;MoveTo(oX, nTop - 10); pDC-\u0026gt;LineTo(oX + 5, nTop - 5); pDC-\u0026gt;TextOutW(oX + 5, nTop - 10, _T(\u0026quot;Y轴\u0026quot;)); } pDC-\u0026gt;SelectObject(pOldPen); } POSITION p = pDoc-\u0026gt;m_List.GetHeadPosition(); int showTop = nTop; while (p != nullptr) { bool shouldMov = true;//一段曲线第一个点MoveTo，其他都是LineTo FuncData* tmpFD = (FuncData*)pDoc-\u0026gt;m_List.GetNext(p); CPen pen(tmpFD-\u0026gt;m_penType, tmpFD-\u0026gt;m_penWidth, tmpFD-\u0026gt;m_color); CPen* pOldPen = (CPen*)pDC-\u0026gt;SelectObject(\u0026amp;pen); if (tmpFD-\u0026gt;FuncCas == CAS_NORMAL) {//动态X坐标模式下，普通函数x范围与视图不同时自动同步 if (pDoc-\u0026gt;m_ForceXrange \u0026amp;\u0026amp; isMoving!=2) if (tmpFD-\u0026gt;minX != m_Xmin || tmpFD-\u0026gt;maxX != m_Xmax) { tmpFD-\u0026gt;minX = m_Xmin; tmpFD-\u0026gt;maxX = m_Xmax; tmpFD-\u0026gt;CalcList(); } } for (auto dot : tmpFD-\u0026gt;vetPoint) { if (dot.first \u0026lt; m_Xmin || dot.first \u0026gt; m_Xmax || dot.second \u0026lt; m_Ymin || dot.second \u0026gt; m_Ymax || dot.second != dot.second) { shouldMov = true; continue; } if (shouldMov) { pDC-\u0026gt;MoveTo(FPxtoLPx(dot.first), FPytoLPy(dot.second)); shouldMov = false; } else pDC-\u0026gt;LineTo(FPxtoLPx(dot.first), FPytoLPy(dot.second)); } pDC-\u0026gt;MoveTo(nRight+5, showTop);//显示图例 pDC-\u0026gt;LineTo(rect.right, showTop); showTop += 5; if (tmpFD-\u0026gt;FuncCas == CAS_NORMAL) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;f(x)=\u0026quot;)+tmpFD-\u0026gt;m_Equation); else if (tmpFD-\u0026gt;FuncCas == CAS_POLAR) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;r(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); else if (tmpFD-\u0026gt;FuncCas == CAS_TWO) { pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;x(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); showTop += 20; pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;y(t)=\u0026quot;) + tmpFD-\u0026gt;GetEquation2()); } else if (tmpFD-\u0026gt;FuncCas == CAS_DATA) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;y(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); showTop += 25; pDC-\u0026gt;SelectObject(pOldPen); } }   值得一提的是OnMouseMove的代码，拖动模式下，起点信息已经在OnLButtonDown更新，拖动过程使用了双缓冲绘图防止闪烁。具体原理可参看文末参考资料。\nvoid CmfcplotView::OnMouseMove(UINT nFlags, CPoint point) { // TODO: 在此添加消息处理程序代码和/或调用默认值 更新状态栏，此处省略 if (isMoving==2) { ::SetCursor(LoadCursor(NULL, IDC_SIZEALL)); CmfcplotDoc* pDoc = GetDocument(); double detx = LPxtoFPx(point.x) - LPxtoFPx(m_posStart.x); pDoc-\u0026gt;m_Xmin = tmp_Xmin - detx; pDoc-\u0026gt;m_Xmax = tmp_Xmax - detx; double dety = LPytoFPy(point.y) - LPytoFPy(m_posStart.y); pDoc-\u0026gt;m_Ymin = tmp_Ymin - dety; pDoc-\u0026gt;m_Ymax = tmp_Ymax - dety; CDC* pDC = GetDC(); //创建一个内存中的显示设备 CDC MemDC; MemDC.CreateCompatibleDC(NULL); //创建一个内存中的图像 CBitmap MemBitmap; CRect rect; GetClientRect(\u0026amp;rect); MemBitmap.CreateCompatibleBitmap(pDC, rect.right, rect.bottom); //指定内存显示设备在内存中的图像上画图 MemDC.SelectObject(\u0026amp;MemBitmap); //先用一种颜色作为内存显示设备的背景色 MemDC.FillSolidRect(rect.left, rect.top, rect.right, rect.bottom, RGB(144, 144, 144)); this-\u0026gt;OnDraw(\u0026amp;MemDC); //将内存中画好的图像直接拷贝到屏幕指定区域上 pDC-\u0026gt;BitBlt(rect.left, rect.top, rect.right, rect.bottom, \u0026amp;MemDC, 0, 0, SRCCOPY); //释放相关资源 ReleaseDC(pDC); } else if (isMoving == 1) { ::SetCursor(LoadCursor(NULL, IDC_HAND)); } 显示函数最近点部分，此处省略 CView::OnMouseMove(nFlags, point); }  完整代码 github gitee csdn下载\n参考资料  DrawText函数的讲解 VC双缓冲绘图技术介绍 阎光伟，彭文，徐琳茜. 基于案例的Visual C++程序设计教程[M].北京：清华大学出版社，2012 张晓民. VC++2010应用开发技术[M].北京：机械工业出版社，2013 ","date":"2020-07-20","permalink":"https://wineee.github.io/post/cpplab_mfcplot/","tags":["c++","mfc","lab"],"title":"[VC++课程设计] 用mfc实现数学函数曲线绘制程序"},{"content":"题目描述 申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要$ N $天才能完成，其中第 $ i $ 天至少需要$A_i$个人。 布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$ 天工作到第 $ T_i $ 天，招募费用是每人$C_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长。于是布布找到了你，希望你帮他设计一种最优的招募方案。\n输入格式： 第一行包含两个整数 $N$ , $M$，表示完成项目的天数和可以招募的志愿者的种类。 接下来的一行中包含N 个非负整数，表示每天至少需要的志愿者人数。 接下来的$M$ 行中每行包含三个整数$S_i$, $T_i$, $C_i$，含义如上文所述。为了方便起见，我们可以认为每类志愿者的数量都是无限多的。\n输出格式： 仅包含一个整数，表示你所设计的最优方案的总费用。\n输入样例#1： 3 3 2 3 4 1 2 2 2 3 5 3 3 2 输出样例#1： 14\n说明 $1 ≤ N ≤ 1000$，$1 ≤ M ≤ 10000$，题目中其他所涉及的数据均不超过$2^{31}-1$。\n分析与建模 设第 $i$ 天需要 $x_i$ 个志愿者，记 $a_{ij}$ 为第 $i$ 天第 $j$ 个志愿者是否能工作。 题目要求总费用最低，即求：$Min , z = \\sum_{i=1}^{n}{C_i * x_i}$。 它们需要满足要求：\n\\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3\u0026hellip;+a_{1m}x_m \\geq A_1 \\\\\na_{21}x_1+a_{22}x_2+a_{23}x_3\u0026hellip;+a_{2m}x_m \\geq A_2 \\\\\n\u0026hellip;\\\\\na_{n1}x_1+a_{n2}x_2+a_{n3}x_3\u0026hellip;+a_{nm}x_m \\geq A_n \\\\ x_1,x_2,x_3 \u0026hellip; x_m \\geq 0\\\n\\end{cases}$$\n这明显是一个的线性规划问题,但它不是标准形式,需要一些改造。\n方法一 转化为对偶问题 观察它的对偶问题：$Max , w = \\sum_{i=1}^{m}A_i*y_i$。 设$b_{ij} = a_{ji}$, 为第 $i$ 个志愿者第 $j$ 天是否能工作,新的约束条件为： $$\\begin{cases} b_{11}y_1+b_{12}y_2+b_{13}y_3\u0026hellip;+b_{1n}y_n \\leq C_1 \\\\\nb_{21}y_1+b_{22}y_2+b_{23}y_3\u0026hellip;+b_{2n}y_n \\leq C_2 \\\\\n\u0026hellip;\\\\\nb_{m1}y_1+b_{m2}y_2+b_{m3}y_3\u0026hellip;+b_{mn}y_n \\leq C_n \\\\\ny_1,y_2,y_3 \u0026hellip; y_n \\geq 0\\\\\n\\end{cases}$$\n添加松弛变量后为： $$\\begin{cases} b_{11}y_1+b_{12}y_2+b_{13}y_3\u0026hellip;+b_{1n}y_n+y_{n+1} = C_1 \\\\ b_{21}y_1+b_{22}y_2+b_{23}y_3\u0026hellip;+b_{2n}y_n+y_{n+2} = C_2 \\\\ \u0026hellip;\\\\\nb_{m1}y_1+b_{m2}y_2+b_{m3}y_3\u0026hellip;+b_{mn}y_n+y_{n+m} = C_n \\\\ y_1,y_2,y_3 \u0026hellip; y_{n+m} \\geq 0\\\\\n\\end{cases}$$ 这是线性规划的标准形式，对偶问题可以使用原始单纯型法求解。 根据对偶定理，若原问题有最优解，那么对偶问题也有最优解，且目标函数值相等。题目要的只有目标函数值，所以可以直接求解对偶问题，但这种方法得到的解不是原问题的解，所以这种方法实际上不太合适，不过它只要最基本的单纯形法，故放第一位。 代码如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int M=10005,N=1005,INF=1e9; const double eps=1e-7; int n,m; double a[M][N],b[M],c[N],v,cc[N]; int B[N],P[M]; void Out() { for (int i = 1; i \u0026lt;= m; i++) printf(\u0026quot;%4d\u0026quot;,P[i]); puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } void pivot(int l,int e) { //旋转运算,l换出变量 e换入变量 swap(B[l],P[e]); b[l]/=a[l][e]; for (int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; // 行变换，处理l对应行,将a[l][e]变为1 a[l][e]=1/a[l][e]; for (int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { //其他行，e对应列，除a[l][e]外变为0 b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=-a[i][e]*a[l][e]; } //需要注意的是，e列将对应新的非基变量，即原基变量l对应的列 v += c[e]*b[l]; //x的检验数即x值增加1对答案的影响，新的基变量值为b[l] for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; //更新检验数 c[e] = -c[e]*a[l][e]; } double simplex() { while(true) { int e=1,l=0;//l换出变量 e换入变量 for(int t=2; t\u0026lt;=n; t++) if(c[t]\u0026gt;c[e]) e = t; //找到检验数最大的变量 if (c[e] \u0026lt; eps) return v;//所以检验数\u0026lt;=0，最优解的情况 double mn=INF; for(int i=1;i\u0026lt;=m;i++) //找换出变量，a[i][e]\u0026gt;0且b[i]/a[i][e]最小 if(a[i][e]\u0026gt;eps\u0026amp;\u0026amp;mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF;//无可行解 pivot(l,e); // Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) { cin \u0026gt;\u0026gt; cc[i]; c[i] = cc[i]; } for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[i][j]=1; cin \u0026gt;\u0026gt; b[i]; P[i] = i; } for (int i = 1; i \u0026lt;= n; i++) B[i] = m+i; //Out(); printf(\u0026quot;%d\u0026quot;,(int)simplex()); }  方法二 人工变量法 在加入剩余变量后，分别给每个约束方程加入人工变量$x_{m+n+1},\u0026hellip;,x_{m+n+n}$,得到初始基可行解。 $$\\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3\u0026hellip;+a_{1m}x_m - x_{m+1} + x_{m+n+1} = A_1 \\\\ a_{21}x_1+a_{22}x_2+a_{23}x_3\u0026hellip;+a_{2m}x_m - x_{m+2} + x_{m+n+2} = A_2 \\\\ \u0026hellip;\\\\\na_{n1}x_1+a_{n2}x_2+a_{n3}x_3\u0026hellip;+a_{nm}x_m - x_{m+n} + x_{m+n+n} = A_n \\\\ x_1,x_2,x_3 \u0026hellip; x_m+n+n \\geq 0\\\\\n\\end{cases}$$\n1. 大M法 人工变量不能影响目标函数取值，必须从基变量中换出来。为此，可以在目标函数中把人工变量的系数设成M(一个充分大的数/惩罚系数)，使得在求Min的过程中，人工变量变为非基变量可以大大减小目标函数值 $Min , z = \\sum_{i=1}^{n}{C_i * x_i}+\\sum_{j=m+n+1}^{m+n+n}M*x_j$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const int M=12005,N=1005,INF=1e5; const double eps=1e-6; int n,m; double a[N][M],b[N],c[M],v,cc[M]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } double simplex() { for (int i = 1; i \u0026lt;= n; i++) { cc[i] = c[i]; for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]-INF*a[j][i]; } } while(true) { int e=0,l=0; for (int t=1; t\u0026lt;=n; t++) if (c[t]\u0026lt;-eps) { e = t; break; } if (e == 0) { v = 0; for (int i = 1; i \u0026lt;= m; i++) v += b[i]*cc[B[i]]; return v; } double mn=INF; for(int i=1;i\u0026lt;=m;i++) if(a[i][e]\u0026gt;eps \u0026amp;\u0026amp; mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF; pivot(l,e); //Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i]=1; cin \u0026gt;\u0026gt; c[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][m+i] = -1; a[i][m+n+i] = 1; B[i] = m+n+i; } for (int i = m+n+1; i \u0026lt;= m+n+n; i++) c[i] = INF; m += n+n; swap(n,m); //Out(); printf(\u0026quot;%d\u0026quot;,(int)simplex()); }  2. 两阶段法 两阶段法则更为直接，第一步，目标函数为$Min , w = \\sum_{i=m+1}^{m+n}{x_i}$，即尽量使人工变量取值为0，如果$w\u0026gt;0$，说明人工变量换不出去，即无解。若$w = 0$，说明有可行解，进行第二阶段，把矩阵中人工变量部分删掉，目标函数换回原问题的，即$Min , z = \\sum_{i=1}^{n}{C_i * x_i}$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const int M=12005,N=1005,INF=1e5; const double eps=1e-6; int n,m; int a[N][M],b[N],c[M],v,cc[M],A[M]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } int simplex() { while(true) { int e=0,l=0; for (int t=1; t\u0026lt;=n; t++) if (c[t]\u0026lt;-eps) { e = t; break; } if (e == 0) { v = 0; for (int i = 1; i \u0026lt;= m; i++) { v += b[i]*cc[B[i]]; } return v; } int mn=INF; for(int i=1;i\u0026lt;=m;i++) if(a[i][e]\u0026gt;eps \u0026amp;\u0026amp; mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF; pivot(l,e); //Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i]=1; cin \u0026gt;\u0026gt; A[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][m+i] = -1; a[i][m+n+i] = 1; B[i] = m+n+i; } for (int i = m+n+1; i \u0026lt;= m+n+n; i++) cc[i] = c[i] = 1; m += n+n; swap(n,m); //Out(); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]- 1*a[j][i]; } if (simplex() \u0026lt; eps) { n -= m; for (int i = 1; i \u0026lt;= n; i++) c[i] = cc[i] = A[i]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]- cc[B[j]]*a[j][i]; } printf(\u0026quot;%d\u0026quot;,(int)(simplex())); } else { puts(\u0026quot;Unsolvable!\u0026quot;); } return 0; }  ###方法三 对偶单纯形法\n将所有式子同乘$-1$后得到类似标准形式，但是b列出现负数，不能用原始单纯形法。 整理一下式子：$Max ,z_{'} = \\sum_{i=1}^{n}{-C_i * x_i}$\n$$\\begin{cases} -a_{11}x_1-a_{12}x_2-a_{13}x_3\u0026hellip;-a_{1m}x_m + x_{m+1} = -A_1 \\\\ -a_{21}x_1-a_{22}x_2-a_{23}x_3\u0026hellip;-a_{2m}x_m + x_{m+2} = -A_2 \\\\ \u0026hellip;\\\\\n-a_{n1}x_1-a_{n2}x_2-a_{n3}x_3\u0026hellip;-a_{nm}x_m + x_{m+n} = -A_n \\\\\nx_1,x_2,x_3 \u0026hellip; x_m \\geq 0\\\\\n\\end{cases}$$ 这里只介绍一下步骤。 (1)对线性规划问题是所有检验数\u0026lt;=0,即对偶问题为基可行解。(本题初始既满足)。 (2)检验：若b列都非负，检验数都非正，已达到最优解，停止计算。 (3)按$min[(B^{-1}b)_i,|(B^{-1}b\u0026lt;0)_i]=(B^{-1}b)_l$对应的基变量$x_l$为换出变量 (4)检查$x_l$行各系数$a_{lj}$，若所有$a_{lj}\u0026gt;=0$，说明无解。否则，计算$\\theta = min_j(\\frac{c_j-z_j}{a_{lj}} |a_{lj}\u0026lt;0) = \\frac{c_k-z_k}{a_{lk}}$，以对应的$x_k$ 为换入变量($\\theta$规则保证对偶问题的解仍为可行解)。 (5)以$a_{lk}$为主元素，进行迭代，得到新表。 重复(2)～(5)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int M=12005,N=1205,INF=1e7; const double eps=1e-6; int n,m; double a[N][M],b[N],c[M],v,cc[M],A[N]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1; j\u0026lt;=n; j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1; i\u0026lt;=m; i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1; j\u0026lt;=n; j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1; j\u0026lt;=n; j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } double dsimplex() { while (true) { int e=1,l=0; for (int t=2; t\u0026lt;=m; t++) if (b[t] \u0026lt; b[e]) e = t; if (b[e] \u0026gt; -eps) { v=0; for (int i = 1; i \u0026lt;= m; i++) v += b[i]*cc[B[i]]; //for (int i = 1; i \u0026lt;= m; i++) v += (-c[n-m+i])*A[i]; return v; } double mn=INF; for (int i = 1; i \u0026lt;= n; i++) if (a[e][i] \u0026lt; -eps \u0026amp;\u0026amp; mn \u0026gt; c[i]/a[e][i]) mn=c[i]/a[e][i],l=i; if (mn==INF) return INF; pivot(e,l); // Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=m; i++) { cin \u0026gt;\u0026gt; A[i]; b[i] = -A[i]; } for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i] = -1; cin \u0026gt;\u0026gt; cc[i]; c[i] = -cc[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][n+i] = 1; B[i] = n+i; } m += n; swap(n,m); //Out(); printf(\u0026quot;%d\u0026quot;,(int)(dsimplex())); return 0; }  一些补充说明 1.这四个程序在运算速度上没有本质上的差别，实际测试中人工变量法稍慢。\n2.原问题的线性规划模型是一步到位的，但不是标准形式，具体的解决方法有很多，可见线性规划与单纯形法内容丰富，体系比较完备。\n3.在已有的题解中，绝大多数作者是使用网络流来做。本题费用流的建图方法颇有挑战性，而线性规划模型简单很多，程序实现上单纯形法稍微麻烦一点，而这两类方法时间复杂度都比较高而且玄学，难分高下。总的来说，线性规划的方法更方便。\n供参考的资料： https://10420.blog.luogu.org/solution-p3980 | https://blog.csdn.net/little_cats/article/details/81189794 （注：这篇是作为《管理运筹学》自选题写的）\n","date":"2019-06-29","permalink":"https://wineee.github.io/post/cpplab_simplex/","tags":["c++","单纯型"],"title":"[管理运筹学]线性规划\u0026单纯形法的各种姿势(题目：[NOI2008]志愿者招募)"},{"content":"题目描述\n有 n 件工作要分配给 n 个人做。第 i 个人做第 j 件工作产生的效益为 c[i][j] 。试设计一个将 n 件工作分配给 n 个人做的分配方案，使产生的总效益最大。 输入格式： 文件的第 1 行有 1 个正整数 n，表示有 n 件工作要分配给 n个人做。 接下来的n 行中，每行有 n 个整数 c[i][j]，表示第 i个人做第 j 件工作产生的效益为 c[i][j]。 输出格式： 两行分别输出最小总效益和最大总效益。\n求最小总效益就是经典的指派问题，最大总收益只要把c乘-1再求最小就可以。 这里举个例子 n = 5，c为下表\n   12 7 9 7 9     8 9 6 6 6   7 17 12 14 9   15 14 6 6 10   4 10 7 10 9    第一步：每行减去该行最小的数，保证每行都有0。\n   5 0 2 0 2     2 3 0 0 0   0 10 5 7 2   9 8 0 0 4   0 6 3 6 5    第二步：每列减去该列最小的数，保证每行每列都有0。\n   5 0 2 0 2     2 3 0 0 0   0 10 5 7 2   9 8 0 0 4   0 6 3 6 5    第三步： 从单个0元素的行开始，给0加圈，记作O,然后划去所在行的其它0元素，记为X。 第四步： 从单个0元素的列开始，给0加圈，记作O,然后划去所在列的其它0元素，记为X。 重复三四，直到无法标记； 第五步： 若还存在没有画圈的0元素，则从剩余的0元素最少的行(列)开始，选0元素画圈，然后划掉同行同列的其它0元素，反复进行，直到所有0元素均被圈出或划掉为止； 检验： 若O的数目cnt=n，则该指派问题的最优解已经得到。 否则，进行调整。\n   5 O 2 X 2     2 3 X X O   O 10 5 7 2   9 8 O X 4   X 6 3 6 5    例子cnt = 4，少一个O 调整：找最少覆盖所有0的直线\n 对没有O的行打√ 对已打√行中含X所在列打√ 对已打√列中含O所在行打√ 重复2~3, 直至没有要打√的行和列为止 对没有打√的行划横线, 对打√的列划竖线，得到最少覆盖所有0的直线。 取未划线的最小数，未划线的减去这个数，线交点处加上这个数。 返回第一步。  打√后\n   5 O 2 X 2      2 3 X X O    O 10 5 7 2 √3   9 8 O X 4    X 6 3 6 5 √1   √2         调整6后\n   7 0 2 0 2     4 3 0 0 0   0 8 3 5 0   11 8 0 0 4   0 4 1 4 3    正确性初步说明：同一行或同一列减去同一个数不影响最优分配方案\n程序的一点说明：实际计算中， 第五步其实不需要dfs所有情况，模拟即可。相应调整5后可以这样: 设直线数为l，若l小于n，则转调整6；若l=n，则转第五步重新试探。程序直接枚举到最好的情况了，所以省了这个判断。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define N 110 void Out(int a[N][N],int v[N][N],int n) { for (int i = 1; i \u0026lt;= n; i++){ for (int j = 1; j \u0026lt;= n; j++) { if(!v[i][j]) printf(\u0026quot;%4d\u0026quot;,a[i][j]); else printf(\u0026quot; %c\u0026quot;,v[i][j]==1?'O':'X'); } puts(\u0026quot;\u0026quot;); }puts(\u0026quot;End!\u0026quot;); } int HZ[N],LZ[N]; struct Pair { int x,y; Pair(int x = 0,int y = 0):x(x),y(y){} bool operator \u0026lt; (const Pair \u0026amp; b) const { return HZ[this-\u0026gt;x]==HZ[b.x] ? LZ[this-\u0026gt;y]\u0026lt;LZ[b.y] : HZ[this-\u0026gt;x]\u0026lt;HZ[b.x]; } }Pt[N*N]; int FH[N],FL[N]; int Maxx,Mx; int st[N*N],tot,used[N*N]; void dfs(int s,int t,int sum) { if (sum \u0026gt; Mx) { Mx = sum; used[0] = tot;//记录最好方案 for (int i = 1; i \u0026lt;= tot; i++) used[i] = st[i]; } if (Mx == Maxx) return;//已经找到满意解 if (t-s+1+sum \u0026lt;= Mx) return;//乐观估计不如目前最优解 if (s \u0026gt; t) return; if (!FH[Pt[s].x] \u0026amp;\u0026amp; !FL[Pt[s].y]) { //选s点 FH[Pt[s].x] = 1; FL[Pt[s].y] = 1; st[++tot] = s; dfs(s+1,t,sum+1); --tot; FH[Pt[s].x] = 0; FL[Pt[s].y] = 0; } dfs(s+1,t,sum);//不选s点 } int calc(int b[N][N],int n) { int a[N][N],v[N][N]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) a[i][j] = b[i][j]; for (int i = 1; i \u0026lt;= n; i++) { int t = a[i][1]; for (int j = 2; j \u0026lt;= n; j++) if (a[i][j] \u0026lt; t) t = a[i][j]; for (int j = 1; j \u0026lt;= n; j++) a[i][j] -= t; } for (int i = 1; i \u0026lt;= n; i++) { int t = a[1][i]; for (int j = 2; j \u0026lt;= n; j++) if (a[j][i] \u0026lt; t) t = a[j][i]; for (int j = 1; j \u0026lt;= n; j++) a[j][i] -= t; } //先让每行每列都有0 //Out(a,v,n); int H[N],L[N]; while(1) { for (int i = 1; i \u0026lt;= n; i++) { H[i] = L[i] = 0; //H[i]，第i行有多少个0，L为列 FH[i] = FL[i] = 0; //FH[i],第i行有没有画O for (int j = 1; j \u0026lt;= n; j++) v[i][j] = 0;//v[i][j] = 1代表‘O’,-1代表‘X’ } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (a[i][j] == 0) { H[i]++; L[j]++; } int cnt = 0; while (1) { int tpcnt = cnt; for (int i = 1; i \u0026lt;= n; i++) //找每行单独的0画‘O’，同列画‘X’ if (H[i] == 1) { int t = 1; while(a[i][t] || v[i][t]) t++; v[i][t] = 1; cnt++; //cnt记有几个‘O’ H[i]--; L[t]--; FH[i] = 1; FL[t] = 1; for (int j = 1; j \u0026lt;= n; j++) if (a[j][t]==0 \u0026amp;\u0026amp; j!=i \u0026amp;\u0026amp; v[j][t]==0) { v[j][t] = -1; H[j]--; L[t]--; } } for (int i = 1; i \u0026lt;= n; i++) //对称的 if (L[i] == 1) { int t = 1; while(a[t][i] || v[t][i]) t++; v[t][i] = 1; cnt++; H[t]--; L[i]--; FH[t] = 1; FL[i] = 1; for (int j = 1; j \u0026lt;= n; j++) if (a[t][j]==0 \u0026amp;\u0026amp; j!=i \u0026amp;\u0026amp; v[t][j]==0) { v[t][j] = -1; H[t]--; L[j]--; } } if (tpcnt == cnt) break; } //Out(a,v,n); int top = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (a[i][j]==0 \u0026amp;\u0026amp; v[i][j]==0) { Pt[++top] = Pair(i,j); HZ[i]++; LZ[j]++; } sort(Pt+1,Pt+top+1);//同行同列少的排前面 Maxx = n-cnt; Mx = 0; used[0] = 0; dfs(1,top,0);//对剩下的0进行试探画‘O’ cnt += Mx; for (int i = 1; i \u0026lt;= used[0]; i++) { v[Pt[used[i]].x][Pt[used[i]].y] = 1; FH[Pt[used[i]].x] = 1; FL[Pt[used[i]].y] = 1; } //Out(a,v,n); if (cnt == n) { //已经找到 int ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (v[i][j] == 1) ans += b[i][j]; return ans; } int flagx[N],flagy[N]; //对号标记 for (int i = 1; i \u0026lt;= n; i++) flagx[i] = flagy[i] = 0; int cas = 1;//时间戳，每次只检查新增对号行/列 for (int i = 1; i \u0026lt;= n; i++) if (!FH[i]) flagx[i] = cas; bool chang = 1; while (chang) { chang = 0; cas++; for (int i = 1; i \u0026lt;= n; i++) if (flagx[i] == cas-1) for (int j = 1; j \u0026lt;= n; j++) if (v[i][j] == -1) { flagy[j] = cas; chang = 1; } for (int i = 1; i \u0026lt;= n; i++) if (flagy[i] == cas-1) for (int j = 1; j \u0026lt;= n; j++) if (v[j][i] == 1) { flagx[j] = cas; chang = 1; } } int Mi = ~0u\u0026gt;\u0026gt;2; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (flagx[i] \u0026amp;\u0026amp; !flagy[j] \u0026amp;\u0026amp; Mi \u0026gt; a[i][j]) Mi = a[i][j]; //未划线找最小的 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (flagx[i] \u0026amp;\u0026amp; !flagy[j]) //未划线 a[i][j] -= Mi; else if (!flagx[i] \u0026amp;\u0026amp; flagy[j]) //线交点 a[i][j] += Mi; } } int main() { int n,a[N][N],b[N][N]; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i][j]); b[i][j] = -a[i][j]; } printf(\u0026quot;%d\\n%d\u0026quot;,calc(a,n),-calc(b,n)); return 0; } ","date":"2019-06-28","permalink":"https://wineee.github.io/post/cpplab_hungarian_algorithm/","tags":["c++","匈牙利算法"],"title":"[管理运筹学]指派问题的匈牙利算法及其c++实现 (例:「网络流 24 题」分配问题 )"},{"content":"题目 重排9宫 设计内容： 编写软件模拟排九宫。从九宫的某个状态出发，移动格子中的数字，使9宫格中的数字顺序排列，空格在最后。\n设计功能： 1、九宫初始化，绘制九宫初始状态。9宫格中只有一个位置是空的，其它位置分别是1-8的8个数字，\n2、手工输入移动九宫的步骤，如11d(第一行一列格中数字下移)，22r(第二行二列格中数字右移)，23u(第二行三列格中数字上移)等，记录移动后九宫状态，并形象绘制。要求判断移动是否合法。一次只能移动一个数字，并且只能到相邻的空格子中。\n3、记录从初始状态以后的移动步骤。\n4、判断成功状态，并给出成功提示。\n5、你能否让计算机自动求解（思考选作）。\n   7 5 6     8  2   4 3 1    初始状态\n   1 2 3     4 5 6   7 8     完成状态\n程序源代码 /* 输入命令介绍 w 手动输入九宫格（用0表示空白格） m 进入移动模式 11d 第一行一列格中数字下移 22r 第二行二列格中数字右移 23u 第二行三列格中数字上移 ...诸如此类 p 输出从初始状态以后的移动步骤 e 退出移动模式 r 随机生成一个九宫格 f 自动求解 e 退出程序 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int map[3][3]; void swap(int *a,int *b) { int t = *a; *a = *b; *b = t; } void print_map(int map[3][3]) { int i,j; for (i = 0; i \u0026lt; 3; i++) { for (j = 0; j \u0026lt; 3; j++) if(map[i][j]) printf(\u0026quot;%d \u0026quot;,map[i][j]); else printf(\u0026quot; \u0026quot;); puts(\u0026quot;\u0026quot;); } } void write() { int i,j,v[10] = {0};\tfor (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;map[i][j]); v[map[i][j]] = 1; } for (i = 0; i \u0026lt; 9; i++) if (v[i] != 1) { printf(\u0026quot;您的输入不合法，请重试!\\n\u0026quot;); write(); return; } printf(\u0026quot;输入成功!结果如下\\n\u0026quot;); print_map(map);\t} void random_map() { int i,j; for (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) map[i][j] = i*3+j; for (i = 0; i \u0026lt; 9; i++) swap(\u0026amp;map[rand()%3][rand()%3],\u0026amp;map[rand()%3][rand()%3]); print_map(map); } int in_map(int x,int y) { return x\u0026gt;=0 \u0026amp;\u0026amp; y\u0026gt;=0 \u0026amp;\u0026amp; x\u0026lt;3 \u0026amp;\u0026amp; y\u0026lt;3; } int map_to_int(int a[3][3]) { int ans = 0,i,j; for (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) ans = ans*10+a[i][j]; return ans; } void move() { char s[5]; int st[300][3],top = 0; while (~scanf(\u0026quot;%s\u0026quot;,s)) { if(s[0] == 'e') return; if(s[0] == 'p') { for (int i = 0; i \u0026lt; top; i++) { printf(\u0026quot;第%d行%d列格中数字\u0026quot;,st[i][0]+1,st[i][1]+1); if(st[i][2] == 0) puts(\u0026quot;上移\u0026quot;); else if(st[i][2] == 1) puts(\u0026quot;下移\u0026quot;); else if(st[i][2] == 2) puts(\u0026quot;左移\u0026quot;); else puts(\u0026quot;右移\u0026quot;); } continue; } int dx = 2,dy; switch(s[2]) { case 'u': dx=-1,dy=0,st[top][2]=0; break; case 'd': dx=1,dy=0,st[top][2]=1; break; case 'l': dx=0,dy=-1,st[top][2]=2; break; case 'r': dx=0,dy=1,st[top][2]=3; break; defalt: printf(\u0026quot;输入不合法!\\n\u0026quot;); } if(dx == 2) continue; int x = s[0]-'1',y = s[1]-'1'; if(!in_map(x+dx,y+dy) || !in_map(x,y)) { printf(\u0026quot;输入不合法!\\n\u0026quot;); continue; } swap(\u0026amp;map[x][y],\u0026amp;map[x+dx][y+dy]); st[top][0] = x; st[top++][1] = y; print_map(map); if(map_to_int(map) == 123456780) puts(\u0026quot;这是完成状态!!\u0026quot;); } } #define MAXX 362883 int q[MAXX],head,tail; int dis[MAXX],per[MAXX]; int xx[] = {1,-1,0,0}; int yy[] = {0,0,1,-1}; int next(int x) { return ++x == MAXX ? x = 0 : x; } int fac[11] = {1,1,2,6,24,120,720,5040,40320,362880,3628800}; int map_to_order(int a[3][3]) {\tint i,j,ans = 0; for (i = 0; i \u0026lt; 9; i++) { int cnt = 0; for (j = i+1; j \u0026lt; 9; j++) if (a[j/3][j%3] \u0026lt; a[i/3][i%3]) cnt++; ans += cnt*fac[8-i]; } return ans; } void int_to_map(int x,int a[3][3]) { int i; for (i = 8; ~i; i--,x /= 10) a[i/3][i%3] = x%10; } int ans[MAXX],top; void find() { head = 1; tail = 2; q[1] = map_to_int(map); if(q[1] == 123456780) { printf(\u0026quot;无需移动！\\n\u0026quot;); return; } int a[3][3],i,x,y,k; for (i = 0; i \u0026lt; MAXX; i++) dis[i] = 0xffffff,per[i] = 0; dis[map_to_order(map)] = 0; while(head != tail) { int_to_map(q[head],a); int old_id = map_to_order(a); for (x = 0; x \u0026lt; 3; x++) for (y = 0; y \u0026lt; 3; y++) for (i = 0; i \u0026lt; 4; i++) if (in_map(x+xx[i],y+yy[i])) { swap(\u0026amp;a[x][y],\u0026amp;a[x+xx[i]][y+yy[i]]); int new_id = map_to_order(a); if (dis[new_id] \u0026gt; dis[old_id]+1) { dis[new_id] = dis[old_id]+1; per[new_id] = q[head]; int id_int = map_to_int(a); if (id_int == 123456780){ printf(\u0026quot;可以通过%d次变换完成\\n\u0026quot;,dis[new_id]);\ttop = 0; for (k = id_int; k; ) { ans[++top] = k; int_to_map(k,a); k = per[map_to_order(a)];\t} int ttop = top; while(top) { printf(\u0026quot;第%d次变换后为：\\n\u0026quot;,ttop-top); int_to_map(ans[top],a); print_map(a);puts(\u0026quot;\u0026quot;); top--; } return; } q[tail] = id_int; tail = next(tail); } swap(\u0026amp;a[x][y],\u0026amp;a[x+xx[i]][y+yy[i]]); } head = next(head); } } int main() { srand(time(0)); char opt; while(~scanf(\u0026quot;%c\u0026quot;,\u0026amp;opt)) { if(opt == 'e') break; else if(opt == 'w') write(); else if(opt == 'm') move(); else if(opt == 'r') random_map(); else if(opt == 'f') find(); } return 0; } ","date":"2019-02-05","permalink":"https://wineee.github.io/post/cpplab_calc_jiugongge/","tags":["康托展开","bfs","c"],"title":"[c语言课程设计] 重排九宫问题"}]