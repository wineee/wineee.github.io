[{"content":"QtPDF 是 Qt 封装的 pdfium 模块，以 GPLv3/LGPLv3 协议分发，也可以在 QT marketplace 购买可商业版本\n下载源代码 git clone \u0026lt;https://code.qt.io/qt/qtwebengine.git\u0026gt; cd qtwebengine git checkout 5.12.8 git submodule update --init --recursive  注意：git checkout 选择自己 qt 的版本\n安装构建依赖 sudo apt install bison build-essential gperf flex python2 libasound2-dev libcups2-dev libdrm-dev libegl1-mesa-dev libnss3-dev libpci-dev libpulse-dev libudev-dev nodejs libxtst-dev gyp ninja-build sudo apt install libssl-dev libxcursor-dev libxcomposite-dev libxdamage-dev libxrandr-dev libfontconfig1-dev libxss-dev libsrtp2-dev libwebp-dev libjsoncpp-dev libopus-dev libminizip-dev libavutil-dev libavformat-dev libavcodec-dev libevent-dev libvpx-dev libsnappy-dev libre2-dev libprotobuf-dev protobuf-compile  如果报错 Project ERROR: Unknown module(s) in QT: qml-private， 需要安装 qtdeclarative5-dev\n编译 cd .. mkdir build cd build qmake ../qtwebengine NINJAJOBS=-j7 make -j7 make install  下面是 qmake 的输出信息，如果依赖安装不全可以参考一下\nRunning configuration tests... Done running configuration tests. Configure summary: Qt WebEngine: Embedded build ......................... no Full debug information ................. no Pepper Plugins ......................... yes Printing and PDF ....................... yes Proprietary Codecs ..................... no Spellchecker ........................... yes Native Spellchecker .................... no WebRTC ................................. yes Use System Ninja ....................... no Geolocation ............................ yes WebChannel support ..................... yes Use v8 snapshot ........................ yes Kerberos Authentication ................ no Support qpa-xcb ........................ yes Use ALSA ............................... yes Use PulseAudio ......................... yes Optional system libraries used: re2 .................................. yes icu .................................. no libwebp, libwebpmux and libwebpdemux . yes opus ................................. yes ffmpeg ............................... no libvpx ............................... yes snappy ............................... yes glib ................................. yes zlib ................................. yes minizip .............................. yes libevent ............................. yes jsoncpp .............................. yes protobuf ............................. yes libxml2 and libxslt .................. yes lcms2 ................................ yes png .................................. yes JPEG ................................. yes harfbuzz ............................. yes freetype ............................. yes Required system libraries: fontconfig ........................... yes dbus ................................. yes nss .................................. yes khr .................................. yes glibc ................................ yes Required system libraries for qpa-xcb: x11 .................................. yes libdrm ............................... yes xcomposite ........................... yes xcursor .............................. yes xi ................................... yes xtst ................................. yes Qt is now configured for building. Just run 'make'. Once everything is built, you must run 'make install'. Qt will be installed into '/usr'. Prior to reconfiguration, make sure you remove any leftovers from the previous build.  编译过程需要2-3个小时，内存占用高峰大概需要16G + 5G swap\n使用测试 QT += core gui widgets pdf pdfwidgets  如果能正常识别，说明配置成功了，可以试试下面这个例子：\nhttps://github.com/CryFeiFei/QtPdfTest\nPDF Viewer Example\n参考资料  QtPDF Build Instructions New QtLabs PDF module QtWebEngine/How to Try ","date":"2021-08-23","permalink":"https://wineee.github.io/post/qtpdf_make/","tags":["Haskell"],"title":"Codeworld: 使用Haskell实现一个贪吃蛇小游戏"},{"content":"haskell 的一些教学可以参考：\nhttps://www.seas.upenn.edu/~cis194/fall16/index.html\nCodeWorld：可以在线运行hs代码，基于ghc.js，四舍五入还是在本地跑\nhttps://code.world/haskell\n下面是利用 CodeWorld 画圆的小例子\nimport CodeWorld main :: IO() main = do drawingOf $ circle 1  还可以画多边形\nimport CodeWorld main :: IO () main = drawingOf triangle triangle :: Picture triangle = polygon [(9,9),(0,-9),(-9,9)]  通过 colored 函数添加颜色， 参数是: color picture\nimport CodeWorld main :: IO () main = drawingOf ourPicture ourPicture = colored green $ solidCircle 2  \u0026amp; 函数可以将图片合并\nimport CodeWorld main :: IO () main = drawingOf $ ourPicture \u0026amp; (solidCircle 5) ourPicture = colored green $ solidCircle 2  translated 函数实现移位，参数dx dy picture\nimport CodeWorld main :: IO () main = drawingOf $ ourPicture \u0026amp; translated 1 2 $ solidCircle 1 ourPicture = colored green $ solidCircle 1  下面实现贪吃蛇，代码参照了此教程，我添加了一些注释\nHaskell 类型系统确实强大，看名字和标注就能知道这个函数有什么用。编译器可以排查大部分错误，可惜我把 unfoldr i+1写成 i-1，无限递归了，找了半天bug（我都不知道怎么debug）\nimport CodeWorld import Data.List import Data.Text(pack, unpack) import System.Random type RandomNumber = Int gridSize = 0.5 -- 为了美观， gridSizeHf = 0.25 -- 坐标（0，0）为中心， 经调整（0，0）的格子占用（0，0）-（0.5，0.5）空间 main :: IO() main = do gen \u0026lt;- getStdGen activityOf (initialWorld gen) handleEvent drawWorld -- 初始化 事件相应 绘制 -- 定义游戏状态，GameIdle data GameState = GameIdle | GameRunning | GameOver deriving(Show, Eq) data World = World { rnds :: [RandomNumber] , state :: GameState , snake :: Snake , apple :: Apple , areaWidth :: Double , areaHeight :: Double } initialWorld :: StdGen -\u0026gt; World initialWorld gen = restartWorld rnds width height where rnds = randomRs (round(0-width), round(width-2)) gen width = 20 :: Double height = 20 :: Double restartWorld :: [RandomNumber] -\u0026gt; Double -\u0026gt; Double -\u0026gt; World restartWorld rnds w h = World rnds' GameRunning snake apple w h where snake = mkSnake (-3, 0) 3 blue apple = mkApple ((fromIntegral r1) / 2, (fromIntegral r2) / 2) green (r1:r2:rnds') = rnds drawWorld :: World -\u0026gt; Picture drawWorld world | state world == GameOver = draw world \u0026amp; translated 0 (1) (styledLettering Bold Handwriting (pack \u0026quot;Game Over\u0026quot;)) \u0026amp; translated 0 (-1) (styledLettering Bold Handwriting (pack score_str)) | otherwise = draw world where draw world = drawSnake (snake world) \u0026amp; drawApple (apple world) \u0026amp; rectangle (areaWidth world) (areaHeight world) score_str = \u0026quot;Playing Score is: \u0026quot; ++ (show $ score $ snake world) -- 蛇的方向 data Direction = DirectUp | DirectDown | DirectLeft | DirectRight deriving(Show, Eq, Ord) -- 蛇的动作 data SnakeAction = SnakeNoAct | SnakeMove | SnakeEat | SnakeDead deriving(Show, Eq) -- 定义蛇 data Snake = Snake { bodyPoints :: [Point] , ds :: Double , score :: Double , direct :: Direction , color :: Color , width :: Double } -- 初始化蛇 mkSnake :: Point -\u0026gt; Int -\u0026gt; Color -\u0026gt; Snake mkSnake startPoint len color = Snake body 0 0 DirectUp color w -- unfoldr 展开函数，从一个点生成其他点，直到产生Nothing where body = unfoldr (\\\\i -\u0026gt; if i \u0026lt; len then Just((x, y - w * fromIntegral i), i+1) else Nothing) 0 -- 初始值 (x, y) = startPoint w = gridSize -- foldr1 相当于 foldr 起始值为列表第一个值 -- . 函数与数学定义相似，f.g(x) 相当于 g(f(x)) drawSnake :: Snake -\u0026gt; Picture drawSnake snake = foldr1 (\u0026amp;) blks where blks = map ((colored snkColor) . drawBodyBlk) snkBody snkColor = color snake snkBody = bodyPoints snake drawBodyBlk (x, y) = translated (x + gridSizeHf) (y + gridSizeHf) $ solidRectangle (w - 0.05) (w - 0.05) -- solidRectangle 画图默认中心（0，0）， translated 加上 gridSizeHf 使其正好对应方格 w = width snake -- 蛇转向 turnSnake :: Direction -\u0026gt; Snake -\u0026gt; Snake turnSnake dir snake = if isConflictDirect dir (direct snake) then snake else snake { direct = dir } where isConflictDirect dir1 dir2 | dir1 == DirectUp \u0026amp;\u0026amp; dir2 == DirectDown = True | dir1 == DirectDown \u0026amp;\u0026amp; dir2 == DirectUp = True | dir1 == DirectRight \u0026amp;\u0026amp; dir2 == DirectLeft = True | dir1 == DirectLeft \u0026amp;\u0026amp; dir2 == DirectRight = True | otherwise = False -- 蛇前进一个单位 moveSnake :: Snake -\u0026gt; Snake moveSnake snake = snake { ds = 0, bodyPoints = pts } where ptsOrg = bodyPoints snake pts = pt : init ptsOrg -- 去尾加头 pt = translatedPoint dx dy $ head ptsOrg (dx, dy) = getSnakeDxDy snake -- 按当前方向蛇头的移动dx，dy getSnakeDxDy snake@(Snake _ _ _ direct _ w) | direct == DirectUp = (0, w) | direct == DirectDown = (0, -w) | direct == DirectLeft = (-w, 0) | direct == DirectRight = (w, 0) -- 吃苹果 eatingSnake :: Snake -\u0026gt; Snake eatingSnake snake = snake { ds = 0, score = score', bodyPoints = pts} where ptsOrg = bodyPoints snake pts = pt : ptsOrg pt = translatedPoint dx dy $ head ptsOrg (dx, dy) = getSnakeDxDy snake score' = score snake + 1 data Apple = Apple { positionA :: Point , colorA :: Color , widthA :: Double } mkApple :: Point -\u0026gt; Color -\u0026gt; Apple mkApple pos color = Apple pos color 0.25 -- 显示苹果 drawApple :: Apple -\u0026gt; Picture drawApple apple@(Apple pos color width) = translated (x + gridSizeHf) (y + gridSizeHf) $ colored color $ solidCircle width where (x, y) = pos -- 随机生成苹果 randowApple :: World -\u0026gt; (Apple, [RandomNumber]) randowApple world@(World rnds _ _ apple w h) = (mkApple pos color, rnds') where pos = ((fromIntegral r1) / 2, (fromIntegral r2) /2) color = if colorOrg == red then green else red (r1:r2:rnds') = rnds colorOrg = colorA apple handleEvent :: Event -\u0026gt; World -\u0026gt; World -- 计时事件 handleEvent (TimePassing dt) w | state w == GameOver = w | otherwise = handleSnakeAction snake' action $ w where (snake', action) = checkSnakeAction dt w (snake w) -- 按键事件 handleEvent (KeyPress keyText) w | state w == GameOver \u0026amp;\u0026amp; unpack keyText == \u0026quot;Enter\u0026quot; = restartWorld (rnds w) areaW areaH | unpack keyText == \u0026quot;Down\u0026quot; = w { snake = turnSnake DirectDown snake' } | unpack keyText == \u0026quot;Up\u0026quot; = w { snake = turnSnake DirectUp snake' } | unpack keyText == \u0026quot;Left\u0026quot; = w { snake = turnSnake DirectLeft snake' } | unpack keyText == \u0026quot;Right\u0026quot; = w { snake = turnSnake DirectRight snake' } | otherwise = w where snake' = snake w areaW = areaWidth w areaH = areaHeight w handleEvent _ w = w -- 进行一步动作 handleSnakeAction :: Snake -\u0026gt; SnakeAction -\u0026gt; World -\u0026gt; World handleSnakeAction snake' action w | action == SnakeMove = w {snake = moveSnake snake'} | action == SnakeEat = w { snake = eatingSnake snake' , apple = apple' -- 重新生成苹果 , rnds = rnds'} | action == SnakeNoAct = w { snake = snake' } | action == SnakeDead = w { state = GameOver } where (apple', rnds') = randowApple w snakeSpeed = 0.05 -- 碰撞检测部分 checkSnakeAction :: Double -\u0026gt; World -\u0026gt; Snake -\u0026gt; (Snake, SnakeAction) checkSnakeAction dt world snakeS = if ds' \u0026gt; snkW then (snakeS { ds = 0 }, action ) -- 动了超过一格 else (snakeS { ds = ds' }, action1 ) where ds' = ds snakeS + dt + snakeSpeed snkW = width snakeS headOrg = head $ bodyPoints $ snake world -- 蛇头 headN = translatedPoint dx dy headOrg -- 新蛇头 (dx, dy) = getSnakeDxDy snakeS appleOrg = apple world (snkHead:snkTail) = bodyPoints $ snake world -- 动了超过一格，判断吃或只移动（死了下一帧判断） action = if headN == positionA appleOrg then SnakeEat else SnakeMove -- 判断蛇头是否撞蛇身或出界 action1 = if headOrg `elem` snkTail || outofBound headOrg then SnakeDead else SnakeNoAct outofBound (x, y) = if x \u0026lt; 0 - maxW || x \u0026gt; maxW - gridSize || y \u0026lt; 0 - maxH || y \u0026gt; maxH - gridSize then True else False maxW = areaWidth world / 2 maxH = areaHeight world / 2  游戏效果：\n","date":"2021-08-20","permalink":"https://wineee.github.io/post/haskell_snake_game/","tags":["Haskell"],"title":"Codeworld: 使用Haskell实现一个贪吃蛇小游戏"},{"content":"运算符函数 (!!) 取第n个元素 Prelude\u0026gt; :t (!!) (!!) :: [a] -\u0026gt; Int -\u0026gt; a Prelude\u0026gt; [0,1,2,3,4]!!3 3 Prelude\u0026gt; [0,1,2,3,4]!!0 0  乘方 (^), (^^),(**) Prelude\u0026gt; :t (^) (^) :: (Integral b, Num a) =\u0026gt; a -\u0026gt; b -\u0026gt; a Prelude\u0026gt; 54.5^5 4.8081998590625e8 Prelude\u0026gt; :t (^^) (^^) :: (Fractional a, Integral b) =\u0026gt; a -\u0026gt; b -\u0026gt; a Prelude\u0026gt; 5.6^^6 30840.979455999986 Prelude\u0026gt; :t (**) (**) :: Floating a =\u0026gt; a -\u0026gt; a -\u0026gt; a Prelude\u0026gt; 0.2**0.1 0.8513399225207846  取余函数 Prelude\u0026gt; mod (-2) 4 2 Prelude\u0026gt; rem (-2) 4 -2  求商函数 Prelude\u0026gt; div (-5) 3 -2 Prelude\u0026gt; quot (-5) 3 -1  (:) 连接元素与列表 Prelude\u0026gt; 1:[2,3] [1,2,3]  (++) 连接两个列表 Prelude\u0026gt; [1,2,3]++[4,5,6] [1,2,3,4,5,6]  ($) 改变运算优先级 ($) 有最低优先级，并且右结合\nPrelude\u0026gt; gcd 4 $ mod 5 6 1  预加载库(Prelude)函数 恒指函数 id Prelude\u0026gt; :t id id :: a -\u0026gt; a Prelude\u0026gt; id 2333.3 2333.3  常值函数 const 返回俩个参数的第一个\nPrelude\u0026gt; :t const const :: a -\u0026gt; b -\u0026gt; a Prelude\u0026gt; const \u0026quot;434\u0026quot; 5 \u0026quot;434\u0026quot;  参数反置函数flip 将二元函数参数顺序颠倒\nPrelude\u0026gt; :t flip flip :: (a -\u0026gt; b -\u0026gt; c) -\u0026gt; b -\u0026gt; a -\u0026gt; c Prelude\u0026gt; flip const 1 2 2  错误函数error Prelude\u0026gt; :t error error :: [Char] -\u0026gt; a Prelude\u0026gt; a = error \u0026quot;error case a\u0026quot; Prelude\u0026gt; a *** Exception: error case a CallStack (from HasCallStack): error, called at \u0026lt;interactive\u0026gt;:28:5 in interactive:Ghci11  undefined Prelude\u0026gt; :t undefined undefined :: a Prelude\u0026gt; undefined *** Exception: Prelude.undefined CallStack (from HasCallStack): error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err undefined, called at \u0026lt;interactive\u0026gt;:31:1 in interactive:Ghci12  min,max 取最值 Prelude\u0026gt; :t min min :: Ord a =\u0026gt; a -\u0026gt; a -\u0026gt; a Prelude\u0026gt; :t max max :: Ord a =\u0026gt; a -\u0026gt; a -\u0026gt; a Prelude\u0026gt; max 42 (-4) --注意括号 42 Prelude\u0026gt; max 2.1 4.5 4.5  基于列表的函数 null 判断是否为空 Prelude\u0026gt; :t null null :: Foldable t =\u0026gt; t a -\u0026gt; Bool Prelude\u0026gt; null [] True Prelude\u0026gt; null [[]] False  length 长度 Prelude\u0026gt; :t length length :: Foldable t =\u0026gt; t a -\u0026gt; Int Prelude\u0026gt; length [] 0 Prelude\u0026gt; length [1,3,2,-2] 4  reverse 翻转列表 Prelude\u0026gt; :t reverse reverse :: [a] -\u0026gt; [a] Prelude\u0026gt; reverse [0,1,2,3,4] [4,3,2,1,0]  head,last Prelude\u0026gt; :t head head :: [a] -\u0026gt; a Prelude\u0026gt; head [1,2,3] 1 Prelude\u0026gt; :t last last :: [a] -\u0026gt; a Prelude\u0026gt; last [1,2,3] 3  init,tail Prelude\u0026gt; :t init init :: [a] -\u0026gt; [a] Prelude\u0026gt; init [1,2,3] [1,2] Prelude\u0026gt; :t tail tail :: [a] -\u0026gt; [a] Prelude\u0026gt; tail [1,2,3] [2,3]  map 将一个函数应用到列表每个元素 Prelude\u0026gt; :t map map :: (a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; [b] Prelude\u0026gt; map (+1) [1,2,3,4] [2,3,4,5] Prelude\u0026gt; map (1+) [1,2,3,4] [2,3,4,5] Prelude\u0026gt; map (\\x -\u0026gt; x*2+1) [1,2,3,4] [3,5,7,9]  filter 过滤出满足条件的元素 Prelude\u0026gt; :t filter filter :: (a -\u0026gt; Bool) -\u0026gt; [a] -\u0026gt; [a] Prelude\u0026gt; filter odd [1,2,3,4,5,6] [1,3,5]  take,drop 从头、尾连续取n个元素 Prelude\u0026gt; :t take take :: Int -\u0026gt; [a] -\u0026gt; [a] Prelude\u0026gt; take 6 [1..] [1,2,3,4,5,6] Prelude\u0026gt; :t drop drop :: Int -\u0026gt; [a] -\u0026gt; [a] Prelude\u0026gt; drop 2 [1,2,3,4] [3,4]  span,break span :: (a -\u0026gt; Bool) -\u0026gt; [a] -\u0026gt; ([a], [a]) Prelude\u0026gt; span even [2,4,6,1,2,3,5,7] ([2,4,6],[1,2,3,5,7]) break :: (a -\u0026gt; Bool) -\u0026gt; [a] -\u0026gt; ([a], [a]) Prelude\u0026gt; break odd [2,4,6,1,2,3,5,7] ([2,4,6],[1,2,3,5,7])  takeWhile,dropWhile takeWhile :: (a -\u0026gt; Bool) -\u0026gt; [a] -\u0026gt; [a] Prelude\u0026gt; takeWhile (\u0026lt;7) [1,2,3,5,6,7,8,8] [1,2,3,5,6] dropWhile :: (a -\u0026gt; Bool) -\u0026gt; [a] -\u0026gt; [a] Prelude\u0026gt; dropWhile (\u0026lt;7) [1,2,3,5,6,7,8,8] [7,8,8]  splitAt 将列表在任何位置分开 Prelude\u0026gt; :t splitAt splitAt :: Int -\u0026gt; [a] -\u0026gt; ([a], [a]) Prelude\u0026gt; splitAt 4 \u0026quot;abcdef\u0026quot; (\u0026quot;abcd\u0026quot;,\u0026quot;ef\u0026quot;) Prelude\u0026gt; splitAt 4 [1,2,3,4,5,6] ([1,2,3,4],[5,6])  重复函数repeat, 复制函数replicate repeat :: a -\u0026gt; [a] Prelude\u0026gt; take 5 $ repeat 6 [6,6,6,6,6] replicate :: Int -\u0026gt; a -\u0026gt; [a] Prelude\u0026gt; replicate 5 6 [6,6,6,6,6]  any,all any :: Foldable t =\u0026gt; (a -\u0026gt; Bool) -\u0026gt; t a -\u0026gt; Bool Prelude\u0026gt; any even [1,2,3] True Prelude\u0026gt; any even [1,3] False all :: Foldable t =\u0026gt; (a -\u0026gt; Bool) -\u0026gt; t a -\u0026gt; Bool Prelude\u0026gt; all even [2,4,6,1] False  elem,notElem elem :: (Foldable t, Eq a) =\u0026gt; a -\u0026gt; t a -\u0026gt; Bool Prelude\u0026gt; elem 3 [1,2,3] True Prelude\u0026gt; elem 3 [1,2,4] False notElem :: (Foldable t, Eq a) =\u0026gt; a -\u0026gt; t a -\u0026gt; Bool Prelude\u0026gt; notElem 3 [1,2,3] False  iterate 把一个函数对一个元素重复应用无数次 iterate :: (a -\u0026gt; a) -\u0026gt; a -\u0026gt; [a] Prelude\u0026gt; take 10 $ iterate (*2) 1 [1,2,4,8,16,32,64,128,256,512]  until 把一个函数对一个元素重复应用至满足条件 until :: (a -\u0026gt; Bool) -\u0026gt; (a -\u0026gt; a) -\u0026gt; a -\u0026gt; a Prelude\u0026gt; until (\u0026gt;1024) (*2) 1 2048  zip 把两个列表合成一个元组的列表 zip :: [a] -\u0026gt; [b] -\u0026gt; [(a, b)] Prelude\u0026gt; zip [1,2,3,4] \u0026quot;abcd\u0026quot; [(1,'a'),(2,'b'),(3,'c'),(4,'d')]  concat 将列表中的列表相连 concat :: Foldable t =\u0026gt; t [a] -\u0026gt; [a] Prelude\u0026gt; concat [[1,2],[3],[4,5,6]] [1,2,3,4,5,6]  concatMap concatMap :: Foldable t =\u0026gt; (a -\u0026gt; [b]) -\u0026gt; t a -\u0026gt; [b] Prelude\u0026gt; map (replicate 2) [1,2,3] [[1,1],[2,2],[3,3]] Prelude\u0026gt; concatMap (replicate 2) [1,2,3] [1,1,2,2,3,3]  字符串处理 show 转化为字符串 show :: Show a =\u0026gt; a -\u0026gt; String Prelude\u0026gt; show True \u0026quot;True\u0026quot; Prelude\u0026gt; show 33.3 \u0026quot;33.3\u0026quot;  read 从字符串读取，需要注明类型 read :: Read a =\u0026gt; String -\u0026gt; a Prelude\u0026gt; (\\str-\u0026gt;read str::Int) \u0026quot;2333\u0026quot; 2333  lines,unlines 以换行分开 lines :: String -\u0026gt; [String] Prelude\u0026gt; lines \u0026quot;abc\\nccc\\ngt\u0026quot; [\u0026quot;abc\u0026quot;,\u0026quot;ccc\u0026quot;,\u0026quot;gt\u0026quot;] unlines :: [String] -\u0026gt; String Prelude\u0026gt; unlines [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;] \u0026quot;a\\nb\\n\u0026quot;  word,unword 以空格分开 words :: String -\u0026gt; [String] Prelude\u0026gt; words \u0026quot;hi,I am Li Huan\\nline2\u0026quot; [\u0026quot;hi,I\u0026quot;,\u0026quot;am\u0026quot;,\u0026quot;Li\u0026quot;,\u0026quot;Huan\u0026quot;,\u0026quot;line2\u0026quot;] unwords :: [String] -\u0026gt; String Prelude\u0026gt; unwords [\u0026quot;1\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;cd\u0026quot;] \u0026quot;1 2 cd\u0026quot; ","date":"2021-06-21","permalink":"https://wineee.github.io/post/leran_haskell_01/","tags":["Haskell"],"title":"Haskell 常用函数笔记"},{"content":"第1章 软件与软件工程的概念 了解与软件相关的基本概念，包括软件、程序、数据、文档。 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合。\n 软件 = 程序+数据+文档  程序是按事先设计的功能和性能要求执行的指令序列。\n 程序 = 数据结构+算法  数据是使程序能正常操纵信息的数据结构。 文档是与程序开发，维护和使用有关的图文材料。\n了解软件危机的表现及发生的原因。 软件危机的表现:\n对软件开发成本和进度的估计常常很不准确。 用户对“已完成的”软件系统不满意。 软件产品的质量往往靠不住，错误多、性能低、不安全、不可靠。 软件通常没有适当的文档资料，常常不可维护。 软件成本在计算机系统总成本中所占的比例逐年上升。 软件开发生产率提高的速度，既跟不上硬件的发展速度，也远远跟不上计算机应用迅速普及深入的趋势。\n软件开发面临的挑战:\n 不断增长的系统复杂性 软件系统规模越来越大、越来越复杂 需求不断变化，要求更快地构建和交付 未采用有效的软件工程方法 有些软件团队不重视软件工程方法的应用，使得软件成本高、性能差、可靠性低。 软件工程方法需要随着客观世界的演化而不断发展，迎接交付更复杂的软件的新挑战。  掌握软件工程的概念。 概括地说，软件工程是指导计算机软件开发和维护的工程学科。\u000b采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。\n软件生命周期由哪三个时期组成，每个时期又可划分为哪些阶段？每个阶段的主要任务是什么？ 三个时期：软件定义、软件开发、软件使用与维护\n软件定义时期包括： 问题定义（确定做什么）： 关键问题是：“要解决的问题是什么”。 提交的内容是关于问题性质、工程目标和工程规模的书面报告。\n可行性研究（能不能做）： 回答的关键问题是：“上一个阶段所确定的问题是否有行得通的解决办法”。 提交的内容为可行性研究报告，即从技术、经济和社会因素等方面研究各方案的可行性。\n需求分析（详细的说做什么）：\n 对用户提出的要求进行分析并给出详细的定义 准确地回答“目标系统必须做什么”这个问题。 对目标系统提出完整、准确、清晰、具体的要求。 编写软件需求说明书或系统功能说明书及初步的系统用户手册  提交管理机构评审\n软件开发时期包括： 概要设计（概要说怎么做）： 概括地回答“怎样实现目标系统?”。设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。提交的文档是概要设计说明书。\n详细设计（详细说怎么做）： 回答“应该怎样具体地实现这个系统”。详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。提交的文档是软件的详细设计说明书。\n编码（根据设计编写代码）： 写出正确的容易理解、容易维护的程序模块。提交的文档为源程序、详尽的程序说明和单元测试报告。\n软件使用与维护时期： 测试： 通过各种类型的测试(及相应的调试)使软件达到预定的要求。 提交的文档为测试计划、详细测试方案以及实际测试结果等。\n维护：\n 改正性维护 ：运行中发现了软件中的错误需要修正。 适应性维护 ：为适应变化了的软件工作环境，需做适当变更。 完善性维护 ：为了增强软件的功能需做变更。 预防性维护 ：修改软件为将来的维护活动预先做准备。  掌握软件工程方法学的三个基本要素及其作用。 方法：完成软件开发的各项任务的技术方法。 工具：为方法的运用提供自动的或半自动的软件支撑环境； 过程：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。\n了解传统方法及面向对象方法各自的特点。 传统方法的特点：\n  传统方法建立的软件结构依赖于要完成的功能，当功能需求发生变化时将引起软件结构的整体修改。用户需求基本是针对功能的，系统不稳定。\n  传统的软件重用技术是利用标准函数库。标准函数库往往只提供最基本、最常用的功能，还缺乏必要的柔性。\n  OO方法学的主要优点\n可重用性好 传统的软件重用技术是利用标准函数库。 标准函数库往往只提供最基本、最常用的功能，还缺乏必要的柔性。 对象固有的封装性和信息隐蔽，使对象具有较强的独立性。 对象提供了较理想的可重用的软件成分。重用时提供了很大的灵活性。（派生和继承）\n可维护性好 面向对象的软件稳定性好 面向对象的软件容易理解 面向对象的软件容易修改 易于测试和调试\n第2章 软件生存期模型 典型的软件生存期模型(即软件过程模型)有哪几种，每种模型有哪些优缺点。 软件过程：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。\n可将软件生存周期划分为：\n（1）3个过程是：软件定义过程、软件开发过程、软件使用与维护过程。\n（2）9个阶段有：可行性研究、需求分析、概要设计、详细设计、实现、组装测试、验收测试、使用与维护、退役。\n1、瀑布模型\n将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，包括问题定义及规划、需求分析、软件设计、程序编码、软件测试和运行维护等六个基本活动，并且规定了他们自上而下，相互衔接的固定次序，形如瀑布流水，逐级下落，具有顺序性和依赖性，最终得到软件产品。\n因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。\n2、V模型\n通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。其形状像一个字母A，故称为V模型。传统软件开发模型，一般适用于一些传统信息系统应用的开发。\n3、敏捷开发模型\n以用户需求进化为核心（强调沟通、弱化文档）、迭代、循序渐进的开发方法。强调以人为本，专注于交付对客户有价值的软件，是一个用于开发和维持复杂产品的框架。\n瀑布模型的优缺点 瀑布模型就像工厂流水线一样把软件开发分层化。 让软件开发过程有序、可控，使分工协作成为可能。 质量有保证。 瀑布模型是现代软件工程的起源，软件工程的发展，很大部分都是构建于瀑布模型的基础之上的。 由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要\n瀑布模型适用于需求已确定、工作采用线性方式完成的情况。\n快速原型模型的优点 有助于满足用户的真实需求 原型系统已经通过与用户的交互而得到验证，据此产生的规格说明文档能够正确地描述用户需求。\n增量模型的优点 能在较短时间内向用户提交可完成一些有用的工作的产品，即从第一个构件交付之日起，用户就能做一些有用的工作。 逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户组织带来的冲击。 项目失败的风险较低，虽然某些增量构件可能遇到问题，但其他增量构件将能够成功地交付给客户。 优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来。因此，最重要的系统服务将接受最多的测试。\n增量模型的困难 软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便。 在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。 采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计。\n螺旋模型 优点 是开发高风险的大型软件系统的实用模型。 可以降低风险，减少项目因风险造成的损失。 缺点 螺旋模型是风险驱动的，因此要求软件开发人员必须具有丰富的风险评估经验和这方面的专门知识，否则将出现真正的风险：当项目实际上正在走向灾难时，开发人员可能还以为一切正常。\n第3章 软件需求分析 软件需求分析分为哪4个步骤？各个步骤的主要任务是什么？ 需求获取，需求分析，需求定义，需求验证\n需求获取 通过启发、引导客户（或用户）而获得软件的原始需求，即软件的业务要求（needs），简称为N。\n需求分析 获取的需求N可能存在各种问题，直接把获取的需求作为软件设计阶段的依据将会导致严重的后果。 需要对获取的需求全面分析并进行相应的调整，从而得到分析的需求R1（b+c）。\n需求定义 清晰、全面、系统、准确地描述需求文档，编写需求规格说明。\n需求验证 为了确保已定义的需求（需求规格说明）准确无误，并能为客户（或用户）理解和接受，需要对其进行严格的评审。\n软件需求分析的困难是什么？ 系统的目标或范围问题 需求不准确性问题 需求的易变问题 需求获取除了需要有专业的系统分析师，还需要通过有效的客户／开发者的合作才能成功。\n用户说不清楚需求 用户经常变更需求 合作态度 知识技能问题：隔行如隔山 双方误解需求 开发人员写不好需求文档\n第4章 人机交互设计 人机交互设计的准则 第5章 面向对象方法与UML UML模型由事物、关系和图组成\n了解UML中的事物及其分类。 事物是对模型中最具代表性成分的抽象； 在UML中，分为结构事物、行为事物、分组事物和注释事物4类。\n结构事物：是UML模型的静态部分，主要用来描述概念的或物理的元素，包括类、主动类、接口、对象、用例、参与者、协作、构件和节点等。 行为事物：行为事物是UML模型的动态部分，包括两类： 交互（interaction）：由在特定的上下文环境中共同完成一定任务的一组对象之间传递的消息组成。 状态机（state machine）：描述了一个对象或一个交互在生存周期内响应事件所经历的状态序列，单个类或者一组类之间协作的行为都可以用状态机来描述。\n分组事物 UML模型的组织部分，作用是为了降低模型复杂性。 UML中的分组事物是包（package）。 包是把模型元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。 注释事物 UML模型的解释部分，用来描述和标注模型的任何元素。 通常可以用注释修饰带有约束或者解释的图。\n了解UML中的关系，包括依赖关系、关联关系、泛化关系和实现关系等。\n掌握UML中5种类型的图，包括用例图、类图、顺序图、状态图、活动图。 用例图 用例是对系统提供的功能(即系统的具体用法)的描述。 用例图从用户的角度描述系统功能，并指出各个功能的操作者。 用例图定义了系统的功能需求。\n类图 类图不仅定义系统中的类，表示类与类之间的关系，也表示类的内部结构(类的属性和操作)。 类图描述的是一种静态关系，在系统的整个生命期内都是有效的。\n顺序图 顺序图显示若干个对象间的动态协作关系，它强调对象之间发送消息的先后次序，描述对象之间的交互过程。\n状态图 状态图描述类的对象可能具有的所有状态，以及引起状态变化的事件，状态变化称作状态转换。通常，状态图是对类图的补充。\n活动图 活动图描述为满足用例要求而进行的动作以及动作间的关系。 活动图是状态图的一个变种，它是另一种描述交互的方法。\n第6章 面向对象分析 了解面向对象分析中的三个模型和五个层次。  面向对象分析就是抽取和整理用户需求并建立问题域精确模型的过程。 三个模型：用例模型、对象模型、交互模型 五个层次：类与对象层、属性层、服务层、结构层、主题层  掌握有关用例模型、对象模型和动态模型的基本概念。 能够针对具体应用，建立用例模型、对象模型和动态模型(状态图和顺序图)的过程。 第7章 面向对象设计原则与软件设计模式 掌握面向对象设计原则 单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、合成复用原则、接口隔离原则、迪米特法则。\n   设计原则名称 设计原则简介 重要性     单一职责原则 类的职责要单一，不能将太多的职责放在一个类中 ★★★★☆   开闭原则 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能 ★★★★★   里氏代换原则 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象 ★★★★☆   依赖倒转原则 要针对抽象层编程，而不要针对具体类编程 ★★★★★   接口隔离原则 使用多个专门的接口来取代一个统一的接口 ★★☆☆☆   合成复用原则 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系 ★★★★☆   迪米特法则 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。 ★★★☆☆    掌握设计模式的概念。 设计模式描述了软件设计过程中某一类常见问题的一般性的解决方案。\n设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\n掌握常用的设计模式：单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、适配器模式、外观模式、桥接模式、观察者模式、迭代器模式。 单例模式：\n确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类。 单例模式的要点有三个 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。\n简单工厂模式：\n在简单工厂模式中，可以根据参数的不同返回不同类的实例。 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n简单工厂模式的优点 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n简单工厂模式的缺点 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。 在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。\n工厂方法模式：\n定义抽象工厂类。 再定义若干具体工厂类\n结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构\n适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的类可以一起工作\n外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面\n行为型模式是对在不同的对象之间划分责任和算法的抽象化。\n观察者模式：定义对象间的一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。\n第8章 面向对象设计 了解软件系统分解的方法。 掌握典型的面向对象设计模型。 了解4个子系统的设计方法。 第10章 软件测试 了解软件测试的概念、软件测试的目标。  软件测试是为了发现错误而执行程序的过程。 软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例（即输入数据及其预期的输出结果），并利用这些测试用例去运行程序，以发现程序错误的过程。 (1) 测试是程序的执行过程,目的在于发现错误； (2) 一个好的测试用例在于, 能发现至今未发现的错误； (3) 一个成功的测试是,发现了至今未发现的错误的测试。  掌握白盒测试中使用逻辑覆盖和基本路径测试的测试用例设计方法。 语句覆盖就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次\n判定覆盖，又称分支覆盖，就是设计若干个测试用例，运行被测程序，使得程序中每个判断框的取真分支和取假分支至少执行一次\n条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断框中的每个条件的可能取值至少执行一次。\n判定－条件覆盖就是设计足够的测试用例，使得每个判断框的所有可能取值至少执行一次；判断框中每个条件的所有可能取值至少执行一次。\n条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断框的所有可能的条件取值组合至少执行一次。(但可能有的路径会遗漏掉)\n路径覆盖就是设计足够的测试用例，覆盖程序中所有可能的路径。 (路径覆盖并不一定达到条件组合覆盖)\n掌握程序控制流图的画法及环路复杂性的计算方法。 控制流图 ：描述程序控制流的一种图示方法。 即退化的程序流程图。\n边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。\n如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, \u0026hellip;)连接的复合条件表达式，则需改为\u000b一系列只有单个条件的嵌套的判断。\nMcCabe方法，又称环路复杂性度量，是一种基于程序控制流的复杂性度量方法。 它基于一个程序模块的流图中环路的个数。\n有向图G的环路复杂性的公式 I. V (G)＝m－n＋2\n​ 其中，V（G）\u0026mdash;\u0026ndash; 有向图G中的环路个数 ​\tm \u0026mdash;\u0026mdash; 图G中边的个数 ​\tn \u0026mdash;\u0026mdash;- 图G中结点个数 ​\tII．区域个数 ​\tIII．V（G）=判定结点数+1\n(1) V(G) = 边的条数-节点个数+2 =11-9+2=4 (2) V(G) = 区域个数 = 4 (3) V(G) = 判定节点个数+1 = 3+1=4\n掌握黑盒测试用例设计的方法：等价类划分法、边界值分析。  等价类划分法:把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。 等价类 ：某个输入域的子集合。\u000b在该子集合中，各个输入数据对于揭露程\u000b序中的错误都是等效的。测试某等价类的代\u000b表值就等价于对这一类其它值的测试。 等价类的划分 有效等价类： 对于程序的规格说明来说，是合理的、有意义的输入数据构成的集合。 无效等价类：对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。 设计测试用例时，要同时考虑有效等价类和无效等价类的设计。 为什么要用边界值分析 大量的错误都发生在输入或输出范围的边界上，而不是在输入范围的内部。 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。  了解软件测试的步骤和策略，包括单元测试、组装测试、确认测试和系统测试。  单元测试又称模块测试，是针对软件设计的最小单位 ─ 程序模块，进行正确性检验的测试工作。 一次性组装方式(big bang):首先对每个模块分别进行模块测试，然后再把所有模块组装在一起进行测试，最终得到要求的软件系统。 是一种非增殖式组装方式，也叫做整体拼装。 增殖式组装方式:又称渐增式组装 首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统。 在组装的过程中边连接边测试，以发现连接过程中产生的问题。 通过增殖逐步组装成为要求的软件系统。 确认测试的步骤:有效性测试 在开发环境下，运用黑盒测试方法，验证被测软件是否满足需求规格说明书列出的需求。 系统测试（system testing）是将软件作为整个计算机系统的一个元素，与硬件、其他软件、数据、人员等其他系统元素结合在一起，在实际使用环境下，对计算机系统进行一系列的组装测试和确认测试。  第9章 编码 理解程序设计风格的重要性。 程序实际上也是一种供人阅读的文章，有一个文章的风格问题。应该使程序具有良好的风格。\n了解程序设计风格的4个方面。 源程序文档化 数据说明标准化 语句结构简单化 输入／输出规范化\n重构的概念、目的、具体做法。  重构的概念：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。 重构的本质是在代码写好之后改进它的设计。 重构的目的 改进软件的设计。 使软件更容易理解。 帮助尽早的发现错误。 提高编程速度。 重构的流程 读懂代码(包括测试例子代码) 重构 运行所有的Unit Tests ","date":"2021-05-10","permalink":"https://wineee.github.io/post/softwareengineeringnote/","tags":["软件工程"],"title":"软件工程知识点总结"},{"content":"前不久，2020图灵奖今日出炉，龙书作者 Alfred Vaino Aho 和 Jeffrey David Ullman 获奖，作为计算机界的最高荣誉，图灵奖获得者及其成果对计算机学科意义非凡，以前只是大概知道几个人，今天，特地翻了翻维基，看看得奖的都有谁。\n最为知名的获奖者 肯·汤普森 Ken Thompson\n丹尼斯·里奇 Dennis M. Ritchie\n肯·汤普森与丹尼斯·里奇设计了 B 语言、C 语言，之后用 C 语言重写了 UNIX。\n如今，汤普森老当益壮，又主导了 Go 语言的开发。\n 这两位可能比图灵还出名\n 艾兹格·迪科斯彻 Edsger Dijkstra\n他的贡献有：\n 提出“goto有害论” Dijkstra最短路径算法 提出信号量和PV原语 解决了“哲学家聚餐”问题 银行家算法的创造者 第一个Algol 60编译器的设计者和实现者 THE操作系统的设计者和开发者 被西方学术界称为“结构程序设计之父”和“先知”   学数据结构告诉你他是图灵奖得主，学操作系统时又不止一次告诉你他是图灵奖得主，学程序设计还要提醒你他是图灵奖得主。简直是图灵奖界的劳模。\n 姚期智 Andrew Chi-Chih Yao\n最先提出量子通信复杂性，基本上完成了量子计算机的理论基础，之后提出分布式量子计算模式，成为分布式量子算法和量子通讯协议安全性的基础。\n研究方向包括计算理论及其在密码学和量子计算中的应用。在三大方面具有突出贡献：\n 创建理论计算机科学的重要次领域：通讯复杂性和伪随机数生成计算理论； 奠定现代密码学基础，在基于复杂性的密码学和安全形式化方法方面有根本性贡献； 解决线路复杂性、计算几何、数据结构及量子计算等领域的开放性问题并建立全新典范   唯一的华人获奖者，进入清华姚班是无数学子的梦想\n 罗伯特·塔扬 Robert Tarjan\n他的一些著名的算法包括：\n  最近共同祖先离线 Tarjan 算法\n  强连通分量 Tarjan 算法\n  Hopcroft-Tarjan 平面嵌入算法，第一个线性时间平面算法。\n  数据结构：\n 斐波纳契堆 splay 树（splay 发明者还有Daniel Sleator） Link-Cut-Tree  另一项重大贡献是分析了并查集。他是第一个证明了计算反阿克曼函数的乐观时间复杂度的科学家。\n 别人可能不熟悉，但 OIer 一定知道他\n 高德纳 Donald E. Knuth\n TeX 排版软件 《计算机程序设计艺术》计算机科学理论与技术的经典巨著 舞蹈链（Dancing Links) KMP 算法的“K” LR解析理论（LR parsing theory）、克努斯-莫里斯-普拉特模式（Knuth-Moris-Pratt pattern）等 \u0026hellip;   高老爷子的个人主页 https://www-cs-faculty.stanford.edu/~knuth/\n 另外出名的几位 LISP 语言， α-β 搜索：约翰·麦卡锡 John McCarthy\n“汉明距离”和“汉明重量”： 理查德·卫斯里·汉明 Richard Hamming 美国计算机协会（ACM）的创立人之一\n快速排序算法：东尼·霍尔 C. Antony R. Hoare 霍尔逻辑\n堆排序算法和 Floyd-Warshall 算法： 罗伯特·弗洛伊德 Robert W. Floyd 前后断言法的创始人，的创始人之一，FPL语言发明者之一，FPL 用来编写计算机语言的语法分析程序。\ndiffie-hellman密钥交换算法 惠特菲尔德·迪菲 Whitfield Diffie 马丁·赫尔曼 Martin Hellman 非对称加密的开创者\nRSA加密算法：罗纳德·李维斯特 Ronald L. Rivest 阿迪·萨莫尔 Adi Shamir 伦纳德·阿德曼 Leonard M. Adleman\n万维网 蒂姆·伯纳斯·李 Tim Berners-Lee 在 1989 年发明了万维网，1991 年，他做出第一个图形界面网页浏览器，1994 年，他确定了超链接的标准。\nTCP/IP 协议 文特·瑟夫 Vinton G. Cerf 罗伯特·卡恩 Robert E. Kahn 罗伯特·卡恩发明了 TCP 协议，并与文特·瑟夫一起发明了 IP 协议，这两个协议成为全世界因特网传输资料所用的最重要的技术。\n面向对象编程 奥利-约翰·达尔 Ole-Johan Dahl 克利斯登·奈加特 Kristen Nygaard 开发了最早的面向对象的程序设计语言 SIMULA-I 和 SIMULA-67，首次引入了面向对象程序设计语言的基本概念。\n算法+数据结构=程序： 尼古拉斯·沃斯 Niklaus Wirth 还是Pascal 之父\nBNF 范式：彼得·诺尔 Peter Naur ALGOL 60 语言\n关系型数据库：埃德加·科德 Edgar F. Codd\n其他（摘自维基百科）  仅仅大致整理，不严谨\n 艾伦·凯 Alan Kay Smalltalk 被公认为历史上第二个面向对象的程序设计语言，和第一个真正的集成开发环境。\n约翰·巴克斯 John Backus 他提出了BNF（用来定义形式语言语法的记号法），发明函数式编程这个概念及实践该概念的计划生育语言，被誉为“Fortran 语言之父”。\n肯尼斯·艾佛森 Kenneth E. Iverson 建立了 APL 语言。\n芭芭拉·利斯科夫 Barbara Liskov 领导了多个重要项目，包括第一个支持数据抽象的面向对象编程语言 CLU 的设计与实现，第一个支持分布式程序实现的高级语言 Argus，面向对象数据库系统Thor，还有最近的Byzantine分布式容错系统。 其中，CLU 语言对现代主流语言如 C++/Java/Python/Ruby/C# 都有比较深远的影响。而她从这些实际项目中提炼出来的数据抽象思想，已经成为软件工程中最重要的精髓之一。\n 查理士·巴赫曼 Charles W. Bachman 主持设计与开发了最早的网状数据库管理系统IDS，积极推动与促成了数据库标准的制定\n詹姆斯·尼古拉·格雷 James Gray 在事务处理技术上的创造性思维和开拓性工作\n迈克尔·斯通布雷克 Michael Stonebraker 在关系数据库管理系统（RDBMS）和数据仓库（DWH）的创建、开发和改进方面的基础工作而闻名于世。\n 查尔斯·萨克尔 Charles Thacker 帮助设计、制造第一款现代 PC\n约翰·科克 John Cocke 主持了一个 801 计算机项目。对编译器的代码生成技术进行了深入研究，提出了一系列优化方法。\n伊凡·苏泽兰 Ivan Sutherland 计算机图形学之父和虚拟现实之父\n威廉·卡亨 William Morton Kahan 主持设计与开发了 8087 芯片，成功地实现了高速、高效的浮点运算部件。\n费尔南多·考巴脱 Fernando J. Corbató 研制了世界上第一个分时系统 CTSS\n道格拉斯·恩格尔巴特 Douglas Engelbart 鼠标之父，人机交互的先锋，开发了超文本系统、网络计算机，以及图形用户界面的先驱；并致力于倡导运用计算机和网络，来协同解决世界上日益增长的紧急而又复杂的问题。\n弗雷德里克·布鲁克斯 Frederick P. Brooks,Jr. 主持与领导了被称为人类从原子能时代进入信息时代的标志的 IBM/360 系列计算机的开发工作\n 艾伦·纽厄尔 Allen Newell 赫伯特·西蒙 Herbert A. Simon 给“物理符号系统” 下了定义，提出了“物理符号系统假说”，成为人工智能中影响最大的符号主义学派的创始人和代表人物。\n爱德华·费根鲍姆 Edward Feigenbaum 拉吉·瑞迪 Raj Reddy 证明了实现智能行为的主要手段在于知识，在多数实际情况下是特定领域的知识，从而最早倡导了\u0026quot;知识工程\u0026rdquo;，并使知识工程成为人工智能领域中取得实际成果最丰富、影响也最大的一个分支。\n犹大·伯尔 Judea Pearl 提出概率推理与因果关系推理的演算模式，是人工智能领域基础性的贡献。\n莱斯利·瓦伦特 Leslie Valiant 在机器学习、计算复杂度理论、并行和分散计算等领域都有突出贡献\n 史提芬·古克 Stephen A. Cook 因为其论文开启了 NP 完备性的研究。\n理查德·卡普 Richard M. Karp 一就是对计算复杂性理论中的术语进行了规范和统一。 其二是提出了“多项式时间多一归约”，有时直接把它叫做“卡普归约”。\n约翰·霍普克罗夫特 John Hopcroft 将计算机科学萌芽阶段的零散结果总结为具有整体性的系统知识，提出用渐近分析作为衡量算法性能的主要指标，成为当今计算机科学的一大支柱。\n尤里斯·哈特马尼斯 Juris Hartmanis 理查德·斯特恩斯 Richard E. Stearns 对“香农公式”开展了深入的研究，其结果就是那篇著名的论文“论算法的计算复杂性”，这篇论文开辟了计算机科学的一个新的研究领域，即“计算复杂性”，并奠定了它的理论基础。\n曼纽尔·布卢姆 Manuel Blum 发表了论文《递归序列的计算复杂性》，论文中首次使用了“计算复杂性” 这一术语，由此开辟了计算机科学中的一个新领域。\n 迈克尔·拉宾 Michael O. Rabin 达纳·斯科特 Dana S. Scott 共同发表了“有限自动机与其判定性问题”的论文，提出了非确定自动机的观点\n罗宾·米尔纳 Robin Milner 提出了形式化逻辑系统的数学模型，实现了他称之为LCF的一个系统——“可计算函数的逻辑”。另一方面的贡献是关于并发计算（concurrent computing）和并行计算（parallel computing）。\n巴特勒·兰普森 Butler W. Lampson 解决计算机文件系统和分布式系统的技术问题上有许多突出的贡献。例如提出“原子事务”(atomic transaction)的概念、提出采用“三明治式的提交协议”(sandwich commit protocol)提高系统可靠性的方案等等。\n阿米尔·伯努利 Amir Pnueli 在计算机科学中引入时序逻辑的开创性的研究工作，和其在编程语言和系统验证方面的突出贡献。\n法兰西斯·艾伦 Frances E. Allen 致力于研究并行计算机的编译问题\n爱德蒙·克拉克 Edmund M. Clarke 艾伦·爱默生 Allen Emerson 约瑟夫·斯发基斯 Joseph Sifakis 模型检查理论基础\n莎菲·戈德瓦塞尔 Shafi Goldwasser 希尔维奥·米卡利 Silvio Micali 共同开创了可证明安全性领域的先河，奠定了现代密码学理论的数学基础。\n莱斯利·兰伯特 Leslie Lamport 发表的论文《分布式系统内的时间、时钟事件顺序》; 为“并发系统的规范与验证”研究贡献了核心原理。\n","date":"2021-04-12","permalink":"https://wineee.github.io/post/turing_award/","tags":["Turing Award"],"title":"整理一下图灵奖得主们都干了什么"},{"content":"通过 man sem_init 可以查看具体文档。 或者使用： https://man7.org/linux/man-pages/man3/sem_init.3.html\nsem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。pshared 参数指明信号量是由进程内共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享。value 参数指定的初始值。\nsem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的。\nsem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。\n交替打印FooBar  我们提供一个类：\nclass FooBar { public void foo() { for (int i = 0; i \u0026lt; n; i++) { print(\u0026ldquo;foo\u0026rdquo;); } }\npublic void bar() { for (int i = 0; i \u0026lt; n; i++) { print(\u0026ldquo;bar\u0026rdquo;); } } } 两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。\n请设计修改程序，以确保 \u0026ldquo;foobar\u0026rdquo; 被输出 n 次。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/print-foobar-alternately 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n #include \u0026lt;semaphore.h\u0026gt; class FooBar { private: int n; sem_t sem_a, sem_b; public: FooBar(int n) { this-\u0026gt;n = n; sem_init(\u0026amp;sem_a, 0, 0); sem_init(\u0026amp;sem_b, 0, 0); sem_post(\u0026amp;sem_a); } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { sem_wait(\u0026amp;sem_a); // printFoo() outputs \u0026quot;foo\u0026quot;. Do not change or remove this line. printFoo(); sem_post(\u0026amp;sem_b); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { sem_wait(\u0026amp;sem_b); // printBar() outputs \u0026quot;bar\u0026quot;. Do not change or remove this line. printBar(); sem_post(\u0026amp;sem_a); } } };  按序打印  我们提供了一个类：\npublic class Foo { public void first() { print(\u0026ldquo;first\u0026rdquo;); } public void second() { print(\u0026ldquo;second\u0026rdquo;); } public void third() { print(\u0026ldquo;third\u0026rdquo;); } } 三个不同的线程 A、B、C 将会共用一个 Foo 实例。\n一个将会调用 first() 方法 一个将会调用 second() 方法 还有一个将会调用 third() 方法 请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/print-in-order 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n #include \u0026lt;semaphore.h\u0026gt; class Foo { sem_t sem_a, sem_b; public: int a,b; Foo() { sem_init(\u0026amp;sem_a, 0, 0); sem_init(\u0026amp;sem_b, 0, 0); } void first(function\u0026lt;void()\u0026gt; printFirst) { // printFirst() outputs \u0026quot;first\u0026quot;. Do not change or remove this line. printFirst(); sem_post(\u0026amp;sem_a); } void second(function\u0026lt;void()\u0026gt; printSecond) { sem_wait(\u0026amp;sem_a); // printSecond() outputs \u0026quot;second\u0026quot;. Do not change or remove this line. printSecond(); sem_post(\u0026amp;sem_b); } void third(function\u0026lt;void()\u0026gt; printThird) { sem_wait(\u0026amp;sem_b); // printThird() outputs \u0026quot;third\u0026quot;. Do not change or remove this line. printThird(); } };  打印零与奇偶数  假设有这么一个类：\nclass ZeroEvenOdd { public ZeroEvenOdd(int n) { \u0026hellip; } // 构造函数 public void zero(printNumber) { \u0026hellip; } // 仅打印出 0 public void even(printNumber) { \u0026hellip; } // 仅打印出 偶数 public void odd(printNumber) { \u0026hellip; } // 仅打印出 奇数 } 相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：\n线程 A 将调用 zero()，它只输出 0 。 线程 B 将调用 even()，它只输出偶数。 线程 C 将调用 odd()，它只输出奇数。 每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506\u0026hellip; ，其中序列的长度必须为 2n。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/print-zero-even-odd 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n #include \u0026lt;semaphore.h\u0026gt; class ZeroEvenOdd { private: int n; sem_t sem_zero, sem_odd, sem_even; public: ZeroEvenOdd(int n) { this-\u0026gt;n = n; sem_init(\u0026amp;sem_zero, 0, 1); //初始化一个0 sem_init(\u0026amp;sem_odd, 0, 0); sem_init(\u0026amp;sem_even, 0, 0); } // printNumber(x) outputs \u0026quot;x\u0026quot;, where x is an integer. void zero(function\u0026lt;void(int)\u0026gt; printNumber) { for(int i = 1; i \u0026lt;= n; i++) { sem_wait(\u0026amp;sem_zero); printNumber(0); if (i \u0026amp; 1) sem_post(\u0026amp;sem_odd); else sem_post(\u0026amp;sem_even); } } void even(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 1; i \u0026lt;= n/2; i++) { sem_wait(\u0026amp;sem_even); printNumber(i*2); sem_post(\u0026amp;sem_zero); } } void odd(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 1; i \u0026lt;= n-n/2; i++) { sem_wait(\u0026amp;sem_odd); printNumber((i-1)*2+1); sem_post(\u0026amp;sem_zero); } } };  1195. 交替打印字符串  难度中等47收藏分享切换为英文接收动态反馈\n编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：\n如果这个数字可以被 3 整除，输出 \u0026quot;fizz\u0026quot;。 如果这个数字可以被 5 整除，输出 \u0026quot;buzz\u0026quot;。 如果这个数字可以同时被 3 和 5 整除，输出 \u0026quot;fizzbuzz\u0026quot;。  例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。\n假设有这么一个类：\nclass FizzBuzz { public FizzBuzz(int n) { \u0026hellip; } // constructor public void fizz(printFizz) { \u0026hellip; } // only output \u0026ldquo;fizz\u0026rdquo; public void buzz(printBuzz) { \u0026hellip; } // only output \u0026ldquo;buzz\u0026rdquo; public void fizzbuzz(printFizzBuzz) { \u0026hellip; } // only output \u0026ldquo;fizzbuzz\u0026rdquo; public void number(printNumber) { \u0026hellip; } // only output the numbers }\n请你实现一个有四个线程的多线程版 FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：\n线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。 线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。 线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。 线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。  提示：\n本题已经提供了打印字符串的相关方法，如 printFizz() 等，具体方法名请参考答题模板中的注释部分。  来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fizz-buzz-multithreaded 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 这是个假并行，所以now不需要加锁\n#include \u0026lt;semaphore.h\u0026gt; class FizzBuzz { private: int n, now; sem_t sem_fizz; sem_t sem_buzz; sem_t sem_fizz_buzz; sem_t sem_num; public: FizzBuzz(int n) { this-\u0026gt;n = n; this-\u0026gt;now = 1; sem_init(\u0026amp;sem_fizz, 0, 0); sem_init(\u0026amp;sem_buzz, 0, 0); sem_init(\u0026amp;sem_fizz_buzz, 0, 0); sem_init(\u0026amp;sem_num, 0, 1); } void next() { now++; if (now == n+1) { sem_post(\u0026amp;sem_fizz_buzz); sem_post(\u0026amp;sem_buzz); sem_post(\u0026amp;sem_fizz); sem_post(\u0026amp;sem_num); return; } bool a = now%3==0; bool b = now%5==0; if (a \u0026amp;\u0026amp; b) sem_post(\u0026amp;sem_fizz_buzz); else if (!a \u0026amp;\u0026amp; b) sem_post(\u0026amp;sem_buzz); else if (a \u0026amp;\u0026amp; !b) sem_post(\u0026amp;sem_fizz); else sem_post(\u0026amp;sem_num); } // printFizz() outputs \u0026quot;fizz\u0026quot;. void fizz(function\u0026lt;void()\u0026gt; printFizz) { while(now \u0026lt;= n) { sem_wait(\u0026amp;sem_fizz); if(now \u0026gt; n) break; printFizz(); this-\u0026gt;next(); } } // printBuzz() outputs \u0026quot;buzz\u0026quot;. void buzz(function\u0026lt;void()\u0026gt; printBuzz) { while(now \u0026lt;= n) { sem_wait(\u0026amp;sem_buzz); if(now \u0026gt; n) break; printBuzz(); this-\u0026gt;next(); } } // printFizzBuzz() outputs \u0026quot;fizzbuzz\u0026quot;. void fizzbuzz(function\u0026lt;void()\u0026gt; printFizzBuzz) { while(now \u0026lt;= n) { sem_wait(\u0026amp;sem_fizz_buzz); if(now \u0026gt; n) break; printFizzBuzz(); this-\u0026gt;next(); } } // printNumber(x) outputs \u0026quot;x\u0026quot;, where x is an integer. void number(function\u0026lt;void(int)\u0026gt; printNumber) { while(now \u0026lt;= n) { sem_wait(\u0026amp;sem_num); if(now \u0026gt; n) break; printNumber(now); this-\u0026gt;next(); } } };  1117. H2O 生成  现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。\n存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。\n氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。\n这些线程应该三三成组突破屏障并能立即组合产生一个水分子。\n你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。\n换句话说:\n如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。 如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。 书写满足这些限制条件的氢、氧线程同步代码。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/building-h2o 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 这个参考了题解区大佬的思路，2个h,1个o是第一层限制，通过第一层限制后，如果是h,告诉半个o可以通过第二次限制，如果是o,告诉2个h可以通过第二层限制。\n#include \u0026lt;semaphore.h\u0026gt; class H2O { sem_t hjob, ojob; sem_t hlimit, olimit; public: H2O() { sem_init(\u0026amp;hjob,0,0);// H 反应条件信号量 sem_init(\u0026amp;ojob,0,0);// O 反应条件信号量 sem_init(\u0026amp;hlimit,0,2);// H线程信号量 sem_init(\u0026amp;olimit,0,1);// O线程信号量 } void hydrogen(function\u0026lt;void()\u0026gt; releaseHydrogen) { sem_wait(\u0026amp;hlimit);// 保证只有2个H线程进入执行 sem_post(\u0026amp;hjob);// 释放H原子到达信号 sem_wait(\u0026amp;ojob);// 等待O原子到达 // releaseHydrogen() outputs \u0026quot;H\u0026quot;. Do not change or remove this line. releaseHydrogen(); sem_post(\u0026amp;hlimit);// 相当于唤醒1个H线程 } void oxygen(function\u0026lt;void()\u0026gt; releaseOxygen) { sem_wait(\u0026amp;olimit);// 保证只有1个O线程进入执行 sem_post(\u0026amp;ojob);// 释放O原子到达信号，因为有2个H线程等待所以释放2个 sem_post(\u0026amp;ojob); sem_wait(\u0026amp;hjob);// 等待H原子到达，2个原因同上 sem_wait(\u0026amp;hjob); // releaseOxygen() outputs \u0026quot;O\u0026quot;. Do not change or remove this line. releaseOxygen(); sem_post(\u0026amp;olimit);// 相当于唤醒1个O线程 } };  1226. 哲学家进餐  5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）\n所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。\n假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。\n设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。\n问题描述和图片来自维基百科 wikipedia.org\n哲学家从 0 到 4 按 顺时针 编号。请实现函数 void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)：\nphilosopher 哲学家的编号。 pickLeftFork 和 pickRightFork 表示拿起左边或右边的叉子。 eat 表示吃面。 putLeftFork 和 putRightFork 表示放下左边或右边的叉子。 由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。  给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/the-dining-philosophers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 只有同时最多4人就餐，就不可能循环等待\n#include\u0026lt;semaphore.h\u0026gt; //#include\u0026lt;pthread.h\u0026gt; class DiningPhilosophers { sem_t sem, fork[5]; //pthread_mutex_t fork[5]; public: DiningPhilosophers() { sem_init(\u0026amp;sem, 0, 3); for(int i = 0; i \u0026lt; 5; i++) sem_init(\u0026amp;fork[i], 0, 1); //pthread_mutex_init(fork+i, nullptr); } void wantsToEat(int philosopher, function\u0026lt;void()\u0026gt; pickLeftFork, function\u0026lt;void()\u0026gt; pickRightFork, function\u0026lt;void()\u0026gt; eat, function\u0026lt;void()\u0026gt; putLeftFork, function\u0026lt;void()\u0026gt; putRightFork) { int right=philosopher; int left=(right+1)%5; sem_wait(\u0026amp;sem); //pthread_mutex_lock(fork+left); //pthread_mutex_lock(fork+right); sem_wait(\u0026amp;fork[left]); sem_wait(\u0026amp;fork[right]); pickLeftFork(); pickRightFork(); eat(); putLeftFork(); putRightFork(); sem_post(\u0026amp;fork[left]); sem_post(\u0026amp;fork[right]); //pthread_mutex_unlock(fork+left); //pthread_mutex_unlock(fork+right); sem_post(\u0026amp;sem); } }; ","date":"2021-04-09","permalink":"https://wineee.github.io/post/leetcode_cpp_sem/","tags":["c++","leetcode","多线程"],"title":"使用c++解决leetcode多线程题题目（之一）semaphore"},{"content":"回想起来，我是因为对 goroutine 有兴趣而去了解 Go 的，因为 finger tree 而想学 Haskell，结果坑留了半年了（另一个坑留了快3年，Monad 还没弄明白），今天有时间先填上一个再说。\ngoroutine，Go 语言的协程，是一种比线程更轻量的存在，一个cpu可以支持上万的协程。Go 可以通过 goroutine 支持并发。\nGo使用的是并发模型中的 CSP 模型，Communicating Sequential Processes，译为通信顺序进程、七周七并发第六章内容，这本书继续留坑有空再看。\ngo 在函数调用前使用 go 语句可以开启一个新的 goroutine。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026quot;world\u0026quot;) say(\u0026quot;hello\u0026quot;) }  可以看到输出hello，world交替出现，程序不再是串行执行了。\nearn_goroutine (main*) » go run a.go hello world hello world hello world world hello hello  如果say(\u0026ldquo;hello\u0026rdquo;)前面也加上go呢？\nfunc main() { go say(\u0026quot;world\u0026quot;) go say(\u0026quot;hello\u0026quot;) }  结果程序什么都不会输出！因为main函数执行完了程序就会退出，不会等所有 goroutine 退出。\n解决方法就是在 main 函数结尾 sleep 到所有 goroutine 执行完毕。\n然而 sleep 多长时间合适，就不太好确定了。 而 sync.WaitGroup 可以解决这个问题，Add 有几个 goroutine 要等待， goroutine 完成后调用 Done，Wait 进行等待直到所有 Add 的 goroutine Done 了。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; \u0026quot;sync\u0026quot; ) func main() { var wg sync.WaitGroup; wg.Add(2) go func() { say(\u0026quot;world\u0026quot;) wg.Done() }() go func() { say(\u0026quot;hello\u0026quot;) wg.Done() }() wg.Wait() } func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } }  channel 通道（channel）是用来传递数据的一个数据结构，CSP模型的精髓。\n通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 \u0026lt;- 用于指定通道的方向, 默认则为双向通道\n使用chan关键字声明一个 channel。\n发送和接收消息是阻塞的，如果没人接收，发送方会阻塞在那里，反之同理。\n// 将数组分成两半求和的程序 package main import \u0026quot;fmt\u0026quot; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum } func main() { s := []int{1, 2, 3, 4, 5, 6} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x,y := \u0026lt;-c, \u0026lt;-c fmt.Println(x, y, x+y) }  通过 close(c) 可以关闭 channel, c\u0026lt;- 的第二个参数表示 channel 的开闭。\nfor { message,open := \u0026lt;-c if (!open) break }  也可以用 range\nfor message := range c { }  通道缓冲区 如果没有缓冲区，可能造成发送消息溢出，导致接收方永远收不到溢出的信息，一直阻塞，如下例\npackage main import \u0026quot;fmt\u0026quot; func main() { ch := make(chan int) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) }  运行结果\n learn_goroutine (main*) » go run c.go fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]: main.main() /home/rew/CodeDrafts/learn_goroutine/c.go:12 +0x59 exit status 2\n 我们可以通过 make 的第二个参数指定缓冲区大小：\nch := make(chan int, 100)  带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\nfunc main() { // 定义了一个可以存储整数类型的带缓冲通道 缓冲区大小为2 ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) }  注意，如果缓冲区不够大，依然会溢出，\nselect select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。\nselect 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { c1 := make(chan string) c2 := make(chan string) go func() { for { c1 \u0026lt;- \u0026quot;Hello\u0026quot; time.Sleep(10 * time.Millisecond) } } () go func() { for { c2 \u0026lt;- \u0026quot;World\u0026quot; time.Sleep(100 * time.Millisecond) } } () for { fmt.Println(\u0026lt;- c1) fmt.Println(\u0026lt;- c2) } }  在上例中，\u0026ldquo;Hello\u0026rdquo;，\u0026ldquo;World\u0026quot;交替输出，但是，明显\u0026quot;World\u0026quot;发送频率慢的多，拖了进度 下面，使用 select\nvar a1, a2 string for { select { case a1 = \u0026lt;-c1: fmt.Println(a1) case a2 = \u0026lt;-c2: fmt.Println(a2) } }  输出变为\n World Hello Hello Hello Hello Hello Hello Hello\n 不会再被慢的一方拖累了。\n参考教程 Golang高并发教程+实战 bilibili\n菜鸟教程的 GO\n","date":"2021-04-03","permalink":"https://wineee.github.io/post/learn_goroutine/","tags":["go","goroutine","并发"],"title":"goroutine 的学习之旅"},{"content":"linux   oh-my-zsh\t漂亮好用的 shell\n  alacritty\t终端模拟器\n  htop\t交互式的进程浏览器，可以用来替换Linux下的top命令\n  ranger\t终端文件管理器\n  ncdu/filelight\t查看磁盘目录占用空间\n  wps/Liberoffice\t办公软件，Liberoffice Draw可以画流程图\n    v2ray+Qv2ray\t魔法上网\n  Typora\tMarkdow编辑器\n  emace\t高度可扩展的文本编辑器\n  Vs Code\t微软诚意之作，最方便的编辑器之一\n  Okular\tpdf阅读器\n  网易云音乐\tflatpak版中文输入没问题 electron-netease-cloud-music\n  火焰截图\t之前用deepin截图，但是dtk跨平台不太好\n  kvm/qemu\t虚拟机\n  IDEA\t我不喜欢java，但idea真的顶\n  Qt Creator\tQt官方的集成开发环境\n  Vivaldi\t超级可控与可配置的浏览器 备胎\n  firefox\t备胎 主用浏览器\n  vlc\t多媒体播放器\n  kdenlive\t开源的视频非线编辑软件\n  obs\t录屏/直播\n  windnws  7-zip 高效简洁的压缩软件 snipaste 截图 wallpaper engineer 动态壁纸 Everthing 文件搜索工具 Seer 一个可以通过空格键来预览文件的工具 CCleaner 清理垃圾 火绒 杀毒治流氓 utools 让你效率倍增的快速启动软件 / 小工具合集 (插件功能扩展), 也有linux版  Android oppo r17 pro  YouTube\t视频 Telegram NekogramX\t聊天，传文件 天翼云盘\t备份文件 Surfboard\t魔法上网，之前用老王 WakeUp课程表\t简洁的课程表 酷安\t基佬交流中心 bililbilil\t二次元 微软To Do\t任务管理，跨平台 系统自带便签 重要日子（酷安）\t纪念日软件 贴吧lite\t第三方百度贴吧客户端 Share\t第三方微博客户端 es文件浏览器\t功能多，广告也多 twitter\t社交，微博客 via 夸克\t浏览器，via更轻量，夸克操作比较顺 白描\tCR文字识别、翻译与文件扫描软件 知乎\t分享你刚编的故事 八戒助手/唐僧取经\t跳过广告和b站烦人的未成年弹窗 cimoc\t漫画综合平台 PixEz\tp站第三方客户端，不用fq既可以看p站 kde connect\t连电脑，传文件 tim\t代替qq 网易云音乐\t到点了，网抑云  华为m6  rotation\t辅助控制屏幕旋转 Termux\t高级的终端模拟器，平板的大屏+键盘与 Termux 更搭配哦 Andronix\tLinux模拟器，配合 Termux Coursea\t上网课，内容质量高 星尘浏览器HD 最适合平板的浏览器 Kiwi Browser\t支持扩展的浏览器 WPS\t适配了平板，挺好的  海信A5  微信读书墨水屏版\t微信少有的良心产品，资源很多 绿色守护/炼妖壶/权限狗\t优化耗电，权限管理  浏览器扩展  darkreader\t暗黑界面 Ghelper\t免费上谷歌 AdGuard\t拦截广告 vimium 类 vim 快捷键 Infinity 新标签页 (Pro) 划词翻译 ampermonkey\t运行各种脚本 ","date":"2021-02-12","permalink":"https://wineee.github.io/post/my_softworks/","tags":["软件推荐"],"title":"我的全平台软件清单"},{"content":"1.准备蓝桥杯需要做什么，有哪些需要学习的算法？ 熟悉比赛环境 比赛使用的编辑环境，c/c++ 组使用的是 dev-c++ , python 组使用 IDLE , java 组使用 Eclipse，建议平时练习多使用对应的编辑器，如果不熟悉编译环境，在比赛时可能会带来不必要的麻烦，尤其是 python 组的 IDLE 非常简陋，由俭入奢易，由奢入俭难。\n喜讯：官方通知第十二届蓝桥杯 c/c++ 组增加了 CodeBlocks 20.03 编程环境，支持 C++ 98 和 C++11， 终于可以用上 c++ 的新特性了。\n写竞赛风格的代码 大学的课程大都是偏向使用工程风格的代码，重视可读性，写竞赛风格的代码可能会受到批评。但在蓝桥杯中，使用工程风格只会浪费时间，还可能增加出错的概率。\n变量名命名的问题，可以参考黄学长的这篇博客：http://hzwer.com/9160.html，总体来说风格比较自由。平时也可以积累一些常见算法的简洁写法，如下面的辗转相除法代码就很经典。短，在竞赛中意味着节省时间，同时更不容易出错。\nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }  数据结构也没必要像课上那样进行封装，遵从简单实用的原则，比如栈\nint st[MAX],top = 0; // 定义 st[top++] = a; // a入栈 b = st[--top]; // 出栈  建议尽量不用指针，用指针动态分配速度慢，而且空指针处理不好可以出现运行时崩溃。竞赛中数据范围是确定的，没必要动态分配内存。\n对数据范围要敏感 同样的题面，不同的数据范围，将是2个难度完全不同的题，数据范围不只是告诉你数组开多大，还可以大致推算算法的时间复杂度，比如n\u0026lt;=10，应该是阶乘级别的算法，比如全排列的暴力枚举；n\u0026lt;=1000, 可能是$O(n^3)$ 的算法，可能是动态规划，递推等等；n\u0026lt;=50000，可能是$O(n \\log(n))$ 的算法，比如线段树，分治之类；n\u0026lt;=1e9, 说不定是$O(\\log(n))$ 的，如二分等等。这些推测不一定准确，但可以提示题解的一些信息。\n程序的空间复杂度通常是电灯泡，不用担心，管够。但有些题目还是要关心关心的，这里给个例题：给你一个元素个数是10000的无序数列，求中位数，怎么做？如果加上内存限制连10000个元素的数组都装不下，只能开5000个元素的数组，怎么做？是不是解题方法完全不一样了。如果竞赛中内存超出限制会导致直接0分。当空间不充裕时，可以用sizeof()先看看用了多少内存，防止超出题目要求。\n2147483247，这个数你熟悉吗？它是 int 可以表示的最大数，再大记得开 long long。\n推荐一些算法 官方其实是有竞赛大纲的：https://upload.lanqiao.cn/file/20180207/1517983424205832.pdf\n不过内容不太具体，下面给出一些个人见解：\n数据结构\n 基础数据结构：数组，栈，队列，链表，树，图，堆 中等数据结构：并查集，Trie树，hash表，线段树，二叉搜索树，单调栈，单调队列  算法\n  暴力穷举，搜索算法（dfs，bfs，回溯，迭代加深搜索，双向搜索，记忆化搜索，最优性剪枝 ，可行性剪枝 ）\n  动态规划（背包问题，区间dp，树形dp，状压 dp， 数位dp，单调队列 / 单调栈优化，矩阵快速幂优化等等）\n  排序（桶排序，归并排序，快速排序等等）\n  前缀和，差分：常用的小技巧。\n  模拟：模拟就是用计算机来模拟题目中要求的操作，主要考验代码能力。\n  二分法，倍增法：二分法，也称折半搜索，必须会。\n  贪心：局部最优到达全局最优，比较常用。对不会做的题可以试试用贪心骗分。\n  分治，递归：非常重要的算法。\n  高精度：随着python的流行，高精度算法的题目越来越少见，不过蓝桥杯py和c++组是分开的，不排除。\n  字符串：字符串hash有必要学一下。此外很多字符串的题其实找规律，动态规划，排列组合，贪心等等，感觉kmp的题不是很多。\n  二进制处理技巧，位运算\n  图论\n 最短路（堆优化Dijkstra算法， SPFA算法，Floyd算法） 最小生成树（Kruskal算法，Prim算法） 二分图 判定（黑白染色） 二分图的最大匹配（匈牙利算法） 有向无环图，拓扑排序，DAG 上的动态规划 欧拉图和哈密顿图的性质  数学：\n 快速幂 辗转相除法，扩展欧几里得算法 组合数学 ，博弈论，概率论，解析几何的基础知识 数论：素数筛（欧拉筛），乘法逆元，费马小定理，素数判定，质因数分解，求欧拉函数等等  想参加省赛不需要把上面的知识全学完，毕竟蓝桥杯是比较全民向的竞赛，真正必要的算法：贪心，分治，dp，搜索，数论只要gcd，再多刷刷题，省二没问题。想要省一的话，还是有必要多学一点的，上面提到的算法最好都掌握。\n一定要了解STL 这条建议只针对c/c++组，选手只要学习c语言就可以参加，不需要完成大学的c++课程，面向对象的思想在竞赛中基本没什么用处，但是，如果不会用 c++ 的 STL 的话，那就实在太可惜了。C++ STL 也就是 C++ 标准模板库，它实现了常用的数据结构和算法。STL 学习难度非常低，只要调库就行，可以节省你大量时间和精力。\n比如竞赛题中经常需要对一组数据进行排序，有了 STL ，你只需要在加入algorithm头文件中，直接调用 sort(a, a+n); 即可完成对数组a从小到大的排序，非常方便。完全不需要自己写排序算法，而且时间复杂度是 $O(n \\log n)$ 的，即使没学过快速排序的人，也可以进行高效的排序了。\n下面的列举了常用的 STL ：\n string 字符串 vector 动态数组 set / multiset 集合 map / multimap / unordered_map 关联容器 queue 队列 priority_queue 优先队列（堆） algorithm 算法库，常用的有sort，偶尔用的lower_bound/upper_bound(二分), nth_element(找第n大)，next_permutation(排列组合中求下一个序列)等 bitset 二进制相关，偶尔用  多练习使用 SLT 的效益是非常高的，比如使用邻接表建图时\nvector\u0026lt;int\u0026gt; g[MAX_NODE]; // 定义 g[a].push_back(b); g[b].push_back(a); // 添加一条a与b的无向边 for (int i = 0; i \u0026lt; g[a].size(); i++) cout \u0026lt;\u0026lt; g[a][i]; // 遍历与a相连的点  是不是非常简洁，既节约时间，代码逻辑也清晰，在竞赛中经常使用。另一种竞赛中常用来表示图的数据结构是链式前项星，大家在网上找题解时应该会经常看到这种写法。\n2.国赛和省赛有什么区别？   蓝桥杯省赛一等奖可以获得报名国赛的资格。\n  省赛，国赛的报名费都是300元。\n  蓝桥杯的国赛无论报名流程，还是参赛过程，都和省赛基本一致。\n  我认为大家没必要太纠结省赛和国赛的不同，国赛的吸引力不算太大，有不少省一的同学没有继续参加国赛。但是，我推荐尽量参加一下，毕竟300块钱还不算太离谱。\n3.国赛需要学习哪些算法？ 准备国赛不如准备 ACM ，有对算法非常感兴趣的同学，一点要尝试一下 ACM 。\n如果仅仅是为了蓝桥杯的国赛的话，其实没有必要学习太多新的算法，多刷题就行了。重点还是分治，搜索，动态规划，这些算法难度上限很高，甚至无上限，比方说动态规划，有的状态非常难确定，很难看出是dp题，有的状态转移需要写单调栈/队列，线段树甚至平衡树等数据结构来加速，有的从前往后行不通，从后往前就可以，我还见过一个动态规划的状态转移是另一个动态规划问题。这个阶段，应该从题目中积累经验，而不是按标签刷题了。\n我没找到蓝桥杯真题的数据，题目和野生的题解网上可以搜到，但没数据就没法判断自己写的对不对，这点就要批评@蓝桥杯了。蓝桥杯官网的评测系统，题目也是不全的。刷题的OJ，我后面会推荐一些。\n下面补充一下 ACM 可能用到的算法，为什么不是蓝桥杯，因为没的可讲啊。\n数据结构\n 树状数组，ST表（倍增法），分块思想（块状数组，树分块，块状链表），树链抛分。 平衡树：STL的set/map封装了平衡树，但是有些情况还是需要手写平衡树，比如动态第k大的问题，STL封装太死，只能手写，常见的有 Treap，Splay，替罪羊树，AVL等 ，其中Splay比较特殊，它是唯二可以维护序列的平衡树，经典例题：文艺平衡树。吊炸天的数据结构Link-Cut-Tree也需要Splay为基础） 可持久化数据结构，最重要的是可持久化线段树，特殊用法：主席树 树套树, K-D Tree等等。 字符串相关：字符串匹配算法kmp，AC自动机，后缀三姐妹（后缀数组的倍增法构建可以学学，hihocoder有相关资料，后缀树，后缀自动机，我也不会hahaha），回文串（马拉车，回文树）  算法\n 搜索算法（启发式搜索A* ， IDA* ， Dancing Links） 动态规划（空间优化：滚动数组，插头 DP，斜率优化，四边形不等式优化等等，经典算法：悬线法） 树分治（点分治，边分治），cdp分治/整体二分，莫队算法。 LCA问题（欧拉序+ST表/倍增法/tarjan算法/树链抛分）  图论\n tarjan 求强连通分量 + 缩点 + 割点 / 桥。 网络流 最大流算法dinic和isap中至少会一个，费用流算法推荐 spfa费用流，网络流关键在于建模，经典题目有\u0026quot;网络流24题\u0026rdquo;。 最小树形图，次小生成树，k短路，差分约束，Prufer序列等。  数学\n BSGS，卢卡斯定理，中国剩余定理，莫比乌斯反演（扩展：杜教筛，min25筛）等数论知识。 牛顿迭代法，自适应辛普森公式等恶心的高数。 维护凸包，旋转卡壳，半平面交等恶心的几何题。 康托展开，卡特兰数，容斥原理，置换群（Burnside 引理，Pólya 定理）等组合数学知识。 高斯消元，线性基，线性规划（单纯型） 生成函数，原根，快速傅立叶变换（fft），快速数论变换（ntt）  4.除了蓝桥杯，还有哪些算法比赛值得参加？ PAT 计算机程序设计能力考试（Programming Ability Test，简称 PAT ） 旨在通过统一组织的在线考试及自动评测方法客观地评判考生的算法设计与程序设计实现能力， 科学的评价计算机程序设计人才， 为企业选拔人才提供参考标准。\nPAT值得参加的是甲级和顶级，甲级难度应该小于蓝桥杯，需要英文阅读能力。对于考研生来说，PAT成绩可能在部分学校会给予免机试的优待。\nACM-ICPC 国际大学生程序设计竞赛（英文全称：International Collegiate Programming Contest（简称 ICPC））是由国际计算机协会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。\nACM与蓝桥杯的主要区别有\n 难度不同，ACM 获奖难度和题目难度都高于蓝桥杯，考察范围更广。 参与方式不同，ACM 是团体赛，一队3人一台电脑，讲求分工合作，蓝桥杯是个人赛。 赛制不同，ACM题目可以提交多次，如果代码不通过会有罚时，可以修改后继续提交，直到通过。蓝桥杯只有一次判题的机会。ACM没有部分分，必须通过所有数据才能得分，蓝桥杯则有部分分。  ACM 是程序设计方面的顶级赛事，含金量高，需要付出的努力也更大。\nCCPC 中国大学生程序设计竞赛（China Collegiate Programming Contest， CCPC），与ACM类似。\n其他 可以了解一下百度之星，计蒜之道之类的网络赛，有难度，主要可以锻炼能力。\n5.有哪些推荐的OJ平台？ vjudge vjudge不是真正的OJ，它通过爬取其他 OJ 的题目，让我们可以直接在 VJ 上查找并提交各种 OJ 的题目，然后通过它在其他OJ的账号，提交代码并把结果反馈给我们。因此VJ上的题目非常全，有很多ACM选手也在使用。\nVJ上有一个kuangbin 带你飞专题，适合作为专项训练使用。\nluogu 洛谷的最大特点是辛勤的管理员了，同类型的codevs，tyvj，甚至bzoj都凉凉了，luogu能保持活跃离不开运营团队。目前，luogu题目很多，难度从入门到入土一应俱全，题解区由于审核的存在保持着较高的质量。题目有比较准确的难度分级，可以根据算法标签找题。\nleetcode leetcode的定位是帮助程序员准备算法面试，与竞赛类的OJ相比，题目考察的知识点比较单一，整体上题目难度偏低，适合入门或者养老使用，如果想提高的话不建议只刷这个。\n其他 hdu,poj 杭电和北大的OJ，可以说是大学ACM题库中最为知名的两个。\ncodeforces 俄罗斯的竞赛网站，有着高质量的题目和高密度的比赛，唯一可惜的是由于时间差，大部分比赛要熬到凌晨1点。\nhihocoder 有大量模板题，有些题自带教程，刷模板的好去处。\nLibreOJ 一个有自由精神的开源OJ，你可以查看任意人提交的代码，下载任意题目数据。\n上面5个OJ的题目都可以在vjudge上提交。\n6.比赛的时候有哪些注意事项？ 时间，一定要注意时间，写完一定要先提交。国赛时，我最后写的是一个填空题，写完想验算一下，当时一直注意电脑右下角的时间，准备最后一分钟提交，结果打开提交页面，居然已经结束了。后来才明白赛场提前3分钟开始的，提前3分钟结束，没想到居然还有这种情况。比赛系统不讲武德，我大意了，没有闪，以后好自为之，好好反思。\n合理分配时间，题目量大，不要一直抓住一个题不放，不保证题目难度是递增的，不会的可以先跳过，至少每个题都看一遍，把能拿的分先拿了。最好抽出时间检查，会做的题却写错并不少见，这些错误往往简单复查一下就可以发现，当最后有可做的题没写完时，就需要取舍了，有时候放弃做新题去检查，反而收益更高。\n","date":"2021-01-22","permalink":"https://wineee.github.io/post/lanqiaobie/","tags":["ACM","蓝桥杯"],"title":"关于蓝桥杯等算法竞赛的经验总结"},{"content":"前言 高中时，作为OIer经常需要看别人的题解博客，那时候luogu还没流行，大家都在tyvj，vijos上刷题，看题解还要找 csdn，博客园，和一些大佬（比如hzwer）的个人博客。慢慢的，就萌生出了自己写博客的想法，一开始，我在蚂蚁笔记上写题解，它可以把markdown笔记分享到蚂蚁博客上，而且主题也很美观，后来它收费了，学生党没有钱（那时候我没手机，没手机号，更别说网银了）弃用了，现在我不推荐大家用了，这个项目2，3年没人维护，恐怕不靠谱。\n我还试过WordPress，用的免费主机（当然现在挂了，资料也丢了）\n以前在同学帮助下搭建了 hexo+github 的 blog，不过我嫌主题不好看万年不更新。\ncsdn 的blog因为要绑定手机号，高中没机会用，大一才开始写一些东西。\n博客园 后台太丑，不喜欢用这个写。\ngridea 这个是我去年了解的，看上去挺方便的，我没试过，感兴趣的可以看看。\nemacs 搞成的博客也不错，比如：https://evanmeek.github.io\nhugo 博客搭建 我现在用的就是 hugo， 本着不重复造轮子的原则，我只放一些参考的文章，不会详细写每个步骤。\n选择主题 在官网找一个顺眼的主题\nhttps://themes.gohugo.io/\n我的要求主要是简洁，选用了hugo主题\nhttps://github.com/dsrkafuu/hugo-theme-fuji\n搭建 hugo 博客 这方面教程很多\nhttps://zhuanlan.zhihu.com/p/105021100\nHuGo博客搭建部署到GitHub Pages\n自动化部署（非必须）  方便用多台电脑是同步\n Hugo + Github Actions 实现自动化部署 如果失败，原因很可能是教程里配置版本太低了，可以参考我的配置\nhttps://github.com/wineee/HUGO_blog/tree/master/.github/workflows\n其他参考资料 Hugo中常用命令及参数\nHuGo博客处理数学公式方案\n工具：Typora 编写文章， Picgo 上传图片。\n","date":"2021-01-15","permalink":"https://wineee.github.io/post/hugo_blog/","tags":["hugo"],"title":"搭建个人博客记录(github action+hugo)"},{"content":"第一章 引言 什么是被动攻击和主动攻击,各有几种类型?   被动攻击：也称窃听，以获取信息为目的。 仅攻击信息的保密性，不影响正常的网络通信，不对消息作任何修改 搭线窃听、对文件或程序非法复制、木马、对资源的非授权使用 被动攻击又分为两类：获取消息的内容和业务流分析\n 获取消息的内容：通过破译密文等手段直接获取机密信息的内容 业务流分析：敌手虽然可能无法从截获的消息中获取内容，但却有可能获知消息的长度，格式，通信双方的位置和身份，通信次数。在商业环境，用户隐私，以及军网中这些消息可能是敏感的。    主动攻击：对数据流进行篡改或产生假的数据流 可分为3类：\n 中断：对系统可用性进行攻击 破坏计算机硬件，网络，或文件管理系统。如DoS，病毒等 篡改：对完整性进行攻击 修改文件中的数据(数据修改后存储)，替换某一程序使其执行不同功能 修改网络中传送消息的内容等，比如中间节点对转发的图象进行了压缩 伪造：对真实性进行攻击 在网络中插入伪造的消息冒充消息发送者，在文件中插入伪造记录等    分别是对信息系统的什么性质进行的攻击? 恶意程序的分类  根据是否需要宿主程序及是否可以自我复制可分为病毒、蠕虫、特洛伊木马、逻辑炸弹等  安全业务分为哪五种?各自含义  保密业务,防止被动攻击  机密性就是保护信息（数据）不泄露或不泄露给那些未授权掌握这一信息的实体，如防止消息内容泄漏，被窃听。 在信息系统安全中需要区分两类机密性服务：  数据机密性服务：使攻击者想要从某个数据项中推出敏感信息是十分困难的 业务流机密性服务：使攻击者想要通过观察通信系统的业务流来获得敏感信息是十分困难的如防止敌手进行业务流分析，以获得信源，信宿，次数，消息长度等     认证业务  鉴别是最基本的安全服务，是对付假冒攻击的有效方法，以保障通信的真实性，鉴别可以分为对等实体鉴别和数据源鉴别 (1) 对等实体鉴别， 即身份认证，如主机和终端，主机和服务器等。保障身份的真实性，通信双方都相信对方是真实的，这种服务可以是单向的，也可以是双向的，可以带有有效期检验，也可以不带。 (2) 数据源鉴别，保障通信连接的真实性，通信连接不能被第三方介入，以假冒其中的一方而进行非授权的传输或接受。单向通信：认证业务功能是使接收者相信消息确实是由它自己所声称的那个信源发出的。   完整性业务  完整性服务用于对抗数据在存储、传输等处理过程中受到的非授权修改 ，如用于消息流：保证所接收的消息未经复制、插入、篡改、重排、或重放。即保证接收的消息和发送的消息完全一样 和机密性一样可以实现不同粒度的完整性保护 还能用于一定程度上对已经毁坏的数据进行恢复   不可否认性业务  用于防止通信双方中的某一方对所传送的消息的否认，保护通信实体免遭来自其他合法实体的威胁 一个消息发出后，接收者能够证明消息的真实来源，发送者能够证明接收者确已接收了该消息   访问控制  访问控制用于防止资源的未授权使用，控制的实现方式是认证，检查用户是否有对某一资源的访问权    信息安全的基本模型?信息系统的保护模型? 密码体制从原理上可分为哪两大类?含义  单钥体制  传统密码体制所用的加密密钥和解密密钥相同k1＝k2，称为单钥密码体制，也称为对称密码体制   双钥密码体制  加密密钥和解密密钥不相同，称为双钥密码体制，也称为非对称密码体制或公钥体制    单钥密码体制对明文加密的两种方式?  流密码  明文消息按字符或比特逐位加密 需要一个至少和明文一样长的密钥流   分组密码  将明文消息分组(含有多个字符)，逐组进行加密 用同一个密钥分别对不同的分组按照一定的运行模式加密    对密码体制的攻击的4种类型   唯密文攻击\n  已知明文攻击\n  选择明文攻击\n  选择密文攻击\n     攻击类型 攻击者掌握的内容     惟密文攻击 加密算法，截获的部分密文   已知明文攻击 加密算法，截获的部分密文，一个或多个明密文对   选择明文攻击 加密算法，截获的部分密文，自己选择的明文消息及由密钥产生的相应密文   选择密文攻击 加密算法，截获的部分密文，自己选择的密文消息及相应的被解密的明文      第二章 流密码 密码和流密码的区别? 同步流密码的概念 分组密码与流密码的区别在于有无记忆性 ,流密码的滚动密钥 $z_0=f(k,\\theta_0)$ , 由函数 $f$ , 密钥 $k$, 和指定的初态 $\\theta_0$ 完全确定. 此后,由输入加密器的明文可能影响加密器中内部记忆部件的存储状态,因而 $\\theta_i (i\u0026gt;0)$ 可能依赖于 $k, \\theta_0, x_0, x_1,\u0026hellip;,x_{i-1}$ 等参数.\n根据加密器中的记忆元件的储存状态 $\\theta_i$ 是否依赖于输入的明文字符,流密码可以进一步分成同布和自同步两种. $\\theta_i$ 独立于明文字符的叫同步流密码,否则叫自同步流密码.\n有限状态自动机的基本原理 有限状态自动机是具有离散输入和输出（输入集和输出集均有限）的一种数学模型，由以下3部分组成：\n密钥流生成器的分解和常见的密钥流生成器 LFSR输出序列和周期的计算 LFSR的特征多项式及其性质  记$2^n-1$个非零序列的全体为G(p(x))。 定理2-2 p(x)|q(x)的充要条件是G(p(x))属于G(q(x)) 说明可用n级LFSR产生的序列，也可用级数更多的LFSR来产生 若序列{ai}的特征多项式p(x)定义在GF(2)上，p是p(x)的周期，则{ai}的周期r|p。 说明n级LFSR输出序列的周期r不依赖于初始条件，而依赖于特征多项式p(x)。 初始状态对序列的周期有一定的影响 所有这些m序列之间是相互移位的关系，本质上是同一个序列  m序列密码的条件和破译  n级LFSR产生的序列有最大周期的必要条件是其特征多项式为不可约的 注意：只要有一条序列为m序列，则所有非0序列都是m序列 该定理的逆不成立，即LFSR的特征多项式为不可约多项式时，其输出序列不一定是m序列。 若n次不可约多项式p(x)的阶为$2^n-1$，则称p(x)是n次本原多项式 {ai}为m序列的充要条件是p(x)为本原多项式。 对于任意的正整数n，至少存在一个n次本原多项式 m序列虽然具有最大的周期，然而因它是线性序列而极其不安全，只要知道连续的2n个bit的序列就可以完全破译了。即可以求出m序列产生器特征多项式的n个系数    第三章 分组密码体制  与流密码相比无记忆性。在相同密钥下分别对长为n的输入明文组实施相同变换，所以只需研究对任一组明文数字的变换规则。 分组密码实质上是字长为n的数字序列的代换密码 分组密码的优缺点  适合软硬件实现，软件实现及标准化优于流密码 没有有效的数学工具，安全性一般无法证明    Shannon提出的设计密码系统的两个基本方法   扩散和混淆(diffusion and confusion)是由Shannon提出的设计密码系统的两个基本准则，目的是抗击敌手对密码系统的统计分析\n  扩散性：所设计的密码应使得\n (1) 密钥的每一个比特影响密文的每一个比特，以防止对密钥进行逐段破译； (2) 明文的每一个比特影响密文的每一个比特，以便最充分地隐蔽明文。即将明文的统计特性散布到密文中去，从而使明文和密文之间的统计关系变得尽可能复杂    混淆性：\n 是使密文和密钥之间的统计关系变得尽可能复杂，以使敌手无法得到密钥。 即使敌手能得到密文的一些统计关系，由于密钥和密文之间的统计关系复杂化，敌手也无法得到密钥。 使用复杂的代换算法可以得到预期的混淆效果 简单的线性代换函数得到的混淆效果则不够理想    Feistel网络的加解密结构 DES加密算法的基本原理和过程 分组密码的四种运行模式和用途    模式 描述 用途     电码本(ECB)模式 每个明文组独立地以同一密钥加密 传送短数据(如一个加密密钥)   密码分组链接(CBC)模式 加密算法的输入是当前明文组与前一密文组的异或 传送数据分组；认证   密码反馈(CFB)模式 每次只处理输入的j比特，将上一次的密文作加密算法的输入以产生伪随机输出，该输出再与当前明文异或以产生当前密文 传送数据流；认证   输出反馈(OFB)模式 与CFB类似不同之处是本次加密算法的输入为前一次加密算法的输出 有扰信道上(如卫星通信)传送数据流   计数器(CTR)模式 对计数器依次用k加密后与明文异或 适合并行，可随机访问    IDEA算法的基本原理和过程  每轮开始时有一个变换，该变换的输入是4个子段和4个子密钥 变换中的运算是两个乘法和两个加法 输出的4个子段经异或运算形成了两个16比特的子段作为MA结构的输入 MA结构也有两个输入的子密钥，输出是两个16比特的子段 最后，变换的4个输出子段和MA结构的两个输出子段经过异或运算产生这一轮的4个输出子段  AES算法的原理和过程  Rijndael的轮函数由4个不同的计算部件组成，分别是： 字节代换（ByteSub）、行移位（ShiftRow） 列混合（MixColumn）、密钥加（AddRoundKey） 轮函数的伪C代码如下： Round (State, RoundKey) { ByteSub (State); ShiftRow (State); MixColumn (State); AddRoundKey (State, RoundKey) } 结尾轮的轮函数与前面各轮不同，将MixColumn这一步去掉。其伪C代码如下： FinalRound (State, RoundKey) { ByteSub (State); ShiftRow (State); AddRoundKey (State, RoundKey) } “InvShiftRow”与“InvByteSub”两个计算部件可以交换顺序 Rijndael密码的解密算法为顺序完成以下操作：初始的密钥加；(Nr-1)轮迭代；一个结尾轮。其中解密算法的轮函数为 InvRound (State, RoundKey) { InvByteSub (State); InvShiftRow (State); InvMixColumn (State); AddRoundKey (State, RoundKey) } 解密算法的结尾轮为 InvFinalRound (State, RoundKey) { InvByteSub (State); InvShiftRow (State); AddRoundKey (State, RoundKey) }  第四章 公钥密码 公钥密码体制的加密和认证原理   公钥密码算法基本工具不再是代换和置换，而是数学函数\n  以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、认证等都有着深刻的意义。\n  公钥密码算法的最大特点是采用两个相关密钥将加密和解密能力分开\n  一个密钥是公开的，称为公开密钥，简称公开钥，用于加密、验证签名，可以被任何人知道\n  另一个密钥是为用户专用，因而是保密的，只能被消息的接收者或签名者知道，称为秘密密钥，简称秘密钥，用于解密、产生签名\n  因此公钥密码体制也称为双钥密码体制\n  公钥体制的加密过程: ① 密钥的产生 ：要求接收消息的端系统，产生一对用来加密和解密的密钥$PK_B$和$SK_B$，如图中的接收者B，其中$PK_B$是公开钥，$SK_B$是秘密钥。因此，公钥可以发布给其他人 ② 公开钥的分发 ：B将加密密钥$(PK_B)$予以公开。另一密钥则被保密$(SK_B)$ ③ 加密 ：A要想向B发送消息m，则使用B的公开钥加密m，表示为$ c=E_{PK_B}[m] $其中c是密文，E是加密算法 ④ 解密 ：B收到密文c后，用自己的秘密钥$SK_B$解密，即$m=D_{SK_B}[c]$，其中D是解密算法。因为只有B知道$SK_B$，所以其他人都无法对c解密。\n  公钥体制的认证过程\n公钥加密不仅能用于加、解密，还能用于对发方A发送的消息m提供认证 用户A用自己的秘密钥$SK_A$对m加密，表示为$c=E_{SK_A}[m]$ 将c发往B。B用A的公开钥$PK_A$对c解密，表示为$m=D_{PK_A}[c]$ 因为从m得到c是经过A的秘密钥$SK_A$加密，**只有A才能做到**。因此c可当做A对m的**数字签字**。 任何人只要得不到A的秘密钥$SK_A$就不能篡改m，所以以上过程获得了对**消息来源和消息完整性的认证**，也实现了**对身份的认证**。\n  RSA加密体制的原理和计算  它既可用于加密、又可用于数字签字。 RSA算法的安全性是基于数论中大整数分解的困难性(但可能达不到大数分解的困难强度) 1 密钥的产生 ① 选两个保密的大素数p和q ② 计算n=p×q，$\\phi(n)=(p-1)(q-1)$，其中$\\phi(n)$是n的欧拉函数值 ③ 选一整数e，满足$1\u0026lt;e\u0026lt; \\phi(n)$，且$gcd(\\phi(n),e)=1$ ④ 计算$d$，满足$ d * e = 1 \\mod \\phi(n)$, 即d是e在模$\\phi(n)$下的乘法逆元，因e与$\\phi(n)$互素，模$\\phi(n)$的乘法逆元一定存在 ⑤ 以{e,n}为公开钥,{d,p,q}为秘密钥 秘密钥也可记为d，或{d, n}，如果是系统负责产生密钥，则用户可能不知道p,q 2 加密 加密时首先将明文比特串分组，使得每个分组对应的十进制数小于n，即分组长度小于$log_2 n$。 然后对每个明文分组m，作加密运算： $c≡m^e \\mod n$ 3 解密 对密文分组的解密运算为： $m≡c^d \\mod n$ RSA的加密很快，因为加密指数e一般选择得很小 解密指数d很大，需要计算模 300digits (or 1024bits) 的乘法，计算机不能直接处理这么大的数，计算速度很慢，需要考虑其它技术，加速RSA的实现 如果知道p和q，可采用中国剩余定理CRT： CRT 对RSA解密算法生成两个解密方程（利用$M=C^d \\mod N$，$N=p * q$）, 即：$M_1 = M \\mod p = (C \\mod p)^{d \\mod (p-1)} \\mod p$ $M_2 = M \\mod q = (C \\mod q)^{d \\mod (q-1)} \\mod q$ 解方程 $M = M_1 \\mod p$ $M = M_2 \\mod q $ 具有唯一解（利用CRT ）： $M = M_1 * q * (q^{－1} \\mod p) + M_2 * p * (p^{－1} \\mod q) \\mod N$ 不考虑CRT的计算代价，改进的算法的解密速度是原来的4倍 若考虑CRT的计算代价，改进后的算法解密速度是原来的3倍多 RSA密钥的产生 需考虑两个大素数p、q的选取，以及e的选取和d的计算 n(=p*q) 是公开的，为了防止敌手通过穷搜索发现p、q，这两个素数应足够大，且具有好的随机性 (1) 如何有效地寻找大素数 一般是先随机选取一个大的奇数（例如用伪随机数产生器）， 然后用素性检验算法检验这一奇数是否为素数，如果不是则选取另一大奇数，重复这一过程，直到找到素数为止 素性检验算法通常都是概率性的，常用Miller-Rabin概率检测算法实现，只有在产生新密钥时才需执行这一工作 (2) 如何选取满足$gcd(\\phi(n),e)=1$的e，并计算满足$d * e≡1 \\mod \\phi(n)$的d,这一问题可由推广的Euclid算法完成  背包密码体制的原理和计算   设$A=(a_1,a_2,…,a_n)$是由 n 个不同的正整数构成的 n 元组，s 是另一已知的正整数。背包问题就是从 A 中求出所有的 $a_i$，使其和等于 s。其中 A称为背包向量，s 是背包的容积。 例如,A=(43, 129, 215, 473, 903, 302, 561, 1165, 697, 1523)，s=3231。 由于 3231=129+473+903+561+1165 所以从 A 中找出的满足要求的数有129、473、903、561、1165 原则上讲，通过检查 A 的所有子集，总可找出问题的解（若有解的话） 本例 A 的子集共有$2^{10}=1024$个（包括空集）。 然而如果 A 中元素个数 n 很大，子集个数 $2^n$将非常大。 如A中有300个元素，A的子集有$2^{300}$。寻找满足要求的 A 的子集没有比穷搜索更好的算法，因此背包问题( Knapsack)是NPC问题\n  由背包问题构造公钥密码体制同样是要构造一个(陷门)单向函数f 将 $x (1≤x≤2 * n-1)$ 写成长为 n 的二元表示, f(x) 定义为 A 中所有$a_i$的和，其中 x 的二元表示的第 i 位为1，即 $f(1)=f(0…001)=a_n;$\n$f(2)=f(0…010)=a_{n-1};$\n$ f(3)=f(0…011)=a_{n-1}+a_n;$\n$f(2n-1)=f(1…111)=a_1+a_2+…+a_n$\n使用向量乘(内积)，有$f(x)=A·B_x$，其中$B_x$是x二元表示的列向量。 上例中f(364) =f(0101101100)= 129+473+903+561+1165 = 3231 显然，已知 x 很容易求 f(x)，但已知 f(x) 求 x 就是要解背包问题。 为使接收方能够解密，就需找出单向函数 f(x) 的陷门。为此需引入一种特殊类型的背包向量。\n  定义背包向量$A=(a_1,a_2,…,a_n)$称为超递增的，如果 $a_j \u0026gt; a_1+a_2+\u0026hellip;+a_{j-1}, 其中j=1,2,3\u0026hellip;n$\n  超递增背包向量对应的背包问题很容易通过以下算法求解。 已知 s 为背包容积，对A从右向左检查每一元素，以确定是否在解中。 若 $s≥a_n$，则 $a_n$ 在解中，令 $x_n=1$； 若 $s \u0026lt; a_n$，则 $a_n$ 不在解中，令$x_n=0$。 下面令\ns = s if s\u0026lt;a[i] else s-a[i]  对$a_{n-1}$重复上述过程，一直下去，直到检查出$a_1$是否在解中。 检查结束后得 $x=(x_1x_2…x_n)$，$B_x=(x_1x_2…x_n)^T$\n  1 密钥产生 选一个超递增背包向量 $ A=(a_1,a_2,…,a_n) $ 用模乘对 A 进行伪装，模乘的模数 k 和乘数 t 皆取为常量，满足 ，gcd(t, k) = 1，即 t 在模 k 下有乘法逆元。 设 $b_i≡t·a_i \\mod k$, i=1,2,…,n，得一新的背包向量$ B = (b_1,b_2,…,b_n)$，记为 $B≡t · A \\mod k$ 用户以 B 作为自己的公开钥，A, t, k为私钥\n  2.加密 对明文分组 $x=(x_1x_2…x_n)$的加密运算为$c=f(x)=B·B_x \\mod k$\n  3. 解密 首先由$s≡t^{-1}c \\mod k$，求出 s 作为超递增背包向量 A 的容积， 再由超递增背包向量A解背包问题即得$x=(x_1x_2…x_n)$。\n  过了两年该体制即被破译\n  Rabin加密体制的原理和计算   Rabin密码体制已被证明对该体制的破译等价于对大整数的分解\n  RSA中选取的公开钥e满足$1\u0026lt;e\u0026lt;\\phi(n)$，且$gcd(e,\\phi(n))=1$。Rabin密码体制则取e=2\n  1 密钥的产生: 随机选择两个大素数p、q，满足$p≡q≡3 \\mod 4$，Blum数，即这两个素数形式为$4 * k+3$；计算$n = p * q$。以 n 作为公开钥，p、q 作为秘密钥。\n  2. 加密:\n$c≡m^2 \\mod n$ 其中 m 是明文分组，c 是对应的密文分组。\n  3. 解密: 解密就是求c模n的平方根，即解$x^2≡c \\mod n$，因此，Rabin体制也被称为基于环上二次剩余困难性构造，由中国剩余定理知解该方程等价于解方程组\n    由于p≡q≡3 mod 4，方程组的解可容易地求出，其中每个方程都有两个解，即$ x≡\\pm m_1 \\mod p$， $x≡\\pm m_2 \\mod q$， 经过组合可得4个同余方程组\n  由中国剩余定理可解出每一方程组的解，共有4个，即每一密文对应的明文不惟一。为了有效地确定明文,可在 m 中加入某些信息,如发送者的身份号、接收者的身份号、日期、时间等。\n  Rabin密码在选择密文攻击CCA下是不安全的\n  ElGamal密码体制  密钥产生 选择一个大的素数 p ；选择 g ，1 \u0026lt; g \u0026lt; p；选择 x，1 \u0026lt; x \u0026lt; p-1； 计算$y = g^x \\mod p$，公钥是(p, g, y)，私钥是x 加密 设欲加密明文消息M，0 \u0026lt; M \u0026lt; p 随机选一整数 k , 满足 gcd(k, p－1) = 1 计算对$C1≡g^k \\mod p,C2≡y^kM \\mod p$，密文为C = C1||C2 (级联) 解密 $M=C_2/C_1x \\mod p$ 这是因为$C_2/C_1^x \\mod p＝y^kM/g^{kx} \\mod p＝y^kM/y^k \\mod p＝M \\mod p $ 特点：密文由明文和所选随机数k来定，因而是一种概率加密体制代价是使数据扩展一倍  Diffie-Hellman 密钥交换   算法的唯一目的是使得两个用户能够安全地交换密钥，得到一个共享地会话密钥，算法本身不能用于加、解密\n  算法的安全性基于求离散对数的困难性\n  假设 p 是大素数， g 是 p 的本原根，p 和 g 作为公开元素，协议如下： ① 用户Alice选择随机数x，计算 $a=g^x \\mod p$，保密x，发送a给Bob ② 用户Bob选择随机数y，计算 $b=g^y \\mod p$，保密y，发送 b 给Alice ③ Bob和Alice各自计算 $k=b^x \\mod p$ 和 $k=a^y \\mod p$, 从而得到共享密钥 k 这是因为$k=b^x mod p=(g^y)^x \\mod p=(g^x)^y \\mod p=a^y \\mod p$\n  ECC加密体制的原理和优点   与基于有限域上离散对数问题的公钥体制（如Diffie-Hellman密钥交换和ElGamal密码体制）相比，椭圆曲线密码体制有如下优点:\n  1: 安全性高\n攻击有限域上的离散对数问题可以用指数积分法，对椭圆曲线上的离散对数问题并不有效。 目前攻击椭圆曲线上的离散对数问题的方法只有适合攻击任何循环群上离散对数问题的大步小步法\n  2: 密钥量小\n由攻击两者的算法复杂度可知，在实现相同的安全性能条件下，椭圆曲线密码体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小\n  3: 灵活性好\n有限域GF(q)一定的情况下，其上的循环群（即GF(q)-{0}）就定了 GF(q)上的椭圆曲线可以通过改变曲线参数，得到不同的曲线，形成不同的循环群。因此，椭圆曲线具有丰富的群结构和多选择性 可在保持和RSA/DSA体制同样安全性能的前提下大大缩短密钥长度(目前160比特足以保证安全性)，因而在密码领域有着广阔的应用前景\n  ECC上的Elgamal密码体制   椭圆曲线并非椭圆，之所以称为椭圆曲线是因为它的曲线方程与计算椭圆周长的方程类似。一般来讲，椭圆曲线的曲线方程是以下形式的三次方程： $y^2+axy+by=x^3+cx^2+dx+e$ 其中a，b，c，d，e是满足某些简单条件的实数。定义中包括一个称为无穷点的元素，记为O。\n  椭圆曲线关于x轴对称。\n  3个点位于同一直线上，那么它们的和为O\n  O为加法单位元，即对椭圆曲线上任一点P，有 P+O=P\n  设P1=(x,y)是椭圆曲线上的一点（如图所示），它的加法逆元定义为P2=－P1=(x, -y)\n  设Q和R是椭圆曲线上x坐标不同的两点，Q+R的定义如下： 画一条通过Q、R的直线与椭圆曲线交于P1\n由Q+R+P1=O 得 Q+R=-P1\n  点Q的倍数定义如下： 在Q点做椭圆曲线的一条切线，设切线与椭圆曲线交于点S，定义2Q=Q+Q=-S。类似地可定义3Q=Q+Q+Q+，…，\n  以上定义的加法具有加法运算的一般性质，如交换律、结合律等\n         (0，1) (0，22) (1，7) (1，16) (3，10) (3，13) (4，0) (5，4) (5，19)     (6，4) (6，19) (7，11) (7，12) (9，7) (9，16) (11，3) (11，20) (12，4)   (12，19) (13，7) (13，16) (17，3) (17，20) (18，3) (18，20) (19，5) (19，18)        第五章 密钥分配与密钥管理  密钥的种类与使用周期 密钥加密密钥(key encrypting key):在传输会话密钥时，用来加密会话密钥的密钥称为密钥加密密钥，也称次主密钥(submaster key)或二级密钥(secondary key) 主机主密钥(host master key):对密钥加密密钥进行加密的密钥称为主机主密钥。它一般保存于网络中心、主节点、主处理机中，受到严格的物理保护。一般在密钥分配中心以及终端系统中主密钥都是物理上安全的。如果主密钥泄露了，则相应的会话密钥也将泄露，如果把主密钥当作会话密钥注入加密设备，那么其安全性则降低 两个用户（主机、进程、应用程序）在用单钥密码体制进行保密通信时，首先必须有一个共享的秘密密钥，为防止攻击者得到密钥，还必须时常更新密钥。因此，密码系统的强度也依赖于密钥分配技术 两个用户A和B获得共享密钥的方法有以下4种： ① 密钥由A选取并通过物理手段发送给B ② 密钥由第三方选取并通过物理手段发送给A和B ③ 如果A、B事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方 ④ 如果A和B与第三方C分别有一保密信道，则C为A、B选取密钥后，分别在两个保密信道上发送给A、B 第1和第2种方法称为人工发送 在通信网中，若只有个别用户想进行保密通信，密钥的人工发送还是可行的。然而如果所有用户都要求支持加密服务，则任意一对希望通信的用户都必须有一共享密钥。如果有n个用户，则密钥数目为n(n-1)/2。因此当n很大时，密钥分配的代价非常大，密钥的人工发送是不可行的 系统的主密钥或初始密钥一般物理手段发送 对于第3种方法 攻击者一旦获得一个密钥就可获取以后所有的密钥；而且用这种方法对所有用户分配初始密钥时，代价仍然很大。  在单钥密钥体制下有中心的密钥分配和无中心的密钥分配   第4种方法比较常用 其中的第三方通常是一个负责为用户分配密钥的密钥分配中心(KDC)。 这时每一用户必须和密钥分配中心有一个共享密钥，称为主密钥。（可通过第二种方法） 通过主密钥分配给一对用户的密钥ks称为会话密钥，用于这一对用户之间的保密通信。 通信完成后，会话密钥即被销毁。如上所述，如果用户数为n，则会话密钥数为n(n-1)/2。但主密钥数却只需n个，所以主密钥可通过物理手段发送。\n  网络中如果用户数目非常多且分布的地域非常广，则需要使用多个KDC的分层结构\n  分层结构可减小主密钥的分布，因为大多数主密钥是在本地KDC和本地用户之间共享。\n  分层结构还可将虚假KDC的危害限制到一个局部区域，但会降低信任度\n  在基于对称密钥和公钥的密钥管理中都存在分层控制问题\n   普遍采用的方式是KDC密钥管理体系\n主密钥的分配采用物理的方式，由KDC负责对用户的密钥进行管理，基于第2种方式在用户和KDC之间建立共享主密钥，要求所有用户必需信任KDC，且需要对KDC进行严格的保护。如果系统规模庞大，还要使用分层控制的方式\n用KDC为用户分配密钥时，要求所有用户都信任KDC，同时还要求对KDC加以保护。如果密钥的分配是无中心的，则不必有以上两个要求\n  无中心的密钥分配时，两个用户A和B建立会话密钥需经过以下3步： ① A向B发出建立会话密钥的请求和一个一次性随机数$N_1$ ② B用与A共享的主密钥$MK_m$对应答的消息加密，并发送给A 应答的消息中有B选取的会话密钥$K_S$、B的身份$ID_B、f(N_1)$和另一个一次性随机数$N_2$ ③ A使用新建立的会话密钥$K_S$对$f(N_2)$加密后返回给B\n  单钥体制中密钥控制技术的两种技术  密钥标签 控制矢量  公钥体制下公钥的4种分配方法   主要有两个方面的问题需要解决\n 公钥密码体制所用的公开密钥的管理和分配 如何用公钥体制来分配单钥密码体制所需的密钥，这是公钥加密的主要用途之一    公钥的分配方法主要有以下4种\n  公开发布\n公开发布指用户将自己的公钥发给每一其他用户，或向某一团体广播\n缺点很明显，即任何人都可伪造这种公开发布\n  公用目录表 公用目录表指一个公用的公钥动态目录表 公用目录表的建立、维护以及公钥的分发由某个可信的实体或组织承担，称这个实体或组织为公用目录的管理员 该方案有以下一些组成部分： ① 管理员为每个用户都在目录表中建立一个目录，目录中有两个数据项: 用户名；用户的公开钥 ② 每一用户都亲自或以某种安全的认证通信在管理者那里为自己的公开钥注册，用户能够直接操作目录表 ③ 用户如果由于自己的公钥用过的次数太多或由于与公钥相关的秘密钥已被泄露，可随时用新密钥替换现有的密钥\n④ 管理员定期公布或定期更新目录表 ⑤ 用户可通过电子手段访问目录表，这时从管理员到用户必须有安全的认证通信\n安全性高于公开发布，但仍易受攻击 如果敌手成功地获取管理员的秘密钥（密码），就可伪造一个公钥目录表，以后既可假冒任一用户又能监听发往任一用户的消息。(因为公钥目录表的保护不是十分安全) 公用目录表还易受到敌手的窜扰(因为用户亲自操作目录表，可能会破坏目录表) 用户需要登录到公钥目录表中自己查找收方的公钥\n  公钥管理机构\n为防止用户自行对公钥目录表操作所带来的安全威胁，假定有一个公钥管理机构来为各用户建立、维护动态的公钥目录 即由用户提出请求，公钥管理机构通过认证信道将用户所需要查找的公钥传给用户 该认证信道主要基于公钥管理机构的签名\n 其中消息②中 管理机构对A的应答消息用自己的秘密钥SKAU加密签名，消息还包含了A的请求，抗篡改、抗重放；包括最初的时戳，抗重放 一次性随机数N1和N2，用于保障通信的新鲜性，使A和B能够完成握手  公钥管理机构方式的优缺点 每次密钥的获得由公钥管理机构查询并认证发送，用户不需要查表，提高了安全性 但公钥管理机构必须一直在线，由于每一用户要想和他人联系都需求助于管理机构，所以管理机构有可能成为系统的瓶颈 由管理机构维护的公钥目录表也易被敌手通过一定方式窜扰\n  公钥证书\n  用户通过公钥证书来互相交换自己的公钥而无须与公钥管理机构联系\n  公钥证书由证书管理机构CA(certificate authority)为用户建立\n  证书中的数据项有与该用户的秘密钥相匹配的公开钥及用户的身份和时戳等，所有的数据项经CA用自己的秘密钥签字后就形成证书\n  公钥基础设施PKI(public key infrastructure)是指结合公钥密码体制建立的提供信息安全服务的基础设施\n  PKI技术提供以下四种安全服务 (1) 数据的保密性：保证在开放的网络上传输的机密信息不泄露给非法接受者 (2) 数据的完整性：保证在开放的网络上传输的信息不被中途篡改及重复发送； (3) 身份认证：对通信方的身份、数据源的身份进行认证，以保证身份的真实性； (4) 不可否认性：通信各方不能否认自己在网络上的行为\n  一个PKI系统由认证中心、证书库、Web安全通信平台，RA注册审核机构等组成，其中认证中心CA和证书库是PKI的核心\n  认证中心CA的体系结构\n        用公钥加密分配单钥体制密钥   简单分配\n    A、B现在可以用单钥加密算法以KS作为会话密钥进行保密通信，通信完成后，又都将KS销毁 这种分配法尽管简单，但却由于A、B双方在通信前和完成通信后，都未存储密钥，因此，密钥泄露的危险性为最小，且可防止双方的通信被敌手监听, 每次公私钥由发方临时产生 但由于公钥缺少证书管理机构认证且非物理传输容易受到主动攻击\n  具有保密性和认证性的密钥分配\n    Diffie-Hellman密钥交换  上面已经提到  线性同余算法伪随机数生成器及其变形   随机数在密码学中的作用 相互认证中的一次性随机数，如在密钥分配中，都使用了一次性随机数防止重放攻击 会话密钥的产生，用随机数作为会话密钥 公钥密码算法中密钥的产生，用随机数作为公钥密码算法中的密钥，或以随机数来产生公钥密码算法中的密钥\n  在随机数的各种应用中，都要求随机数序列满足两个特性 随机性和不可预测性 （1）随机性 以下两个准则常用来保障数列的随机性： ①均匀分布 数列中每个数出现的频率应相等或近似相等 ②独立性 数列中任一数都不能由其它数推出\n（2）不可预测性 在诸如相互认证和会话密钥的产生等应用中，不仅要求数列具有随机性而且要求对数列中以后的数是不可测的 对于真随机数列来说，数列中每个数都独立于其它数，因此是不可预测的 对于伪随机数来说，就需要特别注意防止敌手从数列前边的数预测出后边的数\n  最为广泛使用的伪随机数产生器是线性同余算法 线性同余算法有4个参数： 模数m (m\u0026gt;0)， 乘数a (0\u0026lt;=a\u0026lt;m)， 增量c (0\u0026lt;=c\u0026lt;m)， 初值即种子 $X_0(0\u0026lt;=X_0\u0026lt;m)$； 由以下迭代公式得到随机数数列{ $X_n$}： $X_{n＋1}＝aX_n+c \\mod m$ 如果$m，a，c，X_0$都为整数则产生的随机数序列{$ X_n$}也都是整数\n  评价线性同余算法的性能有以下3个标准： ①迭代函数应是整周期的，即数列中的数在重复之前应产生出0到m之间的所有数 ②产生的数列看上去应是随机的。因为数列是确定性产生的，因此不可能是随机的，但可用各种统计检测来评价数列具有多少随机性 ③迭代函数能有效地利用32位运算实现\n  a, c和m的取值是产生高质量随机数的关键，通过精心选取a, c和m，可使以上3个标准得以满足 为使随机数数列的周期尽可能大，m应尽可能大，普遍原则是选m接近等于计算机能表示的最大整数，为了方便32位运算地实现，m可取为$2^{31}-1$，这满足上述的第③条要求\n  对第①条来说，一种典型的选取方式是， m为素数、c=0、a是m的一个本原根\n  Knuth给出了使迭代函数达到整周期的充要条件\n  通常，可取$m＝2^r，a＝2^i＋1，c＝1$，其中r是一整数，i\u0026lt;r也是一整数即可满足定理条件\n  线性同余算法的强度在于如果将乘数和模数选择得好，则产生的数列和从1，2，…，m-1中随机选取的数列是不可区分的\n  线性同余算法的密码分析\n给定参数，则线性同余算法由初始值$X_0$确定 如果敌手知道正在使用线性同余算法，并知道算法的参数，则一旦获得数列中的一个数，就可得到以后的所有数 甚至如果敌手只知道正在使用线性同余算法以及产生的数列中极少一部分，就足以确定出算法的参数。假定敌手能确定$X_0，X_1，X_2，X_3$，就可通过以下方程组解出a，c和m。\n$X_1＝(aX_0+c) \\mod m$ $X_2＝(aX_1+c) \\mod m$ $X_3＝(aX_2+c) \\mod m$\n改进的方法是利用系统时钟修改随机数数列 一：每当产生N个数后，就利用当前的时钟值模m后作为种子 二：直接将当前的时钟值加到每个随机数上(模m加)\n  对线性同余算法有以下一些常用变形\n  幂形式的迭代公式为$X_{n＋1}＝(X_n)^d \\mod m，n＝1，2，…$ 其中d, m是参数，$X_0(0\u0026lt;=X_0\u0026lt;m)$是种子 根据参数的取法，幂形式又分为以下两种：\n①RSA产生器 此时参数取为RSA算法的参数，即m是两个大素数乘积，d是RSA秘密钥，满足$gcd(d, \\phi(m))=1$ ②平方产生器 取d＝2，m＝pq，而p，q模4余3的大素数\n  离散指数形式的迭代公式为$X_{n＋1}＝g^{X_n} \\mod m，n＝1，2，…$ 其中g, m是参数，$X_0(0\u0026lt;=X_0\u0026lt;m)$是种子\n  ANSI X 9.17 伪随机数生成器的原理   它是密码强度最高的伪随机数产生器之一，已在包括PGP等许多应用过程中被采纳， 产生器有3个组成部分\n  ① 输入 输入为两个64比特的伪随机数，其中$DT_i$表示当前的日期和时间，每产生一个数$R_i$后，$DT_i$都更新一次；$V_i$是产生第i个随机数时的种子，其初值可任意设定，以后每次自动更新。 ②密钥 3次3DES(EDE)加密使用 相同的两个56比特的密钥K1和K2 ③输出 为一个64比特的伪随机数 $R_i$和一个64比特的新种子$V_{i＋1}$\n    $R_i＝EDE_{K1,K2}[V_i @ EDE_{K1,K2}[DT_i]]$ $V_{i＋1}＝EDE_{K1,K2}[R_i @ EDE_{K1,K2}[DT_i]]$\n  本方案具有非常高的密码强度， 这是因为采用了112比特长的密钥和9个DES加密 同时还由于算法由两个伪随机数输入驱动， 一个是当前的日期和时间 另一个是算法上次产生的新种子\n  前向保密和后向保密性 即使某次产生的随机数$R_i$泄漏了，但由于**$R_i$又经一次EDE加密才产生新种子$V_{i＋1}$**，所以别人即使得到$R_i$也得不到$V_{i＋1}$，从而得不到新随机数$R_{i＋1}$\n  BBS(blum-blum-shub)随机比特生成器  在某些情况下，需要的是随机比特序列，而不是随机数序列，如流密码的密钥流 首先，选择两个大素数p，q，满足p≡q≡3 mod 4，令n＝p×q。再选一随机数s，使得s与n互素。然后按以下算法产生比特序列{Bi}：  BBS的安全性基于大整数分解，是密码上安全的伪随机数比特产生器 如果伪随机比特产生器能通过下一比特检验，则称之为密码上安全的伪随机比特产生器 即以伪随机比特产生器的输出序列的前k个比特作为输入，如果不存在多项式时间算法，能以大于1/2的概率预测第k+1个比特。换句话说，已知一个序列的前k个比特，不存在实际可行的算法能以大于1/2的概率预测下一比特是0还是1。  秘密分割Shamir门限方案  设秘密 s 被分成n个部分信息，每一部分信息称为一个子密钥或影子(share or shadow)，由一个参与者持有，使得： ① 由k个或多于k个参与者所持有的部分信息可重构s ② 由少于k个参与者所持有的部分信息则无法重构s 则称这种方案为(k,n)－秘密分割门限方案，k称为方案的门限值。 如果一个参与者或一组未经授权的参与者在猜测秘密s时，并不比局外人猜秘密时有优势,则称这个方案是完善的 攻击者除了试图恢复秘密外，还可能从可靠性方面进行攻击，如果他能阻止多于n-k个人参与秘密恢复，则用户的秘密就难于恢复 秘密分割应该由可信第三方执行，或者托管设备完成 Shamir门限方案基于多项式的Lagrange插值公式      第六章 消息认证和杂凑算法 消息认证码MAC的定义及三种使用方式  消息认证码MAC指消息被一密钥控制的公开函数作用后产生的、用作认证符的、固定长度的数值，也称为密码校验和 此时需要通信双方A和B共享一密钥k   ANSIX9.17数据认证算法  算法基于CBC模式的DES算法，其初始向量为零向量 需被认证的数据(消息、记录、文件或程序)被分为64比特长的分组D1，D2，…，DN， 其中最后一个分组不够64比特的话，可在其右边填充一些0，然后按图所示过程计算数据认证码 杂凑函数的定义及6种使用方式 迭代型杂凑函数的一般结构   MDS和SHA杂凑函数的基本过程, 他们之间的区别与联系  如图所示。其中函数的输入M被分为L个分组Y0,Y1,…,YL-1，每一个分组的长度为b比特，最后一个分组的长度不够的话，需对其做填充 最后一个分组中还包括整个函数输入的长度值，将使得敌手的攻击更为困难 IV = 初始值, n =散列码的长度;最后一轮输出的链接变量CVL即为最终产生的哈希值  MD5算法采用迭代型散列函数的一般结构 算法的输入为任意长的消息，分为512比特长的分组 输出为128比特的消息摘要  处理过程有以下几步： ① 对消息填充，使得其比特长在模512下为448，即填充后消息的长度为512的某一倍数减64，留出的64比特备第2步使用 步骤①是必需的，即使消息长度已满足要求，仍需填充。 填充方式是固定的，即第1位为1，其后各位皆为0 哈希码中每一个比特是所有输入比特的函数 因此获得了很好的混淆效果，从而使得不可能随机选择两个具有相同哈希值的消息 SHA-1算法描述 算法的输入为小于264比特长的任意消息，分为512比特长的分组 输出为160比特长的消息摘要。算法的框图与MD5一样，但哈希值的长度和链接变量的长度为160比特 ① 对消息填充 与MD5的步骤①完全相同。 ② 附加消息的长度 与MD5的步骤②类似，不同之处在于以big-endian方式表示填充前消息的长度  HMAC的算法框图     第七章 数字签名和密码协议 数字签名的两种产生方式   由加密算法产生数字签名\n是指将消息或消息的摘要加密后的密文作为对该消息的数字签名 其用法又根据是单钥加密还是公钥加密而有所不同\n 单钥加密，不具备抗抵赖功能 如图：基于共享密钥加解密，密文即为签名 如果加密的是消息摘要或有消息冗余，则可提供消息源认证和完整性认证  公钥加密  然而由于任何人都可使用A的公开钥解密密文，所以这种方案不提供保密性 加密的消息应该是消息摘要或有消息冗余 为提供保密性，A可用B的公开钥再一次加密\n由加密算法产生数字签名在实现上一般采用外部保密方式，即先签名后加密，反之则称为内部保密方式 外部保密方式便于解决争议，因为第3方在处理争议时，需得到明文消息及其签名 先签名后加密，可防止签名替换攻击 有时签名消息中还要包含收方的身份 这样可以抵抗假冒攻击\n  由签名算法产生数字签名\n  数字签名的两种执行方式   数字签名的执行方式有两类： 直接方式和具有仲裁的方式\n  直接方式(缺少监督的方式)\n直接方式是指数字签名的执行过程只有通信双方参与，并假定双方有共享的秘密钥或接收一方知道发方的公钥 直接方式的数字签名有一公共弱点，即方案的有效性取决于发方秘密钥的安全性(发方可以声称自己秘密钥被窃取，而否认发过的消息,发方也有秘密钥真的被偷的危险)\n  具有仲裁方式的数字签名\n具有仲裁方式的数字签名也有很多实现方案，这些方案都按以下方式运行： ①发方X对发往收方Y的消息签名后，将消息及其签名先发给仲裁者A ②A对消息及其签名验证完后，再连同一个表示已通过验证的指令一起发往收方Y 此时由于A的存在，X无法对自己发出的消息予以否认。在这种方式中，仲裁者起着重要的作用，并应取得所有用户的信任\n    RSA签名于DSS签名的不同   RSA算法既能用于加密和签名，又能用于密钥交换\n  与此不同，DSS使用的算法只能提供数字签名功能\n    RSA签名中，先对消息做hash运算，再对hash值用发方的秘密钥加密就形成了对消息的签名\n  DSS签名也先利用杂凑函数产生消息的一个杂凑值，杂凑值连同一随机数k一起作为签名函数的输入\n签名函数还需使用发送方的秘密钥SKA和供所有用户使用的一族参数，称这一族参数为全局公开钥PKG\n  DSA的算法描述和框图 保证消息实时性的两种常用方法  实现消息新鲜性有两种技术：时间戳和询问应答机制 时戳 如果A收到的消息包括一时戳，且在A看来这一时戳充分接近自己的当前时刻， A才认为收到的消息是新的并接受之。这种方案要求所有各方的时钟是同步的 询问-应答 用户A向B发出一个一次性随机数作为询问，如果收到B发来的消息（应答）也包含一正确的一次性随机数，A就认为B发来的消息是新的并接受之。 时戳法不能用于面向连接的应用过程 询问-应答方式则不适合于无连接的应用过程  相互认证与单向认证  A和B是网络的两个用户，他们想通过网络先建立安全的共享密钥再进行保密通信。A(B)如何确信自己正在和B(A)通信而不是和C通信呢？即双方的身份认证 这种通信方式为双向通信，此时的认证称为相互认证 双向认证也叫相互认证、双方认证等 类似地，对于单向通信来说，认证称为单向认证  交互式证明   交互证明系统由两方参与，分别称为 证明者(prover，简记为P)和验证者(verifier，简记为V)\n  其中P知道某一秘密（如公钥密码体制的秘密钥或一平方剩余x的平方根），P希望使V相信自己的确掌握这一秘密\n  交互证明由若干轮组成\n 在每一轮，P和V可能需根据从对方收到的消息和自己计算的某个结果向对方发送消息 比较典型的方式是在每轮V都向P发出一询问，P向V做出一应答 所有轮执行完后，V根据P是否在每一轮对自己发出的询问都能正确应答，以决定是否接受P的证明    交互证明和数学证明的区别是：\n 数学证明的证明者可自己独立地完成证明 交互证明是由P产生证明、V验证证明的有效性来实现，因此双方之间通过某种信道的通信是必需的。    交互证明系统须满足以下要求：\n① 完备性 如果P知道某一秘密，V将接受P的证明 ② 正确性 如果P能以一定的概率使V相信P的证明，则P知道相应的秘密\n  零知识证明起源于最小泄露证明\n 如果V除了知道P能证明某一事实外，不能得到其他任何信息，则称P实现了零知识证明，相应的协议称为零知识证明协议    第八章 网络加密与认证 网络加密的两种基本方式  链路加密是指每个易受攻击的链路两端都使用加密设备进行加密 端到端加密是指仅在一对用户的通信线路两端(即源节点和终端节点)进行加密  kerberos认证服务系统的详细过程   Kerberos协议是工作在应用层的认证协议\n  解决的问题：\n 在一个公开的分布式环境中，工作站上的用户希望访问分布在网络中的服务器(可能是多个)上的服务 服务器希望能够限制授权用户的访问，并能对服务请求进行鉴别 Kerberos的主要功能：认证、授权、记账与审计 Kerberos系统在一个分布式的Client/Server体系机构中采用一个或多个Kerberos服务器提供一个认证服务 Kerberos系统基于对称密钥（DES算法）构建，提供一个基于可信第三方的认证服务    X.509的认证过程  那么如果我们使用证书技术分发公钥的话具体如何做呢？ X.509协议给了我们一个非常实用的标准 X.509协议是X.500系列标准的一个组成部分。 这里X. 500系列标准定义了一种目录业务 目录实际上是维护用户信息数据库的服务器或分布式服务器集合，其中目录中的用户信息包括用户名到网络地址的映射和用户的其他属性，比如互联网中的各个网站名及其网络地址 目录的作用是存放用户的公钥证书 X. 509还定义了基于公钥证书的认证协议 目录服务器本身并不负责为用户建立公钥证书，其作用仅仅是为用户访问公钥证书提供方便 认证过程  ","date":"2020-12-04","permalink":"https://wineee.github.io/post/cryptography_review/","tags":["cryptography"],"title":"现代密码学复习总结"},{"content":"(1) nullptr 用nullptr 代替NULL,\nNULL是一个宏定义，在c和c++中的定义不同，c中NULL为（void*)0,而c++中NULL为整数0\nvoid foo(char *); void foo(int);  对于这两个函数,如果NULL定义为0的话,foo(NULL)将会出现歧义\n使用NULL的情景均可用nullptr 代替\n(2) constexpr constexpr 让用户显式的声明函数或对象构造函数在编译器为常数\nconstexpr  的函数可以使用递归，从 C++ 14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，但 C++ 11 中是不可以的\nconstexpr int two() { return 2; } int _two() { return 2; } constexpr int fib(int n) { return n == 1 || n == 2 ? 1 : fib(n-1)+fib(n-2); } int main() { int a[two()]; //int _a[_two()]; //编译出错 int b[fib(5)]; int x; cin \u0026gt;\u0026gt; x; int c[fib(x)];//错误用法，constexpr必须编译期可求 cout \u0026lt;\u0026lt; sizeof (c) / sizeof (int); return 0; }  constexpr 还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr ，那么产生的对象中的所有成员都会是constexpr ，该对象也就是constexpr 对象了，可用于各种只能使用constexpr 的场合。注意，constexpr 构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。\nstruct A { constexpr A(int xx, int yy): x(xx), y(yy) {} int x, y; }; constexpr A a(1, 2); enum {SIZE_X = a.x, SIZE_Y = a.y};  C++中的const和constexpr  (3) auto auto  的意义是使C++编译器可以在编译时推导数据类型，这样就不用每次都要声明数据类型了.\n注意 auto  不能用于函数传参以及推导数组类型\nvector\u0026lt;int\u0026gt; vec{1,2,3}; for (auto it = vec.begin(); it != vec.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026quot; \u0026quot;;//迭代器 auto n = 10;//int auto x = new auto(12); //int*  (4) decltype 有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（初始化可以用auto ）。为了满足这一需求，C++11新标准引入了decltype  类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。\nauto x = 1; auto y = 2; decltype(x+y) z = 0; // z 是一个 int 型的  C++11新标准学习：decltype关键字 (5)尾返回类型 template\u0026lt;typename T, typename U\u0026gt; auto add(T x, U y) -\u0026gt; decltype(x+y) { return x+y; }  C++ 14 开始是可以直接让普通函数具备返回值推导\ntemplate\u0026lt;typename T, typename U\u0026gt; auto add(T x, U y) { return x+y; }  (6)基于范围的 for 循环 int array[] = {1,2,3,4,5}; for(auto \u0026amp;x : array) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; x = -x; } for(auto x : array) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; }  (7)初始化列表 int a[3]{1,2,3}; //统一的初始化语法 vector\u0026lt;int\u0026gt; vetc{1,2,3}; set\u0026lt;int\u0026gt; f{1,1,2,3};  (8) 外部模板 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。\n// test1.cpp #include \u0026quot;test.h\u0026quot; template void fun\u0026lt;int\u0026gt;(int); // 显式地实例化 void test1() { fun(1); }  // test2.cpp #include \u0026quot;test.h\u0026quot; extern template void fun\u0026lt;int\u0026gt;(int); // 外部模板的声明 void test2() { fun(2); }  (9) 尖括号 \u0026ldquo;\u0026gt;\u0026rdquo; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; wow;  两个\u0026gt;相连不用加空格了。\n(10) 类型别名模板 template\u0026lt; typename T, typename U, int value\u0026gt; class SuckType { public: T a; U b; SuckType():a(value),b(value){} }; template\u0026lt; typename U\u0026gt; using NewType = SuckType\u0026lt;std::vector\u0026lt;int\u0026gt;, U, 1\u0026gt;; NewType\u0026lt;int\u0026gt; Tmp;  typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process using process = int(*)(void *); // 同上, 更加直观  (11)默认模板参数 template\u0026lt;typename T = int, typename U = int\u0026gt; auto add(T x, U y) -\u0026gt; decltype(x+y) { return x+y; }  (12)变长参数模板 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。\ntemplate\u0026lt;typename... Ts\u0026gt; class Magic;  模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：\nclass Magic\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::map\u0026lt;std::string, std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; darkMagic;  既然是任意形式，所以个数为 0 的模板参数也是可以的：class Magic\u0026lt;\u0026gt; nothing;。\n除了在模板参数中能使用 ... 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如：\ntemplate\u0026lt;typename... Args\u0026gt; void printf(const std::string \u0026amp;str, Args... args);  那么我们定义了变长的模板参数，如何对参数进行解包呢？\n首先，我们可以使用 sizeof... 来计算参数的个数，：\ntemplate\u0026lt;typename... Args\u0026gt; void magic(Args... args) { std::cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; std::endl; }  我们可以传递任意个参数给 magic 函数：\nmagic(); // 输出0 magic(1); // 输出1 magic(1, \u0026quot;\u0026quot;); // 输出2  其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：\n1. 递归模板函数\n递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的：\n#include \u0026lt;iostream\u0026gt; template\u0026lt;typename T\u0026gt; void printf(T value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T, typename... Args\u0026gt; void printf(T value, Args... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; printf(args...); } int main() { printf(1, 2, \u0026quot;123\u0026quot;, 1.1); return 0; }  2. 初始化列表展开\n递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。\n这里介绍一种使用初始化列表展开的黑魔法：\n// 编译这个代码需要开启 -std=c++14 template\u0026lt;typename T, typename... Args\u0026gt; auto print(T value, Args... args) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; return std::initializer_list\u0026lt;T\u0026gt;{([\u0026amp;] { std::cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; std::endl; }(), value)...}; } int main() { print(1, 2.1, \u0026quot;123\u0026quot;); return 0; }  在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性，而 std::initializer_list 也是 C++11 新引入的容器。\n通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。唯一不美观的地方在于如果不使用 return 编译器会给出未使用的变量作为警告。\n(13)面向对象增强 （1）委托构造 class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; int main() { Base b(2); std::cout \u0026lt;\u0026lt; b.value1 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; b.value2 \u0026lt;\u0026lt; std::endl; }  （2）继承构造 class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; class Subclass : public Base { public: using Base::Base; // 继承构造 }; int main() { Subclass s(3); std::cout \u0026lt;\u0026lt; s.value1 \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; s.value2 \u0026lt;\u0026lt; std::endl; }  （3）显式虚函数重载 C++ 11 引入了 override 和 final 这两个关键字来防止上述情形的发生。\n当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：\nstruct Base { virtual void foo(int); }; struct SubClass: Base { virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数 };  final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。\nstruct Base { virtual void foo() final; }; struct SubClass1 final: Base { }; // 合法 struct SubClass2 : SubClass1 { }; // 非法, SubClass 已 final struct SubClass3: Base { void foo(); // 非法, foo 已 final };  （6）显式禁用默认函数 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。\nclass Magic { public: Magic() = default; // 显式声明使用编译器生成的构造 Magic\u0026amp; operator=(const Magic\u0026amp;) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number); }  (14)强类型枚举 C++ 11 引入了枚举类（enumaration class），并使用 enum class 的语法进行声明：\nenum class new_enum : unsigned int { value1, value2, value3 = 100, value4 = 100 };  这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较。\n(15) Lambda 表达式 C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。 Lambda 的语法形式如下：\n[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u0026gt; 返回值类型 {函数体}  函数对象参数 标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量 (包括 Lambda 所在类 的 this)。函数对象参数有以下形式：\n 空。没有任何函数对象参数。 =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 \u0026amp;。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。 this。函数体内可以使用 Lambda 所在类中的成员变量。 a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。 \u0026amp;a。将 a 按引用进行传递。 a，\u0026amp;b。将 a 按值传递，b 按引用进行传递。 =，\u0026amp;a，\u0026amp;b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。 \u0026amp;，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。  操作符重载函数参数 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (\u0026amp;a, \u0026amp;b)) 两种方式进行传递。\nmutable 或 exception 声明 这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw (int)。\n-\u0026gt; 返回值类型 标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n函数体 标识函数的实现，这部分不能省略，但函数体可以为空。\n实例 [] (int x, int y) { return x + y; } // 隐式返回类型 [] (int\u0026amp; x) { ++x;} // 没有 return 语句 -\u0026gt; Lambda 函数的返回类型是 'void' [] () { ++global_x; } // 没有参数，仅访问某个全局变量 [] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)  Lambda参考博客\n","date":"2020-08-19","permalink":"https://wineee.github.io/post/cplusplus1x_base/","tags":["c++"],"title":"初步认识c++1x的新特性"},{"content":"题面  给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。\n  你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k \u0026gt;= 1），这样一轮之后你将得到 k * k 个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-boxes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n解题思路 用f[l][r]来表示移除区间 [l,r] 内所有的盒子能得到的最大积分，然后去探索某一种移除盒子的策略来进行状态转移,这个方法应该是大部分人的第一个想法,官方题解称之错误的思路,但实际上,它是可以做出来的,只是状态转移方程比较特殊.\n首先枚举的是[i,j]区间,对于确定的区间,如何确定f[i][j]呢,我是枚举最后一次消除的是哪个数(以后用numx代替),比如样例[1,3,2,2,2,3,4,3,1],\ni=0,j=2,[1,3]最后一个可以是1或3\ni=0,j=8,[1,3,2,2,2,3,4,3,1],最后一个可以是1,3,2或者4\n我们知道最后的消除的是谁了,那么,一个朴素的想法,$(a+b)^2\u0026gt;a^2+b^2$,把所有的合一起消掉肯定比分两波甚至更多波好,那么状态转移方程就是\n$ f[i][j] = \\sum_{(x,y)}f[x][y]+cntx^2$\n其中(x,y)是被numx分割的子序列,cntx是numx的个数\n聪明的你可能发现了有点不对劲,没错,当我信心满满的交上时,结果WA了\n我又仔细想了想,发现加入我们枚举7的时候,有一个子段XXOO,2,2,2,7,2,2,2,XXOO,我们为了7最优,却忽略了被7分开的2,我们放弃这个7去成就2全局可能更好.情况可能更复杂XXOO,2,2,2,7,3,7,4,2,2,2,XXOO,这次要放弃7,3,7,4成就2,也就是说只看7两边一样的数也不行,要看全局!\n看全局,怎么看?枚举7的时候有m个7分布在数列不同位置,如果一个个枚举7选不选(在最后一波一起消除),$2^m$太爆炸了,但是,仔细想想,这不是动态规划问题吗(没错,用动态规划维护上面的动态规划的状态转移,套娃警告)\n $g[cnt][num]$表示前cnt个numx,一共num个不参与最后一轮(且第cnt个必定不参与)消除的情况下的最优解 初值$g[0][0]=0$ 状态转移方程: $g[cnt][num] = \\max_{0\u0026lt;=per\u0026lt;cnt}(g[per][num-1]+f[posx[per]+1][posx[cnt]-1]))$,其中posx[i]表示第i个numx下标  最后,终于可以更新 $f$ 了\n$f[i][j] = max(f[i][j], g[cntx][num]+num*num)$ (1\u0026lt;=num\u0026lt;=cntx)\n$f[i][j] = max(f[i][j], g[cnt][num]+num*num+f[posx[cnt]+1][j])$ (1\u0026lt;cnt\u0026lt;cntx,1\u0026lt;=num\u0026lt;=cnt别忘了考虑最后一个numx不参与的情况)\n最后:\n  递推和记忆化搜索本质是相同的,递推写法注意,第一层必须枚举区间长度,先算小区间再算大区间,不要枚举起点终点\n  $g[cnt][num]$为什么规定第cnt个必定不参与,感觉是经典问题了,为了方便状态转移,必须知道最后一个不参与的是谁,用$g[cnt][num][last]$表示前cnt个numx,一共num个不参与,位置最靠后的不参与的是last的情况下的最优解,优化一下的产物\n  类似11111211枚举1时显然要把1一次性合并,没必要dp了,我稍微判断了一下$other * other-other \u0026lt;= cntx * cntx-(cntx-1)*(cntx-1))$时,没必要继续dp,算是常数优化吧,当然,可以更精细\n  我看了官方题解,状态定义非常新颖,转移决策更自然,f(l,r,k)真的很难想到,非常厉害,我的方法虽然慢,但是说明f[i][j]的做法是可行的,还是有点价值的\n  inline int max(int a,int b){return a\u0026gt;b?a:b;} int removeBoxes(int* boxes, int boxesSize){ int f[boxesSize+2][boxesSize+2];//f[i][j]表示i到j区间最优解 int g[boxesSize+2][boxesSize+2],posx[boxesSize+2]; int flags[boxesSize+2]; for (int i = 0; i \u0026lt;= boxesSize; i++) for (int j = 0; j \u0026lt;= boxesSize; j++) f[i][j] = 0; for (int i = 0; i \u0026lt; boxesSize; i++) { flags[i] = 0; f[i][i] = 1; } for (int len = 2; len \u0026lt;= boxesSize; len++) //枚举区间长度 for (int i = 0; i+len-1 \u0026lt; boxesSize; i++) { //枚举起点 int j = i+len-1; //区间i到j int flag = i*10000+j; //一个特殊标记flag判重,防止枚举重复数字 for (int x = i; x \u0026lt;= j; x++) //枚举这个区间最后消除的数字numx if (flags[x] != flag) { flags[x] = flag; int tmp = x?f[i][x-1]:0; //tmp记录numx分割开的子区间最优解的和 int cntx = 1,lastx = x; //cntx为numx的数量,lastx是邻近的前一个numx的下标 posx[0] = i-1; //posx[i]记录第i个numx下标 posx[1] = x; for (int k = x+1; k \u0026lt;= j; k++) { if (boxes[k] == boxes[x]) { cntx++; posx[cntx] = k; tmp += f[lastx+1][k-1]; lastx = k; flags[k] = flag; } else { if (k == j) tmp += f[lastx+1][j]; } } tmp += cntx*cntx; //加上最后消除numx的得分(此处只考虑所有numx都在最后消除) if (tmp \u0026gt; f[i][j]) f[i][j] = tmp; int other = len-cntx; if (cntx==1 || other*other-other \u0026lt;= cntx*cntx-(cntx-1)*(cntx-1)) continue; //优化,极端情况(把所有other集合起来利益不如numx缺少一个的损失)不需要下面计算 for (int cnt = 0; cnt \u0026lt;= cntx; cnt++) for (int num = 0; num \u0026lt;= cntx; num++) g[cnt][num] = -233333; g[0][0] = 0; //初始化 //g[i][j]表示前i个numx,一共j个不参与最后一轮(且第i个不参与)的情况下的最优解 for (int cnt = 1; cnt \u0026lt;= cntx; cnt++) //考虑前cnt个numx for (int num = 1; num \u0026lt;= cnt; num++) //枚举不参与最后一轮的numx的个数 for (int per = 0; per \u0026lt; cnt; per++) { //枚举前驱 -- 上一个不参与的numx是谁 if (posx[cnt] \u0026gt; 0) g[cnt][num] = max(g[cnt][num], g[per][num-1]+f[posx[per]+1][posx[cnt]-1]); else g[cnt][num] = max(g[cnt][num], g[per][num-1]); } for (int num = 1; num \u0026lt;= cntx; num++) f[i][j] = max(f[i][j], g[cntx][num]+num*num); //更新答案 for (int cnt = 1; cnt \u0026lt; cntx; cnt++) for (int num = 1; num \u0026lt;= cnt; num++) f[i][j] = max(f[i][j], g[cnt][num]+num*num+f[posx[cnt]+1][j]); //考虑最后一个numx不参与的情况 } } return f[0][boxesSize-1]; } 作者：wineee 链接：https://leetcode-cn.com/problems/remove-boxes/solution/zhen-zheng-de-fang-fa-er-yong-flr-lai-biao-shi-yi-/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。    时间复杂度：$O(n^5)$,比官方题解高,因为常数比较小,实际表现不算太差,击败6.25% 的用户已经很好了。注意不要数for循环,比如x*cnt的两个循环只能算$O(n)$\n  空间复杂度：$O(n^2)$,击败100.00% 的用户无压力\n ","date":"2020-08-15","permalink":"https://wineee.github.io/post/leetcode_546_dp/","tags":null,"title":"记录一个有趣的dp题目-leetcode 546 移除盒子"},{"content":"实验环境  window 10 版本19041 Microsoft Visual Studio Community 2019 版本 16.6.4  实现功能  绘制常见函数的图像 支持普通函数，极坐标函数，参数方程，直接输入数据点 可以删除指定函数图像 可以在一个坐标系中绘制多条数学曲线 显示坐标轴，网格，刻度值，图例 可以选择不同颜色线型来绘制不同的曲线 当鼠标移动到曲线上某点时，可以显示该点的坐标 可以用鼠标拖动图像 可以进行图形的放大，缩小，定量设置显示范围，自动缩放 普通函数x取值范围可设置为跟随显示范围变化 状态栏实时显示鼠标位置，双击显示鼠标精确位置 重要数据的序列化和反序列化 突变函数(如$floor(x)$)和部分y值接近无穷的函数(如$tan(x)$)无法完美显示  界面展示 设计结构 程序流程及设计  用户输入函数信息，显示函数图像。还可以通过菜单和工具栏更改设置。\n 通过计算样本点，相邻样本点用直线连接，当样本点数量足够大时，可近似看成曲线。 程序所有源文件 CalculatorFunc.cpp介绍  double CalcEquation(CString m_sEquation, bool\u0026amp; succ, char xKey, double xVal) m_sEquation:表达式 succ:计算是否成功 xKey:未知数是\u0026quot;x\u0026quot;还是\u0026quot;t\u0026rdquo; xVal:未知数的值\n  此文件可以单独拿出来(把CString换成string就行)使用 bool succ = true; double ans = CalcEquation(\u0026ldquo;sin(x)+e^x\u0026rdquo;,succ,\u0026lsquo;x\u0026rsquo;,1.1);\n  对方程，分为数（常数，未知数x），双目运算符(+ , - ,* , / , ^ ) ,单目运算符(sin,cos等等)，单目运算符后面是一个完整的子式，如2+cos(x+1)中，x+1就是一个完整的式子，通过递归调用可以求子式的值，如果已知子式值，这个[单目运算符+子式]就是一个已知数了，那剩下的就等效于只有+ , - , * , / , ^ 的公式，用表达式栈法就可以解决。\nFuncData.cpp介绍 FuncData类 成员变量： int FuncCas; //函数类型 CString m_Equation;\t//函数表达式 double minX, maxX;\t//x极值 double maxY, minY;\t//y极值 int stepX;\t//可以理解为样本点的数量 int m_penWidth;\t//画笔宽度 int m_penType;\t//画笔类型 COLORREF m_color;\t//画笔颜色 vector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; vetPoint;\t//储存所有样本点 成员函数： virtual double GetY(double xVal, bool\u0026amp; succ) = 0;//得到未知数为xVal时函数值，succ表示计算是否成功 virtual bool CalcList() = 0;\t//计算vetPoint virtual bool GetNearest(pair\u0026lt;double,double\u0026gt; NowPoint, pair\u0026lt;double, double\u0026gt; \u0026amp;CmpPoint);//获取本函数与NowPoint最近的点 virtual CString GetEquation2();\t//为了得到参数方程第二个函数式 FuncData(); FuncData(CString Equation,double minX,double maxX,int stepX,COLORREF color, int penWidth,int penType);//构造函数 注意:此处派生类只记录特有的成员 NormalFD类 无 PolarFD 类 成员变量 double maxth, minth; //自变量θ取值范围 TwoFD类 成员变量 CString m_EquationY; double maxT, minT; 成员函数 double GetX(double tVal, bool\u0026amp; succ);//参数方程X也需要求值 virtual double GetY(double tVal, bool\u0026amp; succ); DataFD类 成员函数 static int DataFD_Cnt; //记录数据点类型函数数量  mfcplotDoc.cpp介绍  mfcplotDoc中记录着设置信息和函数数据，主要内容如下\npublic: bool m_WillShowGrid; //是否显示网格 bool m_WillShowAxis; //是否显示坐标轴 bool m_WillShowEdge; //是否显示边框 bool m_SingelMode; //单函数模式添加函数自动删除上一个函数 bool m_ForceXrange;\t//普通函数x范围是否固定，不固定的话随显示范围变化 bool m_ShowNearPoint;//鼠标接近函数线时是否显示其坐标 double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//显示范围 FuncData *m_FD;//临时变量 CObList m_List;//记录所有函数信息 public: afx_msg void OnAxisMenu();//坐标轴 afx_msg void OnGridMenu();//网格 afx_msg void OnEdgeMenu();//边框 afx_msg void OnSmallerMenu();//显示范围缩小 0.8 afx_msg void OnBiggerMenu();//显示范围放大 1.25 afx_msg void OnNormalFuncMenu();//增加普通函数 afx_msg void OnMenuSetXyrange();//设置显示范围 afx_msg void OnFuncMode();//单/多函数模式 afx_msg void OnPolarFuncMenu();//增加极坐标函数 afx_msg void OnTwoFuncMenu();//增加参数方程函数 afx_msg void OnDataFuncMenu();//增加数据点型函数 afx_msg void OnFroceXrang();//普通函数x范围是否固定 afx_msg void OnNearpointMenu();//是否显示最近点 afx_msg void OnAutorangeMenu();//自动调整显示范围，正好显示完整函数图像 afx_msg void OnDelfunconeMenu();//删除一个函数 afx_msg void OnDelallMenu();//删除所有函数  mfcplotView.cpp介绍  绘图逻辑是在这里实现的，主要内容如下\npublic: double m_Xmin, m_Xmax, m_Ymin, m_Ymax;//函数显示范围 int nTop, nButton, nLeft, nRight;//对应的逻辑坐标范围 int isMoving;//拖动状态 0不拖动 1拖动模式 2正在拖动 double tmp_Xmin, tmp_Xmax, tmp_Ymin, tmp_Ymax; //拖动模式下，单击鼠标左键，记录起点的显示范围 CPoint m_posStart; //拖动模式下，单击鼠标左键，记录起点的鼠标坐标 //根据鼠标坐标偏移量可以计算显示范围变化量   函数中LPxtoFPx表示把函数坐标x变成pDC可以用的逻辑坐标_x，原理函数坐标范围m_Xmin，m_Xmax到逻辑坐标范围nLeft，nRight（下面函数会给出）等比例的映射。\ndouble CmfcplotView::LPxtoFPx(int x) { return m_Xmin + (1.0 * x - nLeft) * (m_Xmax - m_Xmin) / (1.0 * nRight - nLeft); }   实现坐标转换后就可以进行绘图工作了。\nvoid CmfcplotView::OnDraw(CDC* pDC) { CmfcplotDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; m_Xmin = pDoc-\u0026gt;m_Xmin;//极值保存在Doc中 m_Xmax = pDoc-\u0026gt;m_Xmax; m_Ymin = pDoc-\u0026gt;m_Ymin; m_Ymax = pDoc-\u0026gt;m_Ymax; CRect rect; GetClientRect(\u0026amp;rect);//获得视图区 nTop = (int)round(rect.bottom * 0.1); //函数图像不会占据整个视图区 nButton = (int)round(rect.bottom * 0.9); nLeft = (int)round(rect.right * 0.1); nRight = (int)round(rect.right * 0.9); if (pDoc-\u0026gt;m_WillShowEdge) {//画边框 pDC-\u0026gt;MoveTo(nLeft, nTop); pDC-\u0026gt;LineTo(nLeft, nButton); pDC-\u0026gt;LineTo(nRight, nButton); pDC-\u0026gt;LineTo(nRight, nTop); pDC-\u0026gt;LineTo(nLeft, nTop); } //画x坐标信息 int nX,nY; bool BIGX = abs(m_Xmin) \u0026gt; 100 || abs(m_Xmax) \u0026gt; 100;//x坐标值比较大时，标注更稀 for (nX = nLeft; nX \u0026lt; nRight; nX += (BIGX ? 100 : 50)) { //每隔100/50像素一个标注 CRect textRect(nX - (BIGX ? 50 : 25), nButton + 1, nX + (BIGX ? 50 : 25), nButton + 20);//显示区域 CString xInfo; xInfo.Format(_T(\u0026quot;%.2f\u0026quot;),LPxtoFPx(nX)); pDC-\u0026gt;DrawText(xInfo, \u0026amp;textRect, DT_SINGLELINE | DT_CENTER); //单行,上下左右居中显示 } if (nX - nRight \u0026lt;= (BIGX ? 50 : 25)) {//最后一个x坐标，与前一个标注距离太近则不显示 CRect textRect(nRight, nButton + 1, nRight + 50, nButton + 20); CString xInfo; xInfo.Format(_T(\u0026quot;%.2f\u0026quot;),m_Xmax); pDC-\u0026gt;DrawText(xInfo, \u0026amp;textRect, DT_SINGLELINE | DT_LEFT | DT_TOP); } //y坐标 for (nY = nButton - 50; nY \u0026gt; nTop; nY -= 50) { CRect textRect(nLeft - 200, nY-10, nLeft - 3, nY + 10); CString yInfo; yInfo.Format(_T(\u0026quot;%.2f\u0026quot;), LPytoFPy(nY)); pDC-\u0026gt;DrawText(yInfo, \u0026amp;textRect, DT_SINGLELINE | DT_RIGHT); } if (nTop - nY \u0026lt;= 25) { CRect textRect(nLeft - 200, nTop - 10, nLeft - 3, nTop + 10); CString yInfo; yInfo.Format(_T(\u0026quot;%.2f\u0026quot;),m_Ymax); pDC-\u0026gt;DrawText(yInfo, \u0026amp;textRect, DT_SINGLELINE | DT_BOTTOM | DT_RIGHT); } // 显示网格 if (pDoc-\u0026gt;m_WillShowGrid) { CPen pen(PS_DOT, 1, RGB(100, 100, 100)); //创建笔，虚线，并调整坐标颜色灰色 CPen *pOldPen = (CPen *)pDC-\u0026gt;SelectObject(\u0026amp;pen); for (nX = nLeft+50; nX \u0026lt; nRight; nX += 50) { pDC-\u0026gt;MoveTo(nX, nTop); pDC-\u0026gt;LineTo(nX, nButton); } for (nY = nButton - 50; nY \u0026gt; nTop; nY -= 50) { pDC-\u0026gt;MoveTo(nLeft, nY); pDC-\u0026gt;LineTo(nRight, nY); } pDC-\u0026gt;SelectObject(pOldPen); } // 显示坐标轴 if (pDoc-\u0026gt;m_WillShowAxis) { CPen pen(PS_SOLID, 2, RGB(0, 0, 0)); CPen* pOldPen = (CPen*)pDC-\u0026gt;SelectObject(\u0026amp;pen); int oX = FPxtoLPx(0); int oY = FPytoLPy(0); bool showY = oX \u0026gt;= nLeft \u0026amp;\u0026amp; oX \u0026lt;= nRight; bool showX = oY \u0026gt;= nTop \u0026amp;\u0026amp; oY \u0026lt;= nButton;//判断x,y轴是否在范围内 if (showX) { pDC-\u0026gt;MoveTo(nLeft - 10, oY); pDC-\u0026gt;LineTo(nRight + 10, oY); } if (showY) { pDC-\u0026gt;MoveTo(oX, nButton + 10); pDC-\u0026gt;LineTo(oX, nTop - 10); } if (showX \u0026amp;\u0026amp; showY) { pDC-\u0026gt;TextOutW(oX + 1, oY + 1, _T(\u0026quot;O\u0026quot;)); } if (showX) { pDC-\u0026gt;MoveTo(nRight + 10, oY); pDC-\u0026gt;LineTo(nRight + 5, oY + 5); pDC-\u0026gt;MoveTo(nRight + 10, oY); pDC-\u0026gt;LineTo(nRight + 5, oY - 5); pDC-\u0026gt;TextOutW(nRight + 10, oY, _T(\u0026quot;X轴\u0026quot;)); } if (showY) { pDC-\u0026gt;MoveTo(oX, nTop - 10); pDC-\u0026gt;LineTo(oX - 5, nTop - 5); pDC-\u0026gt;MoveTo(oX, nTop - 10); pDC-\u0026gt;LineTo(oX + 5, nTop - 5); pDC-\u0026gt;TextOutW(oX + 5, nTop - 10, _T(\u0026quot;Y轴\u0026quot;)); } pDC-\u0026gt;SelectObject(pOldPen); } POSITION p = pDoc-\u0026gt;m_List.GetHeadPosition(); int showTop = nTop; while (p != nullptr) { bool shouldMov = true;//一段曲线第一个点MoveTo，其他都是LineTo FuncData* tmpFD = (FuncData*)pDoc-\u0026gt;m_List.GetNext(p); CPen pen(tmpFD-\u0026gt;m_penType, tmpFD-\u0026gt;m_penWidth, tmpFD-\u0026gt;m_color); CPen* pOldPen = (CPen*)pDC-\u0026gt;SelectObject(\u0026amp;pen); if (tmpFD-\u0026gt;FuncCas == CAS_NORMAL) {//动态X坐标模式下，普通函数x范围与视图不同时自动同步 if (pDoc-\u0026gt;m_ForceXrange \u0026amp;\u0026amp; isMoving!=2) if (tmpFD-\u0026gt;minX != m_Xmin || tmpFD-\u0026gt;maxX != m_Xmax) { tmpFD-\u0026gt;minX = m_Xmin; tmpFD-\u0026gt;maxX = m_Xmax; tmpFD-\u0026gt;CalcList(); } } for (auto dot : tmpFD-\u0026gt;vetPoint) { if (dot.first \u0026lt; m_Xmin || dot.first \u0026gt; m_Xmax || dot.second \u0026lt; m_Ymin || dot.second \u0026gt; m_Ymax || dot.second != dot.second) { shouldMov = true; continue; } if (shouldMov) { pDC-\u0026gt;MoveTo(FPxtoLPx(dot.first), FPytoLPy(dot.second)); shouldMov = false; } else pDC-\u0026gt;LineTo(FPxtoLPx(dot.first), FPytoLPy(dot.second)); } pDC-\u0026gt;MoveTo(nRight+5, showTop);//显示图例 pDC-\u0026gt;LineTo(rect.right, showTop); showTop += 5; if (tmpFD-\u0026gt;FuncCas == CAS_NORMAL) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;f(x)=\u0026quot;)+tmpFD-\u0026gt;m_Equation); else if (tmpFD-\u0026gt;FuncCas == CAS_POLAR) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;r(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); else if (tmpFD-\u0026gt;FuncCas == CAS_TWO) { pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;x(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); showTop += 20; pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;y(t)=\u0026quot;) + tmpFD-\u0026gt;GetEquation2()); } else if (tmpFD-\u0026gt;FuncCas == CAS_DATA) pDC-\u0026gt;TextOutW(nRight + 5, showTop, _T(\u0026quot;y(t)=\u0026quot;) + tmpFD-\u0026gt;m_Equation); showTop += 25; pDC-\u0026gt;SelectObject(pOldPen); } }   值得一提的是OnMouseMove的代码，拖动模式下，起点信息已经在OnLButtonDown更新，拖动过程使用了双缓冲绘图防止闪烁。具体原理可参看文末参考资料。\nvoid CmfcplotView::OnMouseMove(UINT nFlags, CPoint point) { // TODO: 在此添加消息处理程序代码和/或调用默认值 更新状态栏，此处省略 if (isMoving==2) { ::SetCursor(LoadCursor(NULL, IDC_SIZEALL)); CmfcplotDoc* pDoc = GetDocument(); double detx = LPxtoFPx(point.x) - LPxtoFPx(m_posStart.x); pDoc-\u0026gt;m_Xmin = tmp_Xmin - detx; pDoc-\u0026gt;m_Xmax = tmp_Xmax - detx; double dety = LPytoFPy(point.y) - LPytoFPy(m_posStart.y); pDoc-\u0026gt;m_Ymin = tmp_Ymin - dety; pDoc-\u0026gt;m_Ymax = tmp_Ymax - dety; CDC* pDC = GetDC(); //创建一个内存中的显示设备 CDC MemDC; MemDC.CreateCompatibleDC(NULL); //创建一个内存中的图像 CBitmap MemBitmap; CRect rect; GetClientRect(\u0026amp;rect); MemBitmap.CreateCompatibleBitmap(pDC, rect.right, rect.bottom); //指定内存显示设备在内存中的图像上画图 MemDC.SelectObject(\u0026amp;MemBitmap); //先用一种颜色作为内存显示设备的背景色 MemDC.FillSolidRect(rect.left, rect.top, rect.right, rect.bottom, RGB(144, 144, 144)); this-\u0026gt;OnDraw(\u0026amp;MemDC); //将内存中画好的图像直接拷贝到屏幕指定区域上 pDC-\u0026gt;BitBlt(rect.left, rect.top, rect.right, rect.bottom, \u0026amp;MemDC, 0, 0, SRCCOPY); //释放相关资源 ReleaseDC(pDC); } else if (isMoving == 1) { ::SetCursor(LoadCursor(NULL, IDC_HAND)); } 显示函数最近点部分，此处省略 CView::OnMouseMove(nFlags, point); }  完整代码 github gitee csdn下载\n参考资料  DrawText函数的讲解 VC双缓冲绘图技术介绍 阎光伟，彭文，徐琳茜. 基于案例的Visual C++程序设计教程[M].北京：清华大学出版社，2012 张晓民. VC++2010应用开发技术[M].北京：机械工业出版社，2013 ","date":"2020-07-20","permalink":"https://wineee.github.io/post/cpplab_mfcplot/","tags":["c++","mfc","lab"],"title":"[VC++课程设计] 用mfc实现数学函数曲线绘制程序"},{"content":"题目描述 申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要$ N $天才能完成，其中第 $ i $ 天至少需要$A_i$个人。 布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$ 天工作到第 $ T_i $ 天，招募费用是每人$C_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长。于是布布找到了你，希望你帮他设计一种最优的招募方案。\n输入格式： 第一行包含两个整数 $N$ , $M$，表示完成项目的天数和可以招募的志愿者的种类。 接下来的一行中包含N 个非负整数，表示每天至少需要的志愿者人数。 接下来的$M$ 行中每行包含三个整数$S_i$, $T_i$, $C_i$，含义如上文所述。为了方便起见，我们可以认为每类志愿者的数量都是无限多的。\n输出格式： 仅包含一个整数，表示你所设计的最优方案的总费用。\n输入样例#1： 3 3 2 3 4 1 2 2 2 3 5 3 3 2 输出样例#1： 14\n说明 $1 ≤ N ≤ 1000$，$1 ≤ M ≤ 10000$，题目中其他所涉及的数据均不超过$2^{31}-1$。\n分析与建模 设第 $i$ 天需要 $x_i$ 个志愿者，记 $a_{ij}$ 为第 $i$ 天第 $j$ 个志愿者是否能工作。 题目要求总费用最低，即求：$Min , z = \\sum_{i=1}^{n}{C_i * x_i}$。 它们需要满足要求：\n\\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3\u0026hellip;+a_{1m}x_m \\geq A_1 \\\\\na_{21}x_1+a_{22}x_2+a_{23}x_3\u0026hellip;+a_{2m}x_m \\geq A_2 \\\\\n\u0026hellip;\\\\\na_{n1}x_1+a_{n2}x_2+a_{n3}x_3\u0026hellip;+a_{nm}x_m \\geq A_n \\\\ x_1,x_2,x_3 \u0026hellip; x_m \\geq 0\\\n\\end{cases}$$\n这明显是一个的线性规划问题,但它不是标准形式,需要一些改造。\n方法一 转化为对偶问题 观察它的对偶问题：$Max , w = \\sum_{i=1}^{m}A_i*y_i$。 设$b_{ij} = a_{ji}$, 为第 $i$ 个志愿者第 $j$ 天是否能工作,新的约束条件为： $$\\begin{cases} b_{11}y_1+b_{12}y_2+b_{13}y_3\u0026hellip;+b_{1n}y_n \\leq C_1 \\\\\nb_{21}y_1+b_{22}y_2+b_{23}y_3\u0026hellip;+b_{2n}y_n \\leq C_2 \\\\\n\u0026hellip;\\\\\nb_{m1}y_1+b_{m2}y_2+b_{m3}y_3\u0026hellip;+b_{mn}y_n \\leq C_n \\\\\ny_1,y_2,y_3 \u0026hellip; y_n \\geq 0\\\\\n\\end{cases}$$\n添加松弛变量后为： $$\\begin{cases} b_{11}y_1+b_{12}y_2+b_{13}y_3\u0026hellip;+b_{1n}y_n+y_{n+1} = C_1 \\\\ b_{21}y_1+b_{22}y_2+b_{23}y_3\u0026hellip;+b_{2n}y_n+y_{n+2} = C_2 \\\\ \u0026hellip;\\\\\nb_{m1}y_1+b_{m2}y_2+b_{m3}y_3\u0026hellip;+b_{mn}y_n+y_{n+m} = C_n \\\\ y_1,y_2,y_3 \u0026hellip; y_{n+m} \\geq 0\\\\\n\\end{cases}$$ 这是线性规划的标准形式，对偶问题可以使用原始单纯型法求解。 根据对偶定理，若原问题有最优解，那么对偶问题也有最优解，且目标函数值相等。题目要的只有目标函数值，所以可以直接求解对偶问题，但这种方法得到的解不是原问题的解，所以这种方法实际上不太合适，不过它只要最基本的单纯形法，故放第一位。 代码如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int M=10005,N=1005,INF=1e9; const double eps=1e-7; int n,m; double a[M][N],b[M],c[N],v,cc[N]; int B[N],P[M]; void Out() { for (int i = 1; i \u0026lt;= m; i++) printf(\u0026quot;%4d\u0026quot;,P[i]); puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } void pivot(int l,int e) { //旋转运算,l换出变量 e换入变量 swap(B[l],P[e]); b[l]/=a[l][e]; for (int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; // 行变换，处理l对应行,将a[l][e]变为1 a[l][e]=1/a[l][e]; for (int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { //其他行，e对应列，除a[l][e]外变为0 b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=-a[i][e]*a[l][e]; } //需要注意的是，e列将对应新的非基变量，即原基变量l对应的列 v += c[e]*b[l]; //x的检验数即x值增加1对答案的影响，新的基变量值为b[l] for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; //更新检验数 c[e] = -c[e]*a[l][e]; } double simplex() { while(true) { int e=1,l=0;//l换出变量 e换入变量 for(int t=2; t\u0026lt;=n; t++) if(c[t]\u0026gt;c[e]) e = t; //找到检验数最大的变量 if (c[e] \u0026lt; eps) return v;//所以检验数\u0026lt;=0，最优解的情况 double mn=INF; for(int i=1;i\u0026lt;=m;i++) //找换出变量，a[i][e]\u0026gt;0且b[i]/a[i][e]最小 if(a[i][e]\u0026gt;eps\u0026amp;\u0026amp;mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF;//无可行解 pivot(l,e); // Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) { cin \u0026gt;\u0026gt; cc[i]; c[i] = cc[i]; } for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[i][j]=1; cin \u0026gt;\u0026gt; b[i]; P[i] = i; } for (int i = 1; i \u0026lt;= n; i++) B[i] = m+i; //Out(); printf(\u0026quot;%d\u0026quot;,(int)simplex()); }  方法二 人工变量法 在加入剩余变量后，分别给每个约束方程加入人工变量$x_{m+n+1},\u0026hellip;,x_{m+n+n}$,得到初始基可行解。 $$\\begin{cases} a_{11}x_1+a_{12}x_2+a_{13}x_3\u0026hellip;+a_{1m}x_m - x_{m+1} + x_{m+n+1} = A_1 \\\\ a_{21}x_1+a_{22}x_2+a_{23}x_3\u0026hellip;+a_{2m}x_m - x_{m+2} + x_{m+n+2} = A_2 \\\\ \u0026hellip;\\\\\na_{n1}x_1+a_{n2}x_2+a_{n3}x_3\u0026hellip;+a_{nm}x_m - x_{m+n} + x_{m+n+n} = A_n \\\\ x_1,x_2,x_3 \u0026hellip; x_m+n+n \\geq 0\\\\\n\\end{cases}$$\n1. 大M法 人工变量不能影响目标函数取值，必须从基变量中换出来。为此，可以在目标函数中把人工变量的系数设成M(一个充分大的数/惩罚系数)，使得在求Min的过程中，人工变量变为非基变量可以大大减小目标函数值 $Min , z = \\sum_{i=1}^{n}{C_i * x_i}+\\sum_{j=m+n+1}^{m+n+n}M*x_j$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const int M=12005,N=1005,INF=1e5; const double eps=1e-6; int n,m; double a[N][M],b[N],c[M],v,cc[M]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } double simplex() { for (int i = 1; i \u0026lt;= n; i++) { cc[i] = c[i]; for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]-INF*a[j][i]; } } while(true) { int e=0,l=0; for (int t=1; t\u0026lt;=n; t++) if (c[t]\u0026lt;-eps) { e = t; break; } if (e == 0) { v = 0; for (int i = 1; i \u0026lt;= m; i++) v += b[i]*cc[B[i]]; return v; } double mn=INF; for(int i=1;i\u0026lt;=m;i++) if(a[i][e]\u0026gt;eps \u0026amp;\u0026amp; mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF; pivot(l,e); //Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i]=1; cin \u0026gt;\u0026gt; c[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][m+i] = -1; a[i][m+n+i] = 1; B[i] = m+n+i; } for (int i = m+n+1; i \u0026lt;= m+n+n; i++) c[i] = INF; m += n+n; swap(n,m); //Out(); printf(\u0026quot;%d\u0026quot;,(int)simplex()); }  2. 两阶段法 两阶段法则更为直接，第一步，目标函数为$Min , w = \\sum_{i=m+1}^{m+n}{x_i}$，即尽量使人工变量取值为0，如果$w\u0026gt;0$，说明人工变量换不出去，即无解。若$w = 0$，说明有可行解，进行第二阶段，把矩阵中人工变量部分删掉，目标函数换回原问题的，即$Min , z = \\sum_{i=1}^{n}{C_i * x_i}$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const int M=12005,N=1005,INF=1e5; const double eps=1e-6; int n,m; int a[N][M],b[N],c[M],v,cc[M],A[M]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1;i\u0026lt;=m;i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1;j\u0026lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1;j\u0026lt;=n;j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } int simplex() { while(true) { int e=0,l=0; for (int t=1; t\u0026lt;=n; t++) if (c[t]\u0026lt;-eps) { e = t; break; } if (e == 0) { v = 0; for (int i = 1; i \u0026lt;= m; i++) { v += b[i]*cc[B[i]]; } return v; } int mn=INF; for(int i=1;i\u0026lt;=m;i++) if(a[i][e]\u0026gt;eps \u0026amp;\u0026amp; mn\u0026gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i; if(mn==INF) return INF; pivot(l,e); //Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i]=1; cin \u0026gt;\u0026gt; A[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][m+i] = -1; a[i][m+n+i] = 1; B[i] = m+n+i; } for (int i = m+n+1; i \u0026lt;= m+n+n; i++) cc[i] = c[i] = 1; m += n+n; swap(n,m); //Out(); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]- 1*a[j][i]; } if (simplex() \u0026lt; eps) { n -= m; for (int i = 1; i \u0026lt;= n; i++) c[i] = cc[i] = A[i]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { c[i] = c[i]- cc[B[j]]*a[j][i]; } printf(\u0026quot;%d\u0026quot;,(int)(simplex())); } else { puts(\u0026quot;Unsolvable!\u0026quot;); } return 0; }  ###方法三 对偶单纯形法\n将所有式子同乘$-1$后得到类似标准形式，但是b列出现负数，不能用原始单纯形法。 整理一下式子：$Max ,z_{'} = \\sum_{i=1}^{n}{-C_i * x_i}$\n$$\\begin{cases} -a_{11}x_1-a_{12}x_2-a_{13}x_3\u0026hellip;-a_{1m}x_m + x_{m+1} = -A_1 \\\\ -a_{21}x_1-a_{22}x_2-a_{23}x_3\u0026hellip;-a_{2m}x_m + x_{m+2} = -A_2 \\\\ \u0026hellip;\\\\\n-a_{n1}x_1-a_{n2}x_2-a_{n3}x_3\u0026hellip;-a_{nm}x_m + x_{m+n} = -A_n \\\\\nx_1,x_2,x_3 \u0026hellip; x_m \\geq 0\\\\\n\\end{cases}$$ 这里只介绍一下步骤。 (1)对线性规划问题是所有检验数\u0026lt;=0,即对偶问题为基可行解。(本题初始既满足)。 (2)检验：若b列都非负，检验数都非正，已达到最优解，停止计算。 (3)按$min[(B^{-1}b)_i,|(B^{-1}b\u0026lt;0)_i]=(B^{-1}b)_l$对应的基变量$x_l$为换出变量 (4)检查$x_l$行各系数$a_{lj}$，若所有$a_{lj}\u0026gt;=0$，说明无解。否则，计算$\\theta = min_j(\\frac{c_j-z_j}{a_{lj}} |a_{lj}\u0026lt;0) = \\frac{c_k-z_k}{a_{lk}}$，以对应的$x_k$ 为换入变量($\\theta$规则保证对偶问题的解仍为可行解)。 (5)以$a_{lk}$为主元素，进行迭代，得到新表。 重复(2)～(5)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int M=12005,N=1205,INF=1e7; const double eps=1e-6; int n,m; double a[N][M],b[N],c[M],v,cc[M],A[N]; int B[N]; void pivot(int l,int e) { b[l]/=a[l][e]; for(int j=1; j\u0026lt;=n; j++) if(j!=e) a[l][j]/=a[l][e]; a[l][e]=1; for(int i=1; i\u0026lt;=m; i++) if(i!=l\u0026amp;\u0026amp;fabs(a[i][e])\u0026gt;0) { b[i] -= a[i][e]*b[l]; for(int j=1; j\u0026lt;=n; j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j]; a[i][e]=0; } for (int j=1; j\u0026lt;=n; j++) if(j!=e) c[j] -= c[e]*a[l][j]; c[e] = 0; B[l] = e; } void Out() { puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;,(int)a[i][j]); printf(\u0026quot; B:%4d b:%4d\\n\u0026quot;,B[i],(int)b[i]); } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%4d\u0026quot;, (int)c[i]); puts(\u0026quot;\\nEnd\u0026quot;); } double dsimplex() { while (true) { int e=1,l=0; for (int t=2; t\u0026lt;=m; t++) if (b[t] \u0026lt; b[e]) e = t; if (b[e] \u0026gt; -eps) { v=0; for (int i = 1; i \u0026lt;= m; i++) v += b[i]*cc[B[i]]; //for (int i = 1; i \u0026lt;= m; i++) v += (-c[n-m+i])*A[i]; return v; } double mn=INF; for (int i = 1; i \u0026lt;= n; i++) if (a[e][i] \u0026lt; -eps \u0026amp;\u0026amp; mn \u0026gt; c[i]/a[e][i]) mn=c[i]/a[e][i],l=i; if (mn==INF) return INF; pivot(e,l); // Out(); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=1; i\u0026lt;=m; i++) { cin \u0026gt;\u0026gt; A[i]; b[i] = -A[i]; } for (int i=1; i\u0026lt;=m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int j=s; j\u0026lt;=t; j++) a[j][i] = -1; cin \u0026gt;\u0026gt; cc[i]; c[i] = -cc[i]; } for (int i = 1; i \u0026lt;= n; i++) { a[i][n+i] = 1; B[i] = n+i; } m += n; swap(n,m); //Out(); printf(\u0026quot;%d\u0026quot;,(int)(dsimplex())); return 0; }  一些补充说明 1.这四个程序在运算速度上没有本质上的差别，实际测试中人工变量法稍慢。\n2.原问题的线性规划模型是一步到位的，但不是标准形式，具体的解决方法有很多，可见线性规划与单纯形法内容丰富，体系比较完备。\n3.在已有的题解中，绝大多数作者是使用网络流来做。本题费用流的建图方法颇有挑战性，而线性规划模型简单很多，程序实现上单纯形法稍微麻烦一点，而这两类方法时间复杂度都比较高而且玄学，难分高下。总的来说，线性规划的方法更方便。\n供参考的资料： https://10420.blog.luogu.org/solution-p3980 | https://blog.csdn.net/little_cats/article/details/81189794 （注：这篇是作为《管理运筹学》自选题写的）\n","date":"2019-06-29","permalink":"https://wineee.github.io/post/cpplab_simplex/","tags":["c++","单纯型"],"title":"[管理运筹学]线性规划\u0026单纯形法的各种姿势(题目：[NOI2008]志愿者招募)"},{"content":"题目描述\n有 n 件工作要分配给 n 个人做。第 i 个人做第 j 件工作产生的效益为 c[i][j] 。试设计一个将 n 件工作分配给 n 个人做的分配方案，使产生的总效益最大。 输入格式： 文件的第 1 行有 1 个正整数 n，表示有 n 件工作要分配给 n个人做。 接下来的n 行中，每行有 n 个整数 c[i][j]，表示第 i个人做第 j 件工作产生的效益为 c[i][j]。 输出格式： 两行分别输出最小总效益和最大总效益。\n求最小总效益就是经典的指派问题，最大总收益只要把c乘-1再求最小就可以。 这里举个例子 n = 5，c为下表\n   12 7 9 7 9     8 9 6 6 6   7 17 12 14 9   15 14 6 6 10   4 10 7 10 9    第一步：每行减去该行最小的数，保证每行都有0。\n   5 0 2 0 2     2 3 0 0 0   0 10 5 7 2   9 8 0 0 4   0 6 3 6 5    第二步：每列减去该列最小的数，保证每行每列都有0。\n   5 0 2 0 2     2 3 0 0 0   0 10 5 7 2   9 8 0 0 4   0 6 3 6 5    第三步： 从单个0元素的行开始，给0加圈，记作O,然后划去所在行的其它0元素，记为X。 第四步： 从单个0元素的列开始，给0加圈，记作O,然后划去所在列的其它0元素，记为X。 重复三四，直到无法标记； 第五步： 若还存在没有画圈的0元素，则从剩余的0元素最少的行(列)开始，选0元素画圈，然后划掉同行同列的其它0元素，反复进行，直到所有0元素均被圈出或划掉为止； 检验： 若O的数目cnt=n，则该指派问题的最优解已经得到。 否则，进行调整。\n   5 O 2 X 2     2 3 X X O   O 10 5 7 2   9 8 O X 4   X 6 3 6 5    例子cnt = 4，少一个O 调整：找最少覆盖所有0的直线\n 对没有O的行打√ 对已打√行中含X所在列打√ 对已打√列中含O所在行打√ 重复2~3, 直至没有要打√的行和列为止 对没有打√的行划横线, 对打√的列划竖线，得到最少覆盖所有0的直线。 取未划线的最小数，未划线的减去这个数，线交点处加上这个数。 返回第一步。  打√后\n   5 O 2 X 2      2 3 X X O    O 10 5 7 2 √3   9 8 O X 4    X 6 3 6 5 √1   √2         调整6后\n   7 0 2 0 2     4 3 0 0 0   0 8 3 5 0   11 8 0 0 4   0 4 1 4 3    正确性初步说明：同一行或同一列减去同一个数不影响最优分配方案\n程序的一点说明：实际计算中， 第五步其实不需要dfs所有情况，模拟即可。相应调整5后可以这样: 设直线数为l，若l小于n，则转调整6；若l=n，则转第五步重新试探。程序直接枚举到最好的情况了，所以省了这个判断。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define N 110 void Out(int a[N][N],int v[N][N],int n) { for (int i = 1; i \u0026lt;= n; i++){ for (int j = 1; j \u0026lt;= n; j++) { if(!v[i][j]) printf(\u0026quot;%4d\u0026quot;,a[i][j]); else printf(\u0026quot; %c\u0026quot;,v[i][j]==1?'O':'X'); } puts(\u0026quot;\u0026quot;); }puts(\u0026quot;End!\u0026quot;); } int HZ[N],LZ[N]; struct Pair { int x,y; Pair(int x = 0,int y = 0):x(x),y(y){} bool operator \u0026lt; (const Pair \u0026amp; b) const { return HZ[this-\u0026gt;x]==HZ[b.x] ? LZ[this-\u0026gt;y]\u0026lt;LZ[b.y] : HZ[this-\u0026gt;x]\u0026lt;HZ[b.x]; } }Pt[N*N]; int FH[N],FL[N]; int Maxx,Mx; int st[N*N],tot,used[N*N]; void dfs(int s,int t,int sum) { if (sum \u0026gt; Mx) { Mx = sum; used[0] = tot;//记录最好方案 for (int i = 1; i \u0026lt;= tot; i++) used[i] = st[i]; } if (Mx == Maxx) return;//已经找到满意解 if (t-s+1+sum \u0026lt;= Mx) return;//乐观估计不如目前最优解 if (s \u0026gt; t) return; if (!FH[Pt[s].x] \u0026amp;\u0026amp; !FL[Pt[s].y]) { //选s点 FH[Pt[s].x] = 1; FL[Pt[s].y] = 1; st[++tot] = s; dfs(s+1,t,sum+1); --tot; FH[Pt[s].x] = 0; FL[Pt[s].y] = 0; } dfs(s+1,t,sum);//不选s点 } int calc(int b[N][N],int n) { int a[N][N],v[N][N]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) a[i][j] = b[i][j]; for (int i = 1; i \u0026lt;= n; i++) { int t = a[i][1]; for (int j = 2; j \u0026lt;= n; j++) if (a[i][j] \u0026lt; t) t = a[i][j]; for (int j = 1; j \u0026lt;= n; j++) a[i][j] -= t; } for (int i = 1; i \u0026lt;= n; i++) { int t = a[1][i]; for (int j = 2; j \u0026lt;= n; j++) if (a[j][i] \u0026lt; t) t = a[j][i]; for (int j = 1; j \u0026lt;= n; j++) a[j][i] -= t; } //先让每行每列都有0 //Out(a,v,n); int H[N],L[N]; while(1) { for (int i = 1; i \u0026lt;= n; i++) { H[i] = L[i] = 0; //H[i]，第i行有多少个0，L为列 FH[i] = FL[i] = 0; //FH[i],第i行有没有画O for (int j = 1; j \u0026lt;= n; j++) v[i][j] = 0;//v[i][j] = 1代表‘O’,-1代表‘X’ } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (a[i][j] == 0) { H[i]++; L[j]++; } int cnt = 0; while (1) { int tpcnt = cnt; for (int i = 1; i \u0026lt;= n; i++) //找每行单独的0画‘O’，同列画‘X’ if (H[i] == 1) { int t = 1; while(a[i][t] || v[i][t]) t++; v[i][t] = 1; cnt++; //cnt记有几个‘O’ H[i]--; L[t]--; FH[i] = 1; FL[t] = 1; for (int j = 1; j \u0026lt;= n; j++) if (a[j][t]==0 \u0026amp;\u0026amp; j!=i \u0026amp;\u0026amp; v[j][t]==0) { v[j][t] = -1; H[j]--; L[t]--; } } for (int i = 1; i \u0026lt;= n; i++) //对称的 if (L[i] == 1) { int t = 1; while(a[t][i] || v[t][i]) t++; v[t][i] = 1; cnt++; H[t]--; L[i]--; FH[t] = 1; FL[i] = 1; for (int j = 1; j \u0026lt;= n; j++) if (a[t][j]==0 \u0026amp;\u0026amp; j!=i \u0026amp;\u0026amp; v[t][j]==0) { v[t][j] = -1; H[t]--; L[j]--; } } if (tpcnt == cnt) break; } //Out(a,v,n); int top = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (a[i][j]==0 \u0026amp;\u0026amp; v[i][j]==0) { Pt[++top] = Pair(i,j); HZ[i]++; LZ[j]++; } sort(Pt+1,Pt+top+1);//同行同列少的排前面 Maxx = n-cnt; Mx = 0; used[0] = 0; dfs(1,top,0);//对剩下的0进行试探画‘O’ cnt += Mx; for (int i = 1; i \u0026lt;= used[0]; i++) { v[Pt[used[i]].x][Pt[used[i]].y] = 1; FH[Pt[used[i]].x] = 1; FL[Pt[used[i]].y] = 1; } //Out(a,v,n); if (cnt == n) { //已经找到 int ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (v[i][j] == 1) ans += b[i][j]; return ans; } int flagx[N],flagy[N]; //对号标记 for (int i = 1; i \u0026lt;= n; i++) flagx[i] = flagy[i] = 0; int cas = 1;//时间戳，每次只检查新增对号行/列 for (int i = 1; i \u0026lt;= n; i++) if (!FH[i]) flagx[i] = cas; bool chang = 1; while (chang) { chang = 0; cas++; for (int i = 1; i \u0026lt;= n; i++) if (flagx[i] == cas-1) for (int j = 1; j \u0026lt;= n; j++) if (v[i][j] == -1) { flagy[j] = cas; chang = 1; } for (int i = 1; i \u0026lt;= n; i++) if (flagy[i] == cas-1) for (int j = 1; j \u0026lt;= n; j++) if (v[j][i] == 1) { flagx[j] = cas; chang = 1; } } int Mi = ~0u\u0026gt;\u0026gt;2; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (flagx[i] \u0026amp;\u0026amp; !flagy[j] \u0026amp;\u0026amp; Mi \u0026gt; a[i][j]) Mi = a[i][j]; //未划线找最小的 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (flagx[i] \u0026amp;\u0026amp; !flagy[j]) //未划线 a[i][j] -= Mi; else if (!flagx[i] \u0026amp;\u0026amp; flagy[j]) //线交点 a[i][j] += Mi; } } int main() { int n,a[N][N],b[N][N]; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i][j]); b[i][j] = -a[i][j]; } printf(\u0026quot;%d\\n%d\u0026quot;,calc(a,n),-calc(b,n)); return 0; } ","date":"2019-06-28","permalink":"https://wineee.github.io/post/cpplab_hungarian_algorithm/","tags":["c++","匈牙利算法"],"title":"[管理运筹学]指派问题的匈牙利算法及其c++实现 (例:「网络流 24 题」分配问题 )"},{"content":"题目 重排9宫 设计内容： 编写软件模拟排九宫。从九宫的某个状态出发，移动格子中的数字，使9宫格中的数字顺序排列，空格在最后。\n设计功能： 1、九宫初始化，绘制九宫初始状态。9宫格中只有一个位置是空的，其它位置分别是1-8的8个数字，\n2、手工输入移动九宫的步骤，如11d(第一行一列格中数字下移)，22r(第二行二列格中数字右移)，23u(第二行三列格中数字上移)等，记录移动后九宫状态，并形象绘制。要求判断移动是否合法。一次只能移动一个数字，并且只能到相邻的空格子中。\n3、记录从初始状态以后的移动步骤。\n4、判断成功状态，并给出成功提示。\n5、你能否让计算机自动求解（思考选作）。\n   7 5 6     8  2   4 3 1    初始状态\n   1 2 3     4 5 6   7 8     完成状态\n程序源代码 /* 输入命令介绍 w 手动输入九宫格（用0表示空白格） m 进入移动模式 11d 第一行一列格中数字下移 22r 第二行二列格中数字右移 23u 第二行三列格中数字上移 ...诸如此类 p 输出从初始状态以后的移动步骤 e 退出移动模式 r 随机生成一个九宫格 f 自动求解 e 退出程序 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int map[3][3]; void swap(int *a,int *b) { int t = *a; *a = *b; *b = t; } // 输出九宫格 void print_map(int map[3][3]) { int i,j; for (i = 0; i \u0026lt; 3; i++) { for (j = 0; j \u0026lt; 3; j++) if(map[i][j]) printf(\u0026quot;%d \u0026quot;,map[i][j]); else printf(\u0026quot; \u0026quot;); puts(\u0026quot;\u0026quot;); } } // 键盘输入九宫格 void write() { int i,j,v[10] = {0};\tfor (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;map[i][j]); v[map[i][j]] = 1; } for (i = 0; i \u0026lt; 9; i++) if (v[i] != 1) { printf(\u0026quot;您的输入不合法，请重试!\\n\u0026quot;); write(); return; } printf(\u0026quot;输入成功!结果如下\\n\u0026quot;); print_map(map);\t} // 随机生成一个九宫格 void random_map() { int i,j; for (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) map[i][j] = i*3+j; for (i = 0; i \u0026lt; 9; i++) swap(\u0026amp;map[rand()%3][rand()%3],\u0026amp;map[rand()%3][rand()%3]); print_map(map); } int in_map(int x,int y) { return x\u0026gt;=0 \u0026amp;\u0026amp; y\u0026gt;=0 \u0026amp;\u0026amp; x\u0026lt;3 \u0026amp;\u0026amp; y\u0026lt;3; } // 编码算法，把九宫格映射成一个int值（9位数） int map_to_int(int a[3][3]) { int ans = 0,i,j; for (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) ans = ans*10+a[i][j]; return ans; } // 键盘输入移动方向 void move() { char s[5]; int st[300][3],top = 0; while (~scanf(\u0026quot;%s\u0026quot;,s)) { if(s[0] == 'e') return; if(s[0] == 'p') { for (int i = 0; i \u0026lt; top; i++) { printf(\u0026quot;第%d行%d列格中数字\u0026quot;,st[i][0]+1,st[i][1]+1); if(st[i][2] == 0) puts(\u0026quot;上移\u0026quot;); else if(st[i][2] == 1) puts(\u0026quot;下移\u0026quot;); else if(st[i][2] == 2) puts(\u0026quot;左移\u0026quot;); else puts(\u0026quot;右移\u0026quot;); } continue; } int dx = 2,dy; switch(s[2]) { case 'u': dx=-1,dy=0,st[top][2]=0; break; case 'd': dx=1,dy=0,st[top][2]=1; break; case 'l': dx=0,dy=-1,st[top][2]=2; break; case 'r': dx=0,dy=1,st[top][2]=3; break; defalt: printf(\u0026quot;输入不合法!\\n\u0026quot;); } if(dx == 2) continue; int x = s[0]-'1',y = s[1]-'1'; if(!in_map(x+dx,y+dy) || !in_map(x,y)) { printf(\u0026quot;输入不合法!\\n\u0026quot;); continue; } swap(\u0026amp;map[x][y],\u0026amp;map[x+dx][y+dy]); st[top][0] = x; st[top++][1] = y; print_map(map); if(map_to_int(map) == 123456780) puts(\u0026quot;这是完成状态!!\u0026quot;); } } #define MAXX 362883 int q[MAXX],head,tail; int dis[MAXX],per[MAXX]; int xx[] = {1,-1,0,0}; int yy[] = {0,0,1,-1}; int next(int x) { return ++x == MAXX ? x = 0 : x; } // 九宫格9个数按照顺序排列其实就是1..9全排列，用康托展开编码 int fac[11] = {1,1,2,6,24,120,720,5040,40320,362880,3628800}; int map_to_order(int a[3][3]) {\tint i,j,ans = 0; for (i = 0; i \u0026lt; 9; i++) { int cnt = 0; for (j = i+1; j \u0026lt; 9; j++) if (a[j/3][j%3] \u0026lt; a[i/3][i%3]) cnt++; ans += cnt*fac[8-i]; } return ans; } // 9位数还原成九宫格 void int_to_map(int x,int a[3][3]) { int i; for (i = 8; ~i; i--,x /= 10) a[i/3][i%3] = x%10; } // bfs求解算法 // 使用两种编码方法是因为9位数易于编码解码， 康托展开可以映射到更小的空间，但难解码（其实可以） int ans[MAXX],top; void find() { head = 1; tail = 2; q[1] = map_to_int(map); if(q[1] == 123456780) { printf(\u0026quot;无需移动！\\n\u0026quot;); return; } int a[3][3],i,x,y,k; for (i = 0; i \u0026lt; MAXX; i++) dis[i] = 0xffffff,per[i] = 0; dis[map_to_order(map)] = 0; while(head != tail) { int_to_map(q[head],a); int old_id = map_to_order(a); for (x = 0; x \u0026lt; 3; x++) for (y = 0; y \u0026lt; 3; y++) for (i = 0; i \u0026lt; 4; i++) if (in_map(x+xx[i],y+yy[i])) { swap(\u0026amp;a[x][y],\u0026amp;a[x+xx[i]][y+yy[i]]); int new_id = map_to_order(a); if (dis[new_id] \u0026gt; dis[old_id]+1) { dis[new_id] = dis[old_id]+1; per[new_id] = q[head]; int id_int = map_to_int(a); if (id_int == 123456780){ printf(\u0026quot;可以通过%d次变换完成\\n\u0026quot;,dis[new_id]);\ttop = 0; for (k = id_int; k; ) { ans[++top] = k; int_to_map(k,a); k = per[map_to_order(a)];\t} int ttop = top; while(top) { printf(\u0026quot;第%d次变换后为：\\n\u0026quot;,ttop-top); int_to_map(ans[top],a); print_map(a);puts(\u0026quot;\u0026quot;); top--; } return; } q[tail] = id_int; tail = next(tail); } swap(\u0026amp;a[x][y],\u0026amp;a[x+xx[i]][y+yy[i]]); } head = next(head); } } int main() { srand(time(0)); char opt; while(~scanf(\u0026quot;%c\u0026quot;,\u0026amp;opt)) { if(opt == 'e') break; else if(opt == 'w') write(); else if(opt == 'm') move(); else if(opt == 'r') random_map(); else if(opt == 'f') find(); } return 0; } ","date":"2019-02-05","permalink":"https://wineee.github.io/post/cpplab_calc_jiugongge/","tags":["康托展开","bfs","c"],"title":"[c语言课程设计] 重排九宫问题"}]